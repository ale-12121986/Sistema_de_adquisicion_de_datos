<<<<<<< HEAD
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.mqtt = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process,global){
'use strict'

/**
 * Module dependencies
 */
var events = require('events')
var Store = require('./store')
var mqttPacket = require('mqtt-packet')
var Writable = require('readable-stream').Writable
var inherits = require('inherits')
var reInterval = require('reinterval')
var validations = require('./validations')
var xtend = require('xtend')
var setImmediate = global.setImmediate || function (callback) {
  // works in node v0.8
  process.nextTick(callback)
}
var defaultConnectOptions = {
  keepalive: 60,
  reschedulePings: true,
  protocolId: 'MQTT',
  protocolVersion: 4,
  reconnectPeriod: 1000,
  connectTimeout: 30 * 1000,
  clean: true,
  resubscribe: true
}
var errors = {
  0: '',
  1: 'Unacceptable protocol version',
  2: 'Identifier rejected',
  3: 'Server unavailable',
  4: 'Bad username or password',
  5: 'Not authorized',
  16: 'No matching subscribers',
  17: 'No subscription existed',
  128: 'Unspecified error',
  129: 'Malformed Packet',
  130: 'Protocol Error',
  131: 'Implementation specific error',
  132: 'Unsupported Protocol Version',
  133: 'Client Identifier not valid',
  134: 'Bad User Name or Password',
  135: 'Not authorized',
  136: 'Server unavailable',
  137: 'Server busy',
  138: 'Banned',
  139: 'Server shutting down',
  140: 'Bad authentication method',
  141: 'Keep Alive timeout',
  142: 'Session taken over',
  143: 'Topic Filter invalid',
  144: 'Topic Name invalid',
  145: 'Packet identifier in use',
  146: 'Packet Identifier not found',
  147: 'Receive Maximum exceeded',
  148: 'Topic Alias invalid',
  149: 'Packet too large',
  150: 'Message rate too high',
  151: 'Quota exceeded',
  152: 'Administrative action',
  153: 'Payload format invalid',
  154: 'Retain not supported',
  155: 'QoS not supported',
  156: 'Use another server',
  157: 'Server moved',
  158: 'Shared Subscriptions not supported',
  159: 'Connection rate exceeded',
  160: 'Maximum connect time',
  161: 'Subscription Identifiers not supported',
  162: 'Wildcard Subscriptions not supported'
}

function defaultId () {
  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)
}

function sendPacket (client, packet, cb) {
  client.emit('packetsend', packet)

  var result = mqttPacket.writeToStream(packet, client.stream, client.options)

  if (!result && cb) {
    client.stream.once('drain', cb)
  } else if (cb) {
    cb()
  }
}

function flush (queue) {
  if (queue) {
    Object.keys(queue).forEach(function (messageId) {
      if (typeof queue[messageId].cb === 'function') {
        queue[messageId].cb(new Error('Connection closed'))
        delete queue[messageId]
      }
    })
  }
}

function flushVolatile (queue) {
  if (queue) {
    Object.keys(queue).forEach(function (messageId) {
      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {
        queue[messageId].cb(new Error('Connection closed'))
        delete queue[messageId]
      }
    })
  }
}

function storeAndSend (client, packet, cb, cbStorePut) {
  client.outgoingStore.put(packet, function storedPacket (err) {
    if (err) {
      return cb && cb(err)
    }
    cbStorePut()
    sendPacket(client, packet, cb)
  })
}

function nop () {}

/**
 * MqttClient constructor
 *
 * @param {Stream} stream - stream
 * @param {Object} [options] - connection options
 * (see Connection#connect)
 */
function MqttClient (streamBuilder, options) {
  var k
  var that = this

  if (!(this instanceof MqttClient)) {
    return new MqttClient(streamBuilder, options)
  }

  this.options = options || {}

  // Defaults
  for (k in defaultConnectOptions) {
    if (typeof this.options[k] === 'undefined') {
      this.options[k] = defaultConnectOptions[k]
    } else {
      this.options[k] = options[k]
    }
  }

  this.options.clientId = (typeof options.clientId === 'string') ? options.clientId : defaultId()

  this.options.customHandleAcks = (options.protocolVersion === 5 && options.customHandleAcks) ? options.customHandleAcks : function () { arguments[3](0) }

  this.streamBuilder = streamBuilder

  // Inflight message storages
  this.outgoingStore = options.outgoingStore || new Store()
  this.incomingStore = options.incomingStore || new Store()

  // Should QoS zero messages be queued when the connection is broken?
  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero

  // map of subscribed topics to support reconnection
  this._resubscribeTopics = {}

  // map of a subscribe messageId and a topic
  this.messageIdToTopic = {}

  // Ping timer, setup in _setupPingTimer
  this.pingTimer = null
  // Is the client connected?
  this.connected = false
  // Are we disconnecting?
  this.disconnecting = false
  // Packet queue
  this.queue = []
  // connack timer
  this.connackTimer = null
  // Reconnect timer
  this.reconnectTimer = null
  // Is processing store?
  this._storeProcessing = false
  // Packet Ids are put into the store during store processing
  this._packetIdsDuringStoreProcessing = {}
  /**
   * MessageIDs starting with 1
   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810
   */
  this.nextId = Math.max(1, Math.floor(Math.random() * 65535))

  // Inflight callbacks
  this.outgoing = {}

  // True if connection is first time.
  this._firstConnection = true

  // Mark disconnected on stream close
  this.on('close', function () {
    this.connected = false
    clearTimeout(this.connackTimer)
  })

  // Send queued packets
  this.on('connect', function () {
    var queue = this.queue

    function deliver () {
      var entry = queue.shift()
      var packet = null

      if (!entry) {
        return
      }

      packet = entry.packet

      that._sendPacket(
        packet,
        function (err) {
          if (entry.cb) {
            entry.cb(err)
          }
          deliver()
        }
      )
    }

    deliver()
  })

  // Clear ping timer
  this.on('close', function () {
    if (that.pingTimer !== null) {
      that.pingTimer.clear()
      that.pingTimer = null
    }
  })

  // Setup reconnect timer on disconnect
  this.on('close', this._setupReconnect)

  events.EventEmitter.call(this)

  this._setupStream()
}
inherits(MqttClient, events.EventEmitter)

/**
 * setup the event handlers in the inner stream.
 *
 * @api private
 */
MqttClient.prototype._setupStream = function () {
  var connectPacket
  var that = this
  var writable = new Writable()
  var parser = mqttPacket.parser(this.options)
  var completeParse = null
  var packets = []

  this._clearReconnect()

  this.stream = this.streamBuilder(this)

  parser.on('packet', function (packet) {
    packets.push(packet)
  })

  function nextTickWork () {
    if (packets.length) {
      process.nextTick(work)
    } else {
      var done = completeParse
      completeParse = null
      done()
    }
  }

  function work () {
    var packet = packets.shift()

    if (packet) {
      that._handlePacket(packet, nextTickWork)
    } else {
      var done = completeParse
      completeParse = null
      if (done) done()
    }
  }

  writable._write = function (buf, enc, done) {
    completeParse = done
    parser.parse(buf)
    work()
  }

  this.stream.pipe(writable)

  // Suppress connection errors
  this.stream.on('error', nop)

  // Echo stream close
  this.stream.on('close', function () {
    flushVolatile(that.outgoing)
    that.emit('close')
  })

  // Send a connect packet
  connectPacket = Object.create(this.options)
  connectPacket.cmd = 'connect'
  // avoid message queue
  sendPacket(this, connectPacket)

  // Echo connection errors
  parser.on('error', this.emit.bind(this, 'error'))

  // auth
  if (this.options.properties) {
    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {
      this.emit('error', new Error('Packet has no Authentication Method'))
      return this
    }
    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {
      var authPacket = xtend({cmd: 'auth', reasonCode: 0}, this.options.authPacket)
      sendPacket(this, authPacket)
    }
  }

  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent
  this.stream.setMaxListeners(1000)

  clearTimeout(this.connackTimer)
  this.connackTimer = setTimeout(function () {
    that._cleanUp(true)
  }, this.options.connectTimeout)
}

MqttClient.prototype._handlePacket = function (packet, done) {
  var options = this.options

  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {
    this.emit('error', new Error('exceeding packets size ' + packet.cmd))
    this.end({reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' }})
    return this
  }

  this.emit('packetreceive', packet)

  switch (packet.cmd) {
    case 'publish':
      this._handlePublish(packet, done)
      break
    case 'puback':
    case 'pubrec':
    case 'pubcomp':
    case 'suback':
    case 'unsuback':
      this._handleAck(packet)
      done()
      break
    case 'pubrel':
      this._handlePubrel(packet, done)
      break
    case 'connack':
      this._handleConnack(packet)
      done()
      break
    case 'pingresp':
      this._handlePingresp(packet)
      done()
      break
    case 'disconnect':
      this._handleDisconnect(packet)
      done()
      break
    default:
      // do nothing
      // maybe we should do an error handling
      // or just log it
      break
  }
}

MqttClient.prototype._checkDisconnecting = function (callback) {
  if (this.disconnecting) {
    if (callback) {
      callback(new Error('client disconnecting'))
    } else {
      this.emit('error', new Error('client disconnecting'))
    }
  }
  return this.disconnecting
}

/**
 * publish - publish <message> to <topic>
 *
 * @param {String} topic - topic to publish to
 * @param {String, Buffer} message - message to publish
 * @param {Object} [opts] - publish options, includes:
 *    {Number} qos - qos level to publish on
 *    {Boolean} retain - whether or not to retain the message
 *    {Boolean} dup - whether or not mark a message as duplicate
 *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`
 * @param {Function} [callback] - function(err){}
 *    called when publish succeeds or fails
 * @returns {MqttClient} this - for chaining
 * @api public
 *
 * @example client.publish('topic', 'message');
 * @example
 *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});
 * @example client.publish('topic', 'message', console.log);
 */
MqttClient.prototype.publish = function (topic, message, opts, callback) {
  var packet
  var options = this.options

  // .publish(topic, payload, cb);
  if (typeof opts === 'function') {
    callback = opts
    opts = null
  }

  // default opts
  var defaultOpts = {qos: 0, retain: false, dup: false}
  opts = xtend(defaultOpts, opts)

  if (this._checkDisconnecting(callback)) {
    return this
  }

  packet = {
    cmd: 'publish',
    topic: topic,
    payload: message,
    qos: opts.qos,
    retain: opts.retain,
    messageId: this._nextId(),
    dup: opts.dup
  }

  if (options.protocolVersion === 5) {
    packet.properties = opts.properties
    if ((!options.properties && packet.properties && packet.properties.topicAlias) || ((opts.properties && options.properties) &&
      ((opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum) ||
        (!options.properties.topicAliasMaximum && opts.properties.topicAlias)))) {
      /*
      if we are don`t setup topic alias or
      topic alias maximum less than topic alias or
      server don`t give topic alias maximum,
      we are removing topic alias from packet
      */
      delete packet.properties.topicAlias
    }
  }

  switch (opts.qos) {
    case 1:
    case 2:
      // Add to callbacks
      this.outgoing[packet.messageId] = {
        volatile: false,
        cb: callback || nop
      }
      if (this._storeProcessing) {
        this._packetIdsDuringStoreProcessing[packet.messageId] = false
        this._storePacket(packet, undefined, opts.cbStorePut)
      } else {
        this._sendPacket(packet, undefined, opts.cbStorePut)
      }
      break
    default:
      if (this._storeProcessing) {
        this._storePacket(packet, callback, opts.cbStorePut)
      } else {
        this._sendPacket(packet, callback, opts.cbStorePut)
      }
      break
  }

  return this
}

/**
 * subscribe - subscribe to <topic>
 *
 * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}
 * @param {Object} [opts] - optional subscription options, includes:
 *    {Number} qos - subscribe qos level
 * @param {Function} [callback] - function(err, granted){} where:
 *    {Error} err - subscription error (none at the moment!)
 *    {Array} granted - array of {topic: 't', qos: 0}
 * @returns {MqttClient} this - for chaining
 * @api public
 * @example client.subscribe('topic');
 * @example client.subscribe('topic', {qos: 1});
 * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);
 * @example client.subscribe('topic', console.log);
 */
MqttClient.prototype.subscribe = function () {
  var packet
  var args = new Array(arguments.length)
  for (var i = 0; i < arguments.length; i++) {
    args[i] = arguments[i]
  }
  var subs = []
  var obj = args.shift()
  var resubscribe = obj.resubscribe
  var callback = args.pop() || nop
  var opts = args.pop()
  var invalidTopic
  var that = this
  var version = this.options.protocolVersion

  delete obj.resubscribe

  if (typeof obj === 'string') {
    obj = [obj]
  }

  if (typeof callback !== 'function') {
    opts = callback
    callback = nop
  }

  invalidTopic = validations.validateTopics(obj)
  if (invalidTopic !== null) {
    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))
    return this
  }

  if (this._checkDisconnecting(callback)) {
    return this
  }

  var defaultOpts = {
    qos: 0
  }
  if (version === 5) {
    defaultOpts.nl = false
    defaultOpts.rap = false
    defaultOpts.rh = 0
  }
  opts = xtend(defaultOpts, opts)

  if (Array.isArray(obj)) {
    obj.forEach(function (topic) {
      if (!that._resubscribeTopics.hasOwnProperty(topic) ||
        that._resubscribeTopics[topic].qos < opts.qos ||
          resubscribe) {
        var currentOpts = {
          topic: topic,
          qos: opts.qos
        }
        if (version === 5) {
          currentOpts.nl = opts.nl
          currentOpts.rap = opts.rap
          currentOpts.rh = opts.rh
          currentOpts.properties = opts.properties
        }
        subs.push(currentOpts)
      }
    })
  } else {
    Object
      .keys(obj)
      .forEach(function (k) {
        if (!that._resubscribeTopics.hasOwnProperty(k) ||
          that._resubscribeTopics[k].qos < obj[k].qos ||
            resubscribe) {
          var currentOpts = {
            topic: k,
            qos: obj[k].qos
          }
          if (version === 5) {
            currentOpts.nl = obj[k].nl
            currentOpts.rap = obj[k].rap
            currentOpts.rh = obj[k].rh
            currentOpts.properties = opts.properties
          }
          subs.push(currentOpts)
        }
      })
  }

  packet = {
    cmd: 'subscribe',
    subscriptions: subs,
    qos: 1,
    retain: false,
    dup: false,
    messageId: this._nextId()
  }

  if (opts.properties) {
    packet.properties = opts.properties
  }

  if (!subs.length) {
    callback(null, [])
    return
  }

  // subscriptions to resubscribe to in case of disconnect
  if (this.options.resubscribe) {
    var topics = []
    subs.forEach(function (sub) {
      if (that.options.reconnectPeriod > 0) {
        var topic = { qos: sub.qos }
        if (version === 5) {
          topic.nl = sub.nl || false
          topic.rap = sub.rap || false
          topic.rh = sub.rh || 0
          topic.properties = sub.properties
        }
        that._resubscribeTopics[sub.topic] = topic
        topics.push(sub.topic)
      }
    })
    that.messageIdToTopic[packet.messageId] = topics
  }

  this.outgoing[packet.messageId] = {
    volatile: true,
    cb: function (err, packet) {
      if (!err) {
        var granted = packet.granted
        for (var i = 0; i < granted.length; i += 1) {
          subs[i].qos = granted[i]
        }
      }

      callback(err, subs)
    }
  }

  this._sendPacket(packet)

  return this
}

/**
 * unsubscribe - unsubscribe from topic(s)
 *
 * @param {String, Array} topic - topics to unsubscribe from
 * @param {Object} [opts] - optional subscription options, includes:
 *    {Object} properties - properties of unsubscribe packet
 * @param {Function} [callback] - callback fired on unsuback
 * @returns {MqttClient} this - for chaining
 * @api public
 * @example client.unsubscribe('topic');
 * @example client.unsubscribe('topic', console.log);
 */
MqttClient.prototype.unsubscribe = function () {
  var packet = {
    cmd: 'unsubscribe',
    qos: 1,
    messageId: this._nextId()
  }
  var that = this
  var args = new Array(arguments.length)
  for (var i = 0; i < arguments.length; i++) {
    args[i] = arguments[i]
  }
  var topic = args.shift()
  var callback = args.pop() || nop
  var opts = args.pop()

  if (typeof topic === 'string') {
    topic = [topic]
  }

  if (typeof callback !== 'function') {
    opts = callback
    callback = nop
  }

  if (this._checkDisconnecting(callback)) {
    return this
  }

  if (typeof topic === 'string') {
    packet.unsubscriptions = [topic]
  } else if (typeof topic === 'object' && topic.length) {
    packet.unsubscriptions = topic
  }

  if (this.options.resubscribe) {
    packet.unsubscriptions.forEach(function (topic) {
      delete that._resubscribeTopics[topic]
    })
  }

  if (typeof opts === 'object' && opts.properties) {
    packet.properties = opts.properties
  }

  this.outgoing[packet.messageId] = {
    volatile: true,
    cb: callback
  }

  this._sendPacket(packet)

  return this
}

/**
 * end - close connection
 *
 * @returns {MqttClient} this - for chaining
 * @param {Boolean} force - do not wait for all in-flight messages to be acked
 * @param {Function} cb - called when the client has been closed
 *
 * @api public
 */
MqttClient.prototype.end = function () {
  var that = this

  var force = arguments[0]
  var opts = arguments[1]
  var cb = arguments[2]

  if (force == null || typeof force !== 'boolean') {
    cb = opts || nop
    opts = force
    force = false
    if (typeof opts !== 'object') {
      cb = opts
      opts = null
      if (typeof cb !== 'function') {
        cb = nop
      }
    }
  }

  if (typeof opts !== 'object') {
    cb = opts
    opts = null
  }

  cb = cb || nop

  function closeStores () {
    that.disconnected = true
    that.incomingStore.close(function () {
      that.outgoingStore.close(function () {
        if (cb) {
          cb.apply(null, arguments)
        }
        that.emit('end')
      })
    })
    if (that._deferredReconnect) {
      that._deferredReconnect()
    }
  }

  function finish () {
    // defer closesStores of an I/O cycle,
    // just to make sure things are
    // ok for websockets
    that._cleanUp(force, setImmediate.bind(null, closeStores), opts)
  }

  if (this.disconnecting) {
    return this
  }

  this._clearReconnect()

  this.disconnecting = true

  if (!force && Object.keys(this.outgoing).length > 0) {
    // wait 10ms, just to be sure we received all of it
    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))
  } else {
    finish()
  }

  return this
}

/**
 * removeOutgoingMessage - remove a message in outgoing store
 * the outgoing callback will be called withe Error('Message removed') if the message is removed
 *
 * @param {Number} mid - messageId to remove message
 * @returns {MqttClient} this - for chaining
 * @api public
 *
 * @example client.removeOutgoingMessage(client.getLastMessageId());
 */
MqttClient.prototype.removeOutgoingMessage = function (mid) {
  var cb = this.outgoing[mid] ? this.outgoing[mid].cb : null
  delete this.outgoing[mid]
  this.outgoingStore.del({messageId: mid}, function () {
    cb(new Error('Message removed'))
  })
  return this
}

/**
 * reconnect - connect again using the same options as connect()
 *
 * @param {Object} [opts] - optional reconnect options, includes:
 *    {Store} incomingStore - a store for the incoming packets
 *    {Store} outgoingStore - a store for the outgoing packets
 *    if opts is not given, current stores are used
 * @returns {MqttClient} this - for chaining
 *
 * @api public
 */
MqttClient.prototype.reconnect = function (opts) {
  var that = this
  var f = function () {
    if (opts) {
      that.options.incomingStore = opts.incomingStore
      that.options.outgoingStore = opts.outgoingStore
    } else {
      that.options.incomingStore = null
      that.options.outgoingStore = null
    }
    that.incomingStore = that.options.incomingStore || new Store()
    that.outgoingStore = that.options.outgoingStore || new Store()
    that.disconnecting = false
    that.disconnected = false
    that._deferredReconnect = null
    that._reconnect()
  }

  if (this.disconnecting && !this.disconnected) {
    this._deferredReconnect = f
  } else {
    f()
  }
  return this
}

/**
 * _reconnect - implement reconnection
 * @api privateish
 */
MqttClient.prototype._reconnect = function () {
  this.emit('reconnect')
  this._setupStream()
}

/**
 * _setupReconnect - setup reconnect timer
 */
MqttClient.prototype._setupReconnect = function () {
  var that = this

  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {
    if (!this.reconnecting) {
      this.emit('offline')
      this.reconnecting = true
    }
    that.reconnectTimer = setInterval(function () {
      that._reconnect()
    }, that.options.reconnectPeriod)
  }
}

/**
 * _clearReconnect - clear the reconnect timer
 */
MqttClient.prototype._clearReconnect = function () {
  if (this.reconnectTimer) {
    clearInterval(this.reconnectTimer)
    this.reconnectTimer = null
  }
}

/**
 * _cleanUp - clean up on connection end
 * @api private
 */
MqttClient.prototype._cleanUp = function (forced, done) {
  var opts = arguments[2]
  if (done) {
    this.stream.on('close', done)
  }

  if (forced) {
    if ((this.options.reconnectPeriod === 0) && this.options.clean) {
      flush(this.outgoing)
    }
    this.stream.destroy()
  } else {
    var packet = xtend({ cmd: 'disconnect' }, opts)
    this._sendPacket(
      packet,
      setImmediate.bind(
        null,
        this.stream.end.bind(this.stream)
      )
    )
  }

  if (!this.disconnecting) {
    this._clearReconnect()
    this._setupReconnect()
  }

  if (this.pingTimer !== null) {
    this.pingTimer.clear()
    this.pingTimer = null
  }

  if (done && !this.connected) {
    this.stream.removeListener('close', done)
    done()
  }
}

/**
 * _sendPacket - send or queue a packet
 * @param {String} type - packet type (see `protocol`)
 * @param {Object} packet - packet options
 * @param {Function} cb - callback when the packet is sent
 * @param {Function} cbStorePut - called when message is put into outgoingStore
 * @api private
 */
MqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {
  cbStorePut = cbStorePut || nop

  if (!this.connected) {
    this._storePacket(packet, cb, cbStorePut)
    return
  }

  // When sending a packet, reschedule the ping timer
  this._shiftPingInterval()

  switch (packet.cmd) {
    case 'publish':
      break
    case 'pubrel':
      storeAndSend(this, packet, cb, cbStorePut)
      return
    default:
      sendPacket(this, packet, cb)
      return
  }

  switch (packet.qos) {
    case 2:
    case 1:
      storeAndSend(this, packet, cb, cbStorePut)
      break
    /**
     * no need of case here since it will be caught by default
     * and jshint comply that before default it must be a break
     * anyway it will result in -1 evaluation
     */
    case 0:
      /* falls through */
    default:
      sendPacket(this, packet, cb)
      break
  }
}

/**
 * _storePacket - queue a packet
 * @param {String} type - packet type (see `protocol`)
 * @param {Object} packet - packet options
 * @param {Function} cb - callback when the packet is sent
 * @param {Function} cbStorePut - called when message is put into outgoingStore
 * @api private
 */
MqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {
  cbStorePut = cbStorePut || nop

  if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {
    this.queue.push({ packet: packet, cb: cb })
  } else if (packet.qos > 0) {
    cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null
    this.outgoingStore.put(packet, function (err) {
      if (err) {
        return cb && cb(err)
      }
      cbStorePut()
    })
  } else if (cb) {
    cb(new Error('No connection to broker'))
  }
}

/**
 * _setupPingTimer - setup the ping timer
 *
 * @api private
 */
MqttClient.prototype._setupPingTimer = function () {
  var that = this

  if (!this.pingTimer && this.options.keepalive) {
    this.pingResp = true
    this.pingTimer = reInterval(function () {
      that._checkPing()
    }, this.options.keepalive * 1000)
  }
}

/**
 * _shiftPingInterval - reschedule the ping interval
 *
 * @api private
 */
MqttClient.prototype._shiftPingInterval = function () {
  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {
    this.pingTimer.reschedule(this.options.keepalive * 1000)
  }
}
/**
 * _checkPing - check if a pingresp has come back, and ping the server again
 *
 * @api private
 */
MqttClient.prototype._checkPing = function () {
  if (this.pingResp) {
    this.pingResp = false
    this._sendPacket({ cmd: 'pingreq' })
  } else {
    // do a forced cleanup since socket will be in bad shape
    this._cleanUp(true)
  }
}

/**
 * _handlePingresp - handle a pingresp
 *
 * @api private
 */
MqttClient.prototype._handlePingresp = function () {
  this.pingResp = true
}

/**
 * _handleConnack
 *
 * @param {Object} packet
 * @api private
 */

MqttClient.prototype._handleConnack = function (packet) {
  var options = this.options
  var version = options.protocolVersion
  var rc = version === 5 ? packet.reasonCode : packet.returnCode

  clearTimeout(this.connackTimer)

  if (packet.properties) {
    if (packet.properties.topicAliasMaximum) {
      if (!options.properties) { options.properties = {} }
      options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum
    }
    if (packet.properties.serverKeepAlive && options.keepalive) {
      options.keepalive = packet.properties.serverKeepAlive
      this._shiftPingInterval()
    }
    if (packet.properties.maximumPacketSize) {
      if (!options.properties) { options.properties = {} }
      options.properties.maximumPacketSize = packet.properties.maximumPacketSize
    }
  }

  if (rc === 0) {
    this.reconnecting = false
    this._onConnect(packet)
  } else if (rc > 0) {
    var err = new Error('Connection refused: ' + errors[rc])
    err.code = rc
    this.emit('error', err)
  }
}

/**
 * _handlePublish
 *
 * @param {Object} packet
 * @api private
 */
/*
those late 2 case should be rewrite to comply with coding style:

case 1:
case 0:
  // do not wait sending a puback
  // no callback passed
  if (1 === qos) {
    this._sendPacket({
      cmd: 'puback',
      messageId: mid
    });
  }
  // emit the message event for both qos 1 and 0
  this.emit('message', topic, message, packet);
  this.handleMessage(packet, done);
  break;
default:
  // do nothing but every switch mus have a default
  // log or throw an error about unknown qos
  break;

for now i just suppressed the warnings
*/
MqttClient.prototype._handlePublish = function (packet, done) {
  done = typeof done !== 'undefined' ? done : nop
  var topic = packet.topic.toString()
  var message = packet.payload
  var qos = packet.qos
  var mid = packet.messageId
  var that = this
  var options = this.options
  var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153]

  switch (qos) {
    case 2: {
      options.customHandleAcks(topic, message, packet, function (error, code) {
        if (!(error instanceof Error)) {
          code = error
          error = null
        }
        if (error) { return that.emit('error', error) }
        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for pubrec')) }
        if (code) {
          that._sendPacket({cmd: 'pubrec', messageId: mid, reasonCode: code}, done)
        } else {
          that.incomingStore.put(packet, function () {
            that._sendPacket({cmd: 'pubrec', messageId: mid}, done)
          })
        }
      })
      break
    }
    case 1: {
      // emit the message event
      options.customHandleAcks(topic, message, packet, function (error, code) {
        if (!(error instanceof Error)) {
          code = error
          error = null
        }
        if (error) { return that.emit('error', error) }
        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for puback')) }
        if (!code) { that.emit('message', topic, message, packet) }
        that.handleMessage(packet, function (err) {
          if (err) {
            return done && done(err)
          }
          that._sendPacket({cmd: 'puback', messageId: mid, reasonCode: code}, done)
        })
      })
      break
    }
    case 0:
      // emit the message event
      this.emit('message', topic, message, packet)
      this.handleMessage(packet, done)
      break
    default:
      // do nothing
      // log or throw an error about unknown qos
      break
  }
}

/**
 * Handle messages with backpressure support, one at a time.
 * Override at will.
 *
 * @param Packet packet the packet
 * @param Function callback call when finished
 * @api public
 */
MqttClient.prototype.handleMessage = function (packet, callback) {
  callback()
}

/**
 * _handleAck
 *
 * @param {Object} packet
 * @api private
 */

MqttClient.prototype._handleAck = function (packet) {
  /* eslint no-fallthrough: "off" */
  var mid = packet.messageId
  var type = packet.cmd
  var response = null
  var cb = this.outgoing[mid] ? this.outgoing[mid].cb : null
  var that = this
  var err

  if (!cb) {
    // Server sent an ack in error, ignore it.
    return
  }

  // Process
  switch (type) {
    case 'pubcomp':
      // same thing as puback for QoS 2
    case 'puback':
      var pubackRC = packet.reasonCode
      // Callback - we're done
      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {
        err = new Error('Publish error: ' + errors[pubackRC])
        err.code = pubackRC
        cb(err, packet)
      }
      delete this.outgoing[mid]
      this.outgoingStore.del(packet, cb)
      break
    case 'pubrec':
      response = {
        cmd: 'pubrel',
        qos: 2,
        messageId: mid
      }
      var pubrecRC = packet.reasonCode

      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {
        err = new Error('Publish error: ' + errors[pubrecRC])
        err.code = pubrecRC
        cb(err, packet)
      } else {
        this._sendPacket(response)
      }
      break
    case 'suback':
      delete this.outgoing[mid]
      for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {
        if ((packet.granted[grantedI] & 0x80) !== 0) {
          // suback with Failure status
          var topics = this.messageIdToTopic[mid]
          if (topics) {
            topics.forEach(function (topic) {
              delete that._resubscribeTopics[topic]
            })
          }
        }
      }
      cb(null, packet)
      break
    case 'unsuback':
      delete this.outgoing[mid]
      cb(null)
      break
    default:
      that.emit('error', new Error('unrecognized packet type'))
  }

  if (this.disconnecting &&
      Object.keys(this.outgoing).length === 0) {
    this.emit('outgoingEmpty')
  }
}

/**
 * _handlePubrel
 *
 * @param {Object} packet
 * @api private
 */
MqttClient.prototype._handlePubrel = function (packet, callback) {
  callback = typeof callback !== 'undefined' ? callback : nop
  var mid = packet.messageId
  var that = this

  var comp = {cmd: 'pubcomp', messageId: mid}

  that.incomingStore.get(packet, function (err, pub) {
    if (!err) {
      that.emit('message', pub.topic, pub.payload, pub)
      that.handleMessage(pub, function (err) {
        if (err) {
          return callback(err)
        }
        that.incomingStore.del(pub, nop)
        that._sendPacket(comp, callback)
      })
    } else {
      that._sendPacket(comp, callback)
    }
  })
}

/**
 * _handleDisconnect
 *
 * @param {Object} packet
 * @api private
 */
MqttClient.prototype._handleDisconnect = function (packet) {
  this.emit('disconnect', packet)
}

/**
 * _nextId
 * @return unsigned int
 */
MqttClient.prototype._nextId = function () {
  // id becomes current state of this.nextId and increments afterwards
  var id = this.nextId++
  // Ensure 16 bit unsigned int (max 65535, nextId got one higher)
  if (this.nextId === 65536) {
    this.nextId = 1
  }
  return id
}

/**
 * getLastMessageId
 * @return unsigned int
 */
MqttClient.prototype.getLastMessageId = function () {
  return (this.nextId === 1) ? 65535 : (this.nextId - 1)
}

/**
 * _resubscribe
 * @api private
 */
MqttClient.prototype._resubscribe = function (connack) {
  var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)
  if (!this._firstConnection &&
      (this.options.clean || (this.options.protocolVersion === 5 && !connack.sessionPresent)) &&
      _resubscribeTopicsKeys.length > 0) {
    if (this.options.resubscribe) {
      if (this.options.protocolVersion === 5) {
        for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {
          var resubscribeTopic = {}
          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]]
          resubscribeTopic.resubscribe = true
          this.subscribe(resubscribeTopic, {properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties})
        }
      } else {
        this._resubscribeTopics.resubscribe = true
        this.subscribe(this._resubscribeTopics)
      }
    } else {
      this._resubscribeTopics = {}
    }
  }

  this._firstConnection = false
}

/**
 * _onConnect
 *
 * @api private
 */
MqttClient.prototype._onConnect = function (packet) {
  if (this.disconnected) {
    this.emit('connect', packet)
    return
  }

  var that = this

  this._setupPingTimer()
  this._resubscribe(packet)

  this.connected = true

  function startStreamProcess () {
    var outStore = that.outgoingStore.createStream()

    function clearStoreProcessing () {
      that._storeProcessing = false
      that._packetIdsDuringStoreProcessing = {}
    }

    that.once('close', remove)
    outStore.on('error', function (err) {
      clearStoreProcessing()
      that.removeListener('close', remove)
      that.emit('error', err)
    })

    function remove () {
      outStore.destroy()
      outStore = null
      clearStoreProcessing()
    }

    function storeDeliver () {
      // edge case, we wrapped this twice
      if (!outStore) {
        return
      }
      that._storeProcessing = true

      var packet = outStore.read(1)

      var cb

      if (!packet) {
        // read when data is available in the future
        outStore.once('readable', storeDeliver)
        return
      }

      // Skip already processed store packets
      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {
        storeDeliver()
        return
      }

      // Avoid unnecessary stream read operations when disconnected
      if (!that.disconnecting && !that.reconnectTimer) {
        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null
        that.outgoing[packet.messageId] = {
          volatile: false,
          cb: function (err, status) {
            // Ensure that the original callback passed in to publish gets invoked
            if (cb) {
              cb(err, status)
            }

            storeDeliver()
          }
        }
        that._packetIdsDuringStoreProcessing[packet.messageId] = true
        that._sendPacket(packet)
      } else if (outStore.destroy) {
        outStore.destroy()
      }
    }

    outStore.on('end', function () {
      var allProcessed = true
      for (var id in that._packetIdsDuringStoreProcessing) {
        if (!that._packetIdsDuringStoreProcessing[id]) {
          allProcessed = false
          break
        }
      }
      if (allProcessed) {
        clearStoreProcessing()
        that.removeListener('close', remove)
        that.emit('connect', packet)
      } else {
        startStreamProcess()
      }
    })
    storeDeliver()
  }
  // start flowing
  startStreamProcess()
}

module.exports = MqttClient

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./store":7,"./validations":8,"_process":92,"events":13,"inherits":80,"mqtt-packet":84,"readable-stream":108,"reinterval":109,"xtend":121}],2:[function(require,module,exports){
(function (Buffer){
'use strict'

var Transform = require('readable-stream').Transform
var duplexify = require('duplexify')
var base64 = require('base64-js')

/* global FileReader */
var my
var proxy
var stream
var isInitialized = false

function buildProxy () {
  var proxy = new Transform()
  proxy._write = function (chunk, encoding, next) {
    my.sendSocketMessage({
      data: chunk.buffer,
      success: function () {
        next()
      },
      fail: function () {
        next(new Error())
      }
    })
  }
  proxy._flush = function socketEnd (done) {
    my.closeSocket({
      success: function () {
        done()
      }
    })
  }

  return proxy
}

function setDefaultOpts (opts) {
  if (!opts.hostname) {
    opts.hostname = 'localhost'
  }
  if (!opts.path) {
    opts.path = '/'
  }

  if (!opts.wsOptions) {
    opts.wsOptions = {}
  }
}

function buildUrl (opts, client) {
  var protocol = opts.protocol === 'alis' ? 'wss' : 'ws'
  var url = protocol + '://' + opts.hostname + opts.path
  if (opts.port && opts.port !== 80 && opts.port !== 443) {
    url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path
  }
  if (typeof (opts.transformWsUrl) === 'function') {
    url = opts.transformWsUrl(url, opts, client)
  }
  return url
}

function bindEventHandler () {
  if (isInitialized) return

  isInitialized = true

  my.onSocketOpen(function () {
    stream.setReadable(proxy)
    stream.setWritable(proxy)
    stream.emit('connect')
  })

  my.onSocketMessage(function (res) {
    if (typeof res.data === 'string') {
      var array = base64.toByteArray(res.data)
      var buffer = Buffer.from(array)
      proxy.push(buffer)
    } else {
      var reader = new FileReader()
      reader.addEventListener('load', function () {
        var data = reader.result

        if (data instanceof ArrayBuffer) data = Buffer.from(data)
        else data = Buffer.from(data, 'utf8')
        proxy.push(data)
      })
      reader.readAsArrayBuffer(res.data)
    }
  })

  my.onSocketClose(function () {
    stream.end()
    stream.destroy()
  })

  my.onSocketError(function (res) {
    stream.destroy(res)
  })
}

function buildStream (client, opts) {
  opts.hostname = opts.hostname || opts.host

  if (!opts.hostname) {
    throw new Error('Could not determine host. Specify host manually.')
  }

  var websocketSubProtocol =
    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)
      ? 'mqttv3.1'
      : 'mqtt'

  setDefaultOpts(opts)

  var url = buildUrl(opts, client)
  my = opts.my
  my.connectSocket({
    url: url,
    protocols: websocketSubProtocol
  })

  proxy = buildProxy()
  stream = duplexify.obj()

  bindEventHandler()

  return stream
}

module.exports = buildStream

}).call(this,require("buffer").Buffer)
},{"base64-js":10,"buffer":12,"duplexify":17,"readable-stream":108}],3:[function(require,module,exports){
'use strict'
var net = require('net')

/*
  variables port and host can be removed since
  you have all required information in opts object
*/
function buildBuilder (client, opts) {
  var port, host
  opts.port = opts.port || 1883
  opts.hostname = opts.hostname || opts.host || 'localhost'

  port = opts.port
  host = opts.hostname

  return net.createConnection(port, host)
}

module.exports = buildBuilder

},{"net":11}],4:[function(require,module,exports){
'use strict'
var tls = require('tls')

function buildBuilder (mqttClient, opts) {
  var connection
  opts.port = opts.port || 8883
  opts.host = opts.hostname || opts.host || 'localhost'

  opts.rejectUnauthorized = opts.rejectUnauthorized !== false

  delete opts.path

  connection = tls.connect(opts)
  /* eslint no-use-before-define: [2, "nofunc"] */
  connection.on('secureConnect', function () {
    if (opts.rejectUnauthorized && !connection.authorized) {
      connection.emit('error', new Error('TLS not authorized'))
    } else {
      connection.removeListener('error', handleTLSerrors)
    }
  })

  function handleTLSerrors (err) {
    // How can I get verify this error is a tls error?
    if (opts.rejectUnauthorized) {
      mqttClient.emit('error', err)
    }

    // close this connection to match the behaviour of net
    // otherwise all we get is an error from the connection
    // and close event doesn't fire. This is a work around
    // to enable the reconnect code to work the same as with
    // net.createConnection
    connection.end()
  }

  connection.on('error', handleTLSerrors)
  return connection
}

module.exports = buildBuilder

},{"tls":11}],5:[function(require,module,exports){
(function (process){
'use strict'

var websocket = require('websocket-stream')
var urlModule = require('url')
var WSS_OPTIONS = [
  'rejectUnauthorized',
  'ca',
  'cert',
  'key',
  'pfx',
  'passphrase'
]
var IS_BROWSER = process.title === 'browser'

function buildUrl (opts, client) {
  var url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path
  if (typeof (opts.transformWsUrl) === 'function') {
    url = opts.transformWsUrl(url, opts, client)
  }
  return url
}

function setDefaultOpts (opts) {
  if (!opts.hostname) {
    opts.hostname = 'localhost'
  }
  if (!opts.port) {
    if (opts.protocol === 'wss') {
      opts.port = 443
    } else {
      opts.port = 80
    }
  }
  if (!opts.path) {
    opts.path = '/'
  }

  if (!opts.wsOptions) {
    opts.wsOptions = {}
  }
  if (!IS_BROWSER && opts.protocol === 'wss') {
    // Add cert/key/ca etc options
    WSS_OPTIONS.forEach(function (prop) {
      if (opts.hasOwnProperty(prop) && !opts.wsOptions.hasOwnProperty(prop)) {
        opts.wsOptions[prop] = opts[prop]
      }
    })
  }
}

function createWebSocket (client, opts) {
  var websocketSubProtocol =
    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)
      ? 'mqttv3.1'
      : 'mqtt'

  setDefaultOpts(opts)
  var url = buildUrl(opts, client)
  return websocket(url, [websocketSubProtocol], opts.wsOptions)
}

function buildBuilder (client, opts) {
  return createWebSocket(client, opts)
}

function buildBuilderBrowser (client, opts) {
  if (!opts.hostname) {
    opts.hostname = opts.host
  }

  if (!opts.hostname) {
    // Throwing an error in a Web Worker if no `hostname` is given, because we
    // can not determine the `hostname` automatically.  If connecting to
    // localhost, please supply the `hostname` as an argument.
    if (typeof (document) === 'undefined') {
      throw new Error('Could not determine host. Specify host manually.')
    }
    var parsed = urlModule.parse(document.URL)
    opts.hostname = parsed.hostname

    if (!opts.port) {
      opts.port = parsed.port
    }
  }
  return createWebSocket(client, opts)
}

if (IS_BROWSER) {
  module.exports = buildBuilderBrowser
} else {
  module.exports = buildBuilder
}

}).call(this,require('_process'))
},{"_process":92,"url":113,"websocket-stream":118}],6:[function(require,module,exports){
(function (process,Buffer){
'use strict'

var Transform = require('readable-stream').Transform
var duplexify = require('duplexify')

/* global wx */
var socketTask
var proxy
var stream

function buildProxy () {
  var proxy = new Transform()
  proxy._write = function (chunk, encoding, next) {
    socketTask.send({
      data: chunk.buffer,
      success: function () {
        next()
      },
      fail: function (errMsg) {
        next(new Error(errMsg))
      }
    })
  }
  proxy._flush = function socketEnd (done) {
    socketTask.close({
      success: function () {
        done()
      }
    })
  }

  return proxy
}

function setDefaultOpts (opts) {
  if (!opts.hostname) {
    opts.hostname = 'localhost'
  }
  if (!opts.path) {
    opts.path = '/'
  }

  if (!opts.wsOptions) {
    opts.wsOptions = {}
  }
}

function buildUrl (opts, client) {
  var protocol = opts.protocol === 'wxs' ? 'wss' : 'ws'
  var url = protocol + '://' + opts.hostname + opts.path
  if (opts.port && opts.port !== 80 && opts.port !== 443) {
    url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path
  }
  if (typeof (opts.transformWsUrl) === 'function') {
    url = opts.transformWsUrl(url, opts, client)
  }
  return url
}

function bindEventHandler () {
  socketTask.onOpen(function () {
    stream.setReadable(proxy)
    stream.setWritable(proxy)
    stream.emit('connect')
  })

  socketTask.onMessage(function (res) {
    var data = res.data

    if (data instanceof ArrayBuffer) data = Buffer.from(data)
    else data = Buffer.from(data, 'utf8')
    proxy.push(data)
  })

  socketTask.onClose(function () {
    stream.end()
    stream.destroy()
  })

  socketTask.onError(function (res) {
    stream.destroy(new Error(res.errMsg))
  })
}

function buildStream (client, opts) {
  opts.hostname = opts.hostname || opts.host

  if (!opts.hostname) {
    throw new Error('Could not determine host. Specify host manually.')
  }

  var websocketSubProtocol =
    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)
      ? 'mqttv3.1'
      : 'mqtt'

  setDefaultOpts(opts)

  var url = buildUrl(opts, client)
  socketTask = wx.connectSocket({
    url: url,
    protocols: websocketSubProtocol
  })

  proxy = buildProxy()
  stream = duplexify.obj()
  stream._destroy = function (err, cb) {
    socketTask.close({
      success: function () {
        cb && cb(err)
      }
    })
  }

  var destroyRef = stream.destroy
  stream.destroy = function () {
    stream.destroy = destroyRef

    var self = this
    process.nextTick(function () {
      socketTask.close({
        fail: function () {
          self._destroy(new Error())
        }
      })
    })
  }.bind(stream)

  bindEventHandler()

  return stream
}

module.exports = buildStream

}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":92,"buffer":12,"duplexify":17,"readable-stream":108}],7:[function(require,module,exports){
(function (process){
'use strict'

/**
 * Module dependencies
 */
var xtend = require('xtend')

var Readable = require('readable-stream').Readable
var streamsOpts = { objectMode: true }
var defaultStoreOptions = {
  clean: true
}

/**
 * es6-map can preserve insertion order even if ES version is older.
 *
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Description
 * It should be noted that a Map which is a map of an object, especially
 * a dictionary of dictionaries, will only map to the object's insertion
 * order. In ES2015 this is ordered for objects but for older versions of
 * ES, this may be random and not ordered.
 *
 */
var Map = require('es6-map')

/**
 * In-memory implementation of the message store
 * This can actually be saved into files.
 *
 * @param {Object} [options] - store options
 */
function Store (options) {
  if (!(this instanceof Store)) {
    return new Store(options)
  }

  this.options = options || {}

  // Defaults
  this.options = xtend(defaultStoreOptions, options)

  this._inflights = new Map()
}

/**
 * Adds a packet to the store, a packet is
 * anything that has a messageId property.
 *
 */
Store.prototype.put = function (packet, cb) {
  this._inflights.set(packet.messageId, packet)

  if (cb) {
    cb()
  }

  return this
}

/**
 * Creates a stream with all the packets in the store
 *
 */
Store.prototype.createStream = function () {
  var stream = new Readable(streamsOpts)
  var destroyed = false
  var values = []
  var i = 0

  this._inflights.forEach(function (value, key) {
    values.push(value)
  })

  stream._read = function () {
    if (!destroyed && i < values.length) {
      this.push(values[i++])
    } else {
      this.push(null)
    }
  }

  stream.destroy = function () {
    if (destroyed) {
      return
    }

    var self = this

    destroyed = true

    process.nextTick(function () {
      self.emit('close')
    })
  }

  return stream
}

/**
 * deletes a packet from the store.
 */
Store.prototype.del = function (packet, cb) {
  packet = this._inflights.get(packet.messageId)
  if (packet) {
    this._inflights.delete(packet.messageId)
    cb(null, packet)
  } else if (cb) {
    cb(new Error('missing packet'))
  }

  return this
}

/**
 * get a packet from the store.
 */
Store.prototype.get = function (packet, cb) {
  packet = this._inflights.get(packet.messageId)
  if (packet) {
    cb(null, packet)
  } else if (cb) {
    cb(new Error('missing packet'))
  }

  return this
}

/**
 * Close the store
 */
Store.prototype.close = function (cb) {
  if (this.options.clean) {
    this._inflights = null
  }
  if (cb) {
    cb()
  }
}

module.exports = Store

}).call(this,require('_process'))
},{"_process":92,"es6-map":67,"readable-stream":108,"xtend":121}],8:[function(require,module,exports){
'use strict'

/**
 * Validate a topic to see if it's valid or not.
 * A topic is valid if it follow below rules:
 * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'
 * - Rule #2: Part `#` must be located at the end of the mailbox
 *
 * @param {String} topic - A topic
 * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.
 */
function validateTopic (topic) {
  var parts = topic.split('/')

  for (var i = 0; i < parts.length; i++) {
    if (parts[i] === '+') {
      continue
    }

    if (parts[i] === '#') {
      // for Rule #2
      return i === parts.length - 1
    }

    if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {
      return false
    }
  }

  return true
}

/**
 * Validate an array of topics to see if any of them is valid or not
  * @param {Array} topics - Array of topics
 * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one
 */
function validateTopics (topics) {
  if (topics.length === 0) {
    return 'empty_topic_list'
  }
  for (var i = 0; i < topics.length; i++) {
    if (!validateTopic(topics[i])) {
      return topics[i]
    }
  }
  return null
}

module.exports = {
  validateTopics: validateTopics
}

},{}],9:[function(require,module,exports){
(function (process){
'use strict'

var MqttClient = require('../client')
var Store = require('../store')
var url = require('url')
var xtend = require('xtend')
var protocols = {}

if (process.title !== 'browser') {
  protocols.mqtt = require('./tcp')
  protocols.tcp = require('./tcp')
  protocols.ssl = require('./tls')
  protocols.tls = require('./tls')
  protocols.mqtts = require('./tls')
} else {
  protocols.wx = require('./wx')
  protocols.wxs = require('./wx')

  protocols.ali = require('./ali')
  protocols.alis = require('./ali')
}

protocols.ws = require('./ws')
protocols.wss = require('./ws')

/**
 * Parse the auth attribute and merge username and password in the options object.
 *
 * @param {Object} [opts] option object
 */
function parseAuthOptions (opts) {
  var matches
  if (opts.auth) {
    matches = opts.auth.match(/^(.+):(.+)$/)
    if (matches) {
      opts.username = matches[1]
      opts.password = matches[2]
    } else {
      opts.username = opts.auth
    }
  }
}

/**
 * connect - connect to an MQTT broker.
 *
 * @param {String} [brokerUrl] - url of the broker, optional
 * @param {Object} opts - see MqttClient#constructor
 */
function connect (brokerUrl, opts) {
  if ((typeof brokerUrl === 'object') && !opts) {
    opts = brokerUrl
    brokerUrl = null
  }

  opts = opts || {}

  if (brokerUrl) {
    var parsed = url.parse(brokerUrl, true)
    if (parsed.port != null) {
      parsed.port = Number(parsed.port)
    }

    opts = xtend(parsed, opts)

    if (opts.protocol === null) {
      throw new Error('Missing protocol')
    }
    opts.protocol = opts.protocol.replace(/:$/, '')
  }

  // merge in the auth options if supplied
  parseAuthOptions(opts)

  // support clientId passed in the query string of the url
  if (opts.query && typeof opts.query.clientId === 'string') {
    opts.clientId = opts.query.clientId
  }

  if (opts.cert && opts.key) {
    if (opts.protocol) {
      if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {
        switch (opts.protocol) {
          case 'mqtt':
            opts.protocol = 'mqtts'
            break
          case 'ws':
            opts.protocol = 'wss'
            break
          case 'wx':
            opts.protocol = 'wxs'
            break
          case 'ali':
            opts.protocol = 'alis'
            break
          default:
            throw new Error('Unknown protocol for secure connection: "' + opts.protocol + '"!')
        }
      }
    } else {
      // don't know what protocol he want to use, mqtts or wss
      throw new Error('Missing secure protocol key')
    }
  }

  if (!protocols[opts.protocol]) {
    var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1
    opts.protocol = [
      'mqtt',
      'mqtts',
      'ws',
      'wss',
      'wx',
      'wxs',
      'ali',
      'alis'
    ].filter(function (key, index) {
      if (isSecure && index % 2 === 0) {
        // Skip insecure protocols when requesting a secure one.
        return false
      }
      return (typeof protocols[key] === 'function')
    })[0]
  }

  if (opts.clean === false && !opts.clientId) {
    throw new Error('Missing clientId for unclean clients')
  }

  if (opts.protocol) {
    opts.defaultProtocol = opts.protocol
  }

  function wrapper (client) {
    if (opts.servers) {
      if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {
        client._reconnectCount = 0
      }

      opts.host = opts.servers[client._reconnectCount].host
      opts.port = opts.servers[client._reconnectCount].port
      opts.protocol = (!opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol)
      opts.hostname = opts.host

      client._reconnectCount++
    }

    return protocols[opts.protocol](client, opts)
  }

  return new MqttClient(wrapper, opts)
}

module.exports = connect
module.exports.connect = connect
module.exports.MqttClient = MqttClient
module.exports.Store = Store

}).call(this,require('_process'))
},{"../client":1,"../store":7,"./ali":2,"./tcp":3,"./tls":4,"./ws":5,"./wx":6,"_process":92,"url":113,"xtend":121}],10:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],11:[function(require,module,exports){

},{}],12:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":10,"ieee754":79}],13:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],14:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":81}],15:[function(require,module,exports){
'use strict';

var copy             = require('es5-ext/object/copy')
  , normalizeOptions = require('es5-ext/object/normalize-options')
  , ensureCallable   = require('es5-ext/object/valid-callable')
  , map              = require('es5-ext/object/map')
  , callable         = require('es5-ext/object/valid-callable')
  , validValue       = require('es5-ext/object/valid-value')

  , bind = Function.prototype.bind, defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , define;

define = function (name, desc, options) {
	var value = validValue(desc) && callable(desc.value), dgs;
	dgs = copy(desc);
	delete dgs.writable;
	delete dgs.value;
	dgs.get = function () {
		if (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;
		desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);
		defineProperty(this, name, desc);
		return this[name];
	};
	return dgs;
};

module.exports = function (props/*, options*/) {
	var options = normalizeOptions(arguments[1]);
	if (options.resolveContext != null) ensureCallable(options.resolveContext);
	return map(props, function (desc, name) { return define(name, desc, options); });
};

},{"es5-ext/object/copy":39,"es5-ext/object/map":48,"es5-ext/object/normalize-options":49,"es5-ext/object/valid-callable":54,"es5-ext/object/valid-value":55}],16:[function(require,module,exports){
'use strict';

var assign        = require('es5-ext/object/assign')
  , normalizeOpts = require('es5-ext/object/normalize-options')
  , isCallable    = require('es5-ext/object/is-callable')
  , contains      = require('es5-ext/string/#/contains')

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

},{"es5-ext/object/assign":36,"es5-ext/object/is-callable":42,"es5-ext/object/normalize-options":49,"es5-ext/string/#/contains":56}],17:[function(require,module,exports){
(function (process,Buffer){
var stream = require('readable-stream')
var eos = require('end-of-stream')
var inherits = require('inherits')
var shift = require('stream-shift')

var SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)
  ? Buffer.from([0])
  : new Buffer([0])

var onuncork = function(self, fn) {
  if (self._corked) self.once('uncork', fn)
  else fn()
}

var autoDestroy = function (self, err) {
  if (self._autoDestroy) self.destroy(err)
}

var destroyer = function(self, end) {
  return function(err) {
    if (err) autoDestroy(self, err.message === 'premature close' ? null : err)
    else if (end && !self._ended) self.end()
  }
}

var end = function(ws, fn) {
  if (!ws) return fn()
  if (ws._writableState && ws._writableState.finished) return fn()
  if (ws._writableState) return ws.end(fn)
  ws.end()
  fn()
}

var toStreams2 = function(rs) {
  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)
}

var Duplexify = function(writable, readable, opts) {
  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)
  stream.Duplex.call(this, opts)

  this._writable = null
  this._readable = null
  this._readable2 = null

  this._autoDestroy = !opts || opts.autoDestroy !== false
  this._forwardDestroy = !opts || opts.destroy !== false
  this._forwardEnd = !opts || opts.end !== false
  this._corked = 1 // start corked
  this._ondrain = null
  this._drained = false
  this._forwarding = false
  this._unwrite = null
  this._unread = null
  this._ended = false

  this.destroyed = false

  if (writable) this.setWritable(writable)
  if (readable) this.setReadable(readable)
}

inherits(Duplexify, stream.Duplex)

Duplexify.obj = function(writable, readable, opts) {
  if (!opts) opts = {}
  opts.objectMode = true
  opts.highWaterMark = 16
  return new Duplexify(writable, readable, opts)
}

Duplexify.prototype.cork = function() {
  if (++this._corked === 1) this.emit('cork')
}

Duplexify.prototype.uncork = function() {
  if (this._corked && --this._corked === 0) this.emit('uncork')
}

Duplexify.prototype.setWritable = function(writable) {
  if (this._unwrite) this._unwrite()

  if (this.destroyed) {
    if (writable && writable.destroy) writable.destroy()
    return
  }

  if (writable === null || writable === false) {
    this.end()
    return
  }

  var self = this
  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))

  var ondrain = function() {
    var ondrain = self._ondrain
    self._ondrain = null
    if (ondrain) ondrain()
  }

  var clear = function() {
    self._writable.removeListener('drain', ondrain)
    unend()
  }

  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks

  this._writable = writable
  this._writable.on('drain', ondrain)
  this._unwrite = clear

  this.uncork() // always uncork setWritable
}

Duplexify.prototype.setReadable = function(readable) {
  if (this._unread) this._unread()

  if (this.destroyed) {
    if (readable && readable.destroy) readable.destroy()
    return
  }

  if (readable === null || readable === false) {
    this.push(null)
    this.resume()
    return
  }

  var self = this
  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))

  var onreadable = function() {
    self._forward()
  }

  var onend = function() {
    self.push(null)
  }

  var clear = function() {
    self._readable2.removeListener('readable', onreadable)
    self._readable2.removeListener('end', onend)
    unend()
  }

  this._drained = true
  this._readable = readable
  this._readable2 = readable._readableState ? readable : toStreams2(readable)
  this._readable2.on('readable', onreadable)
  this._readable2.on('end', onend)
  this._unread = clear

  this._forward()
}

Duplexify.prototype._read = function() {
  this._drained = true
  this._forward()
}

Duplexify.prototype._forward = function() {
  if (this._forwarding || !this._readable2 || !this._drained) return
  this._forwarding = true

  var data

  while (this._drained && (data = shift(this._readable2)) !== null) {
    if (this.destroyed) continue
    this._drained = this.push(data)
  }

  this._forwarding = false
}

Duplexify.prototype.destroy = function(err) {
  if (this.destroyed) return
  this.destroyed = true

  var self = this
  process.nextTick(function() {
    self._destroy(err)
  })
}

Duplexify.prototype._destroy = function(err) {
  if (err) {
    var ondrain = this._ondrain
    this._ondrain = null
    if (ondrain) ondrain(err)
    else this.emit('error', err)
  }

  if (this._forwardDestroy) {
    if (this._readable && this._readable.destroy) this._readable.destroy()
    if (this._writable && this._writable.destroy) this._writable.destroy()
  }

  this.emit('close')
}

Duplexify.prototype._write = function(data, enc, cb) {
  if (this.destroyed) return cb()
  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))
  if (data === SIGNAL_FLUSH) return this._finish(cb)
  if (!this._writable) return cb()

  if (this._writable.write(data) === false) this._ondrain = cb
  else cb()
}

Duplexify.prototype._finish = function(cb) {
  var self = this
  this.emit('preend')
  onuncork(this, function() {
    end(self._forwardEnd && self._writable, function() {
      // haxx to not emit prefinish twice
      if (self._writableState.prefinished === false) self._writableState.prefinished = true
      self.emit('prefinish')
      onuncork(self, cb)
    })
  })
}

Duplexify.prototype.end = function(data, enc, cb) {
  if (typeof data === 'function') return this.end(null, null, data)
  if (typeof enc === 'function') return this.end(data, null, enc)
  this._ended = true
  if (data) this.write(data)
  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)
  return stream.Writable.prototype.end.call(this, cb)
}

module.exports = Duplexify

}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":92,"buffer":12,"end-of-stream":18,"inherits":80,"readable-stream":108,"stream-shift":111}],18:[function(require,module,exports){
var once = require('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;

},{"once":90}],19:[function(require,module,exports){
// Inspired by Google Closure:
// http://closure-library.googlecode.com/svn/docs/
// closure_goog_array_array.js.html#goog.array.clear

"use strict";

var value = require("../../object/valid-value");

module.exports = function () {
	value(this).length = 0;
	return this;
};

},{"../../object/valid-value":55}],20:[function(require,module,exports){
"use strict";

var numberIsNaN       = require("../../number/is-nan")
  , toPosInt          = require("../../number/to-pos-integer")
  , value             = require("../../object/valid-value")
  , indexOf           = Array.prototype.indexOf
  , objHasOwnProperty = Object.prototype.hasOwnProperty
  , abs               = Math.abs
  , floor             = Math.floor;

module.exports = function (searchElement /*, fromIndex*/) {
	var i, length, fromIndex, val;
	if (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);

	length = toPosInt(value(this).length);
	fromIndex = arguments[1];
	if (isNaN(fromIndex)) fromIndex = 0;
	else if (fromIndex >= 0) fromIndex = floor(fromIndex);
	else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));

	for (i = fromIndex; i < length; ++i) {
		if (objHasOwnProperty.call(this, i)) {
			val = this[i];
			if (numberIsNaN(val)) return i; // Jslint: ignore
		}
	}
	return -1;
};

},{"../../number/is-nan":30,"../../number/to-pos-integer":34,"../../object/valid-value":55}],21:[function(require,module,exports){
"use strict";

module.exports = require("./is-implemented")()
	? Array.from
	: require("./shim");

},{"./is-implemented":22,"./shim":23}],22:[function(require,module,exports){
"use strict";

module.exports = function () {
	var from = Array.from, arr, result;
	if (typeof from !== "function") return false;
	arr = ["raz", "dwa"];
	result = from(arr);
	return Boolean(result && (result !== arr) && (result[1] === "dwa"));
};

},{}],23:[function(require,module,exports){
"use strict";

var iteratorSymbol = require("es6-symbol").iterator
  , isArguments    = require("../../function/is-arguments")
  , isFunction     = require("../../function/is-function")
  , toPosInt       = require("../../number/to-pos-integer")
  , callable       = require("../../object/valid-callable")
  , validValue     = require("../../object/valid-value")
  , isValue        = require("../../object/is-value")
  , isString       = require("../../string/is-string")
  , isArray        = Array.isArray
  , call           = Function.prototype.call
  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
  , defineProperty = Object.defineProperty;

// eslint-disable-next-line complexity
module.exports = function (arrayLike /*, mapFn, thisArg*/) {
	var mapFn = arguments[1]
	  , thisArg = arguments[2]
	  , Context
	  , i
	  , j
	  , arr
	  , length
	  , code
	  , iterator
	  , result
	  , getIterator
	  , value;

	arrayLike = Object(validValue(arrayLike));

	if (isValue(mapFn)) callable(mapFn);
	if (!this || this === Array || !isFunction(this)) {
		// Result: Plain array
		if (!mapFn) {
			if (isArguments(arrayLike)) {
				// Source: Arguments
				length = arrayLike.length;
				if (length !== 1) return Array.apply(null, arrayLike);
				arr = new Array(1);
				arr[0] = arrayLike[0];
				return arr;
			}
			if (isArray(arrayLike)) {
				// Source: Array
				arr = new Array(length = arrayLike.length);
				for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
				return arr;
			}
		}
		arr = [];
	} else {
		// Result: Non plain array
		Context = this;
	}

	if (!isArray(arrayLike)) {
		if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
			// Source: Iterator
			iterator = callable(getIterator).call(arrayLike);
			if (Context) arr = new Context();
			result = iterator.next();
			i = 0;
			while (!result.done) {
				value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
				if (Context) {
					desc.value = value;
					defineProperty(arr, i, desc);
				} else {
					arr[i] = value;
				}
				result = iterator.next();
				++i;
			}
			length = i;
		} else if (isString(arrayLike)) {
			// Source: String
			length = arrayLike.length;
			if (Context) arr = new Context();
			for (i = 0, j = 0; i < length; ++i) {
				value = arrayLike[i];
				if (i + 1 < length) {
					code = value.charCodeAt(0);
					// eslint-disable-next-line max-depth
					if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
				}
				value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
				if (Context) {
					desc.value = value;
					defineProperty(arr, j, desc);
				} else {
					arr[j] = value;
				}
				++j;
			}
			length = j;
		}
	}
	if (length === undefined) {
		// Source: array or array-like
		length = toPosInt(arrayLike.length);
		if (Context) arr = new Context(length);
		for (i = 0; i < length; ++i) {
			value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
			if (Context) {
				desc.value = value;
				defineProperty(arr, i, desc);
			} else {
				arr[i] = value;
			}
		}
	}
	if (Context) {
		desc.value = null;
		arr.length = length;
	}
	return arr;
};

},{"../../function/is-arguments":24,"../../function/is-function":25,"../../number/to-pos-integer":34,"../../object/is-value":44,"../../object/valid-callable":54,"../../object/valid-value":55,"../../string/is-string":59,"es6-symbol":73}],24:[function(require,module,exports){
"use strict";

var objToString = Object.prototype.toString
  , id = objToString.call(
	(function () {
		return arguments;
	})()
);

module.exports = function (value) {
	return objToString.call(value) === id;
};

},{}],25:[function(require,module,exports){
"use strict";

var objToString = Object.prototype.toString, id = objToString.call(require("./noop"));

module.exports = function (value) {
	return typeof value === "function" && objToString.call(value) === id;
};

},{"./noop":26}],26:[function(require,module,exports){
"use strict";

// eslint-disable-next-line no-empty-function
module.exports = function () {};

},{}],27:[function(require,module,exports){
"use strict";

module.exports = require("./is-implemented")()
	? Math.sign
	: require("./shim");

},{"./is-implemented":28,"./shim":29}],28:[function(require,module,exports){
"use strict";

module.exports = function () {
	var sign = Math.sign;
	if (typeof sign !== "function") return false;
	return (sign(10) === 1) && (sign(-20) === -1);
};

},{}],29:[function(require,module,exports){
"use strict";

module.exports = function (value) {
	value = Number(value);
	if (isNaN(value) || (value === 0)) return value;
	return value > 0 ? 1 : -1;
};

},{}],30:[function(require,module,exports){
"use strict";

module.exports = require("./is-implemented")()
	? Number.isNaN
	: require("./shim");

},{"./is-implemented":31,"./shim":32}],31:[function(require,module,exports){
"use strict";

module.exports = function () {
	var numberIsNaN = Number.isNaN;
	if (typeof numberIsNaN !== "function") return false;
	return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
};

},{}],32:[function(require,module,exports){
"use strict";

module.exports = function (value) {
	// eslint-disable-next-line no-self-compare
	return value !== value;
};

},{}],33:[function(require,module,exports){
"use strict";

var sign = require("../math/sign")

  , abs = Math.abs, floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) return 0;
	value = Number(value);
	if ((value === 0) || !isFinite(value)) return value;
	return sign(value) * floor(abs(value));
};

},{"../math/sign":27}],34:[function(require,module,exports){
"use strict";

var toInteger = require("./to-integer")

  , max = Math.max;

module.exports = function (value) {
 return max(0, toInteger(value));
};

},{"./to-integer":33}],35:[function(require,module,exports){
// Internal method, used by iteration functions.
// Calls a function for each key-value pair found in object
// Optionally takes compareFn to iterate object in specific order

"use strict";

var callable                = require("./valid-callable")
  , value                   = require("./valid-value")
  , bind                    = Function.prototype.bind
  , call                    = Function.prototype.call
  , keys                    = Object.keys
  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function (method, defVal) {
	return function (obj, cb /*, thisArg, compareFn*/) {
		var list, thisArg = arguments[2], compareFn = arguments[3];
		obj = Object(value(obj));
		callable(cb);

		list = keys(obj);
		if (compareFn) {
			list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : undefined);
		}
		if (typeof method !== "function") method = list[method];
		return call.call(method, list, function (key, index) {
			if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
			return call.call(cb, thisArg, obj[key], key, obj, index);
		});
	};
};

},{"./valid-callable":54,"./valid-value":55}],36:[function(require,module,exports){
"use strict";

module.exports = require("./is-implemented")()
	? Object.assign
	: require("./shim");

},{"./is-implemented":37,"./shim":38}],37:[function(require,module,exports){
"use strict";

module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== "function") return false;
	obj = { foo: "raz" };
	assign(obj, { bar: "dwa" }, { trzy: "trzy" });
	return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
};

},{}],38:[function(require,module,exports){
"use strict";

var keys  = require("../keys")
  , value = require("../valid-value")
  , max   = Math.max;

module.exports = function (dest, src /*, srcn*/) {
	var error, i, length = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try {
			dest[key] = src[key];
		} catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < length; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};

},{"../keys":45,"../valid-value":55}],39:[function(require,module,exports){
"use strict";

var aFrom  = require("../array/from")
  , assign = require("./assign")
  , value  = require("./valid-value");

module.exports = function (obj/*, propertyNames, options*/) {
	var copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);
	if (copy !== obj && !propertyNames) return copy;
	var result = {};
	if (propertyNames) {
		aFrom(propertyNames, function (propertyName) {
			if (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];
		});
	} else {
		assign(result, obj);
	}
	return result;
};

},{"../array/from":21,"./assign":36,"./valid-value":55}],40:[function(require,module,exports){
// Workaround for http://code.google.com/p/v8/issues/detail?id=2804

"use strict";

var create = Object.create, shim;

if (!require("./set-prototype-of/is-implemented")()) {
	shim = require("./set-prototype-of/shim");
}

module.exports = (function () {
	var nullObject, polyProps, desc;
	if (!shim) return create;
	if (shim.level !== 1) return create;

	nullObject = {};
	polyProps = {};
	desc = {
		configurable: false,
		enumerable: false,
		writable: true,
		value: undefined
	};
	Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
		if (name === "__proto__") {
			polyProps[name] = {
				configurable: true,
				enumerable: false,
				writable: true,
				value: undefined
			};
			return;
		}
		polyProps[name] = desc;
	});
	Object.defineProperties(nullObject, polyProps);

	Object.defineProperty(shim, "nullPolyfill", {
		configurable: false,
		enumerable: false,
		writable: false,
		value: nullObject
	});

	return function (prototype, props) {
		return create(prototype === null ? nullObject : prototype, props);
	};
}());

},{"./set-prototype-of/is-implemented":52,"./set-prototype-of/shim":53}],41:[function(require,module,exports){
"use strict";

module.exports = require("./_iterate")("forEach");

},{"./_iterate":35}],42:[function(require,module,exports){
// Deprecated

"use strict";

module.exports = function (obj) {
 return typeof obj === "function";
};

},{}],43:[function(require,module,exports){
"use strict";

var isValue = require("./is-value");

var map = { function: true, object: true };

module.exports = function (value) {
	return (isValue(value) && map[typeof value]) || false;
};

},{"./is-value":44}],44:[function(require,module,exports){
"use strict";

var _undefined = require("../function/noop")(); // Support ES3 engines

module.exports = function (val) {
 return (val !== _undefined) && (val !== null);
};

},{"../function/noop":26}],45:[function(require,module,exports){
"use strict";

module.exports = require("./is-implemented")() ? Object.keys : require("./shim");

},{"./is-implemented":46,"./shim":47}],46:[function(require,module,exports){
"use strict";

module.exports = function () {
	try {
		Object.keys("primitive");
		return true;
	} catch (e) {
		return false;
	}
};

},{}],47:[function(require,module,exports){
"use strict";

var isValue = require("../is-value");

var keys = Object.keys;

module.exports = function (object) { return keys(isValue(object) ? Object(object) : object); };

},{"../is-value":44}],48:[function(require,module,exports){
"use strict";

var callable = require("./valid-callable")
  , forEach  = require("./for-each")
  , call     = Function.prototype.call;

module.exports = function (obj, cb /*, thisArg*/) {
	var result = {}, thisArg = arguments[2];
	callable(cb);
	forEach(obj, function (value, key, targetObj, index) {
		result[key] = call.call(cb, thisArg, value, key, targetObj, index);
	});
	return result;
};

},{"./for-each":41,"./valid-callable":54}],49:[function(require,module,exports){
"use strict";

var isValue = require("./is-value");

var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

// eslint-disable-next-line no-unused-vars
module.exports = function (opts1 /*, options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (!isValue(options)) return;
		process(Object(options), result);
	});
	return result;
};

},{"./is-value":44}],50:[function(require,module,exports){
"use strict";

var forEach = Array.prototype.forEach, create = Object.create;

// eslint-disable-next-line no-unused-vars
module.exports = function (arg /*, args*/) {
	var set = create(null);
	forEach.call(arguments, function (name) {
		set[name] = true;
	});
	return set;
};

},{}],51:[function(require,module,exports){
"use strict";

module.exports = require("./is-implemented")()
	? Object.setPrototypeOf
	: require("./shim");

},{"./is-implemented":52,"./shim":53}],52:[function(require,module,exports){
"use strict";

var create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};

module.exports = function (/* CustomCreate*/) {
	var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
	if (typeof setPrototypeOf !== "function") return false;
	return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
};

},{}],53:[function(require,module,exports){
/* eslint no-proto: "off" */

// Big thanks to @WebReflection for sorting this out
// https://gist.github.com/WebReflection/5593554

"use strict";

var isObject        = require("../is-object")
  , value           = require("../valid-value")
  , objIsPrototypeOf = Object.prototype.isPrototypeOf
  , defineProperty  = Object.defineProperty
  , nullDesc        = {
	configurable: true,
	enumerable: false,
	writable: true,
	value: undefined
}
  , validate;

validate = function (obj, prototype) {
	value(obj);
	if (prototype === null || isObject(prototype)) return obj;
	throw new TypeError("Prototype must be null or an object");
};

module.exports = (function (status) {
	var fn, set;
	if (!status) return null;
	if (status.level === 2) {
		if (status.set) {
			set = status.set;
			fn = function (obj, prototype) {
				set.call(validate(obj, prototype), prototype);
				return obj;
			};
		} else {
			fn = function (obj, prototype) {
				validate(obj, prototype).__proto__ = prototype;
				return obj;
			};
		}
	} else {
		fn = function self(obj, prototype) {
			var isNullBase;
			validate(obj, prototype);
			isNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);
			if (isNullBase) delete self.nullPolyfill.__proto__;
			if (prototype === null) prototype = self.nullPolyfill;
			obj.__proto__ = prototype;
			if (isNullBase) defineProperty(self.nullPolyfill, "__proto__", nullDesc);
			return obj;
		};
	}
	return Object.defineProperty(fn, "level", {
		configurable: false,
		enumerable: false,
		writable: false,
		value: status.level
	});
}(
	(function () {
		var tmpObj1 = Object.create(null)
		  , tmpObj2 = {}
		  , set
		  , desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");

		if (desc) {
			try {
				set = desc.set; // Opera crashes at this point
				set.call(tmpObj1, tmpObj2);
			} catch (ignore) {}
			if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };
		}

		tmpObj1.__proto__ = tmpObj2;
		if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };

		tmpObj1 = {};
		tmpObj1.__proto__ = tmpObj2;
		if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };

		return false;
	})()
));

require("../create");

},{"../create":40,"../is-object":43,"../valid-value":55}],54:[function(require,module,exports){
"use strict";

module.exports = function (fn) {
	if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
	return fn;
};

},{}],55:[function(require,module,exports){
"use strict";

var isValue = require("./is-value");

module.exports = function (value) {
	if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
	return value;
};

},{"./is-value":44}],56:[function(require,module,exports){
"use strict";

module.exports = require("./is-implemented")()
	? String.prototype.contains
	: require("./shim");

},{"./is-implemented":57,"./shim":58}],57:[function(require,module,exports){
"use strict";

var str = "razdwatrzy";

module.exports = function () {
	if (typeof str.contains !== "function") return false;
	return (str.contains("dwa") === true) && (str.contains("foo") === false);
};

},{}],58:[function(require,module,exports){
"use strict";

var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};

},{}],59:[function(require,module,exports){
"use strict";

var objToString = Object.prototype.toString, id = objToString.call("");

module.exports = function (value) {
	return (
		typeof value === "string" ||
		(value &&
			typeof value === "object" &&
			(value instanceof String || objToString.call(value) === id)) ||
		false
	);
};

},{}],60:[function(require,module,exports){
"use strict";

var setPrototypeOf = require("es5-ext/object/set-prototype-of")
  , contains       = require("es5-ext/string/#/contains")
  , d              = require("d")
  , Symbol         = require("es6-symbol")
  , Iterator       = require("./");

var defineProperty = Object.defineProperty, ArrayIterator;

ArrayIterator = module.exports = function (arr, kind) {
	if (!(this instanceof ArrayIterator)) throw new TypeError("Constructor requires 'new'");
	Iterator.call(this, arr);
	if (!kind) kind = "value";
	else if (contains.call(kind, "key+value")) kind = "key+value";
	else if (contains.call(kind, "key")) kind = "key";
	else kind = "value";
	defineProperty(this, "__kind__", d("", kind));
};
if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);

// Internal %ArrayIteratorPrototype% doesn't expose its constructor
delete ArrayIterator.prototype.constructor;

ArrayIterator.prototype = Object.create(Iterator.prototype, {
	_resolve: d(function (i) {
		if (this.__kind__ === "value") return this.__list__[i];
		if (this.__kind__ === "key+value") return [i, this.__list__[i]];
		return i;
	})
});
defineProperty(ArrayIterator.prototype, Symbol.toStringTag, d("c", "Array Iterator"));

},{"./":63,"d":16,"es5-ext/object/set-prototype-of":51,"es5-ext/string/#/contains":56,"es6-symbol":73}],61:[function(require,module,exports){
"use strict";

var isArguments = require("es5-ext/function/is-arguments")
  , callable    = require("es5-ext/object/valid-callable")
  , isString    = require("es5-ext/string/is-string")
  , get         = require("./get");

var isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;

module.exports = function (iterable, cb /*, thisArg*/) {
	var mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code;
	if (isArray(iterable) || isArguments(iterable)) mode = "array";
	else if (isString(iterable)) mode = "string";
	else iterable = get(iterable);

	callable(cb);
	doBreak = function () {
		broken = true;
	};
	if (mode === "array") {
		some.call(iterable, function (value) {
			call.call(cb, thisArg, value, doBreak);
			return broken;
		});
		return;
	}
	if (mode === "string") {
		length = iterable.length;
		for (i = 0; i < length; ++i) {
			char = iterable[i];
			if (i + 1 < length) {
				code = char.charCodeAt(0);
				if (code >= 0xd800 && code <= 0xdbff) char += iterable[++i];
			}
			call.call(cb, thisArg, char, doBreak);
			if (broken) break;
		}
		return;
	}
	result = iterable.next();

	while (!result.done) {
		call.call(cb, thisArg, result.value, doBreak);
		if (broken) return;
		result = iterable.next();
	}
};

},{"./get":62,"es5-ext/function/is-arguments":24,"es5-ext/object/valid-callable":54,"es5-ext/string/is-string":59}],62:[function(require,module,exports){
"use strict";

var isArguments    = require("es5-ext/function/is-arguments")
  , isString       = require("es5-ext/string/is-string")
  , ArrayIterator  = require("./array")
  , StringIterator = require("./string")
  , iterable       = require("./valid-iterable")
  , iteratorSymbol = require("es6-symbol").iterator;

module.exports = function (obj) {
	if (typeof iterable(obj)[iteratorSymbol] === "function") return obj[iteratorSymbol]();
	if (isArguments(obj)) return new ArrayIterator(obj);
	if (isString(obj)) return new StringIterator(obj);
	return new ArrayIterator(obj);
};

},{"./array":60,"./string":65,"./valid-iterable":66,"es5-ext/function/is-arguments":24,"es5-ext/string/is-string":59,"es6-symbol":73}],63:[function(require,module,exports){
"use strict";

var clear    = require("es5-ext/array/#/clear")
  , assign   = require("es5-ext/object/assign")
  , callable = require("es5-ext/object/valid-callable")
  , value    = require("es5-ext/object/valid-value")
  , d        = require("d")
  , autoBind = require("d/auto-bind")
  , Symbol   = require("es6-symbol");

var defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;

module.exports = Iterator = function (list, context) {
	if (!(this instanceof Iterator)) throw new TypeError("Constructor requires 'new'");
	defineProperties(this, {
		__list__: d("w", value(list)),
		__context__: d("w", context),
		__nextIndex__: d("w", 0)
	});
	if (!context) return;
	callable(context.on);
	context.on("_add", this._onAdd);
	context.on("_delete", this._onDelete);
	context.on("_clear", this._onClear);
};

// Internal %IteratorPrototype% doesn't expose its constructor
delete Iterator.prototype.constructor;

defineProperties(
	Iterator.prototype,
	assign(
		{
			_next: d(function () {
				var i;
				if (!this.__list__) return undefined;
				if (this.__redo__) {
					i = this.__redo__.shift();
					if (i !== undefined) return i;
				}
				if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
				this._unBind();
				return undefined;
			}),
			next: d(function () {
				return this._createResult(this._next());
			}),
			_createResult: d(function (i) {
				if (i === undefined) return { done: true, value: undefined };
				return { done: false, value: this._resolve(i) };
			}),
			_resolve: d(function (i) {
				return this.__list__[i];
			}),
			_unBind: d(function () {
				this.__list__ = null;
				delete this.__redo__;
				if (!this.__context__) return;
				this.__context__.off("_add", this._onAdd);
				this.__context__.off("_delete", this._onDelete);
				this.__context__.off("_clear", this._onClear);
				this.__context__ = null;
			}),
			toString: d(function () {
				return "[object " + (this[Symbol.toStringTag] || "Object") + "]";
			})
		},
		autoBind({
			_onAdd: d(function (index) {
				if (index >= this.__nextIndex__) return;
				++this.__nextIndex__;
				if (!this.__redo__) {
					defineProperty(this, "__redo__", d("c", [index]));
					return;
				}
				this.__redo__.forEach(function (redo, i) {
					if (redo >= index) this.__redo__[i] = ++redo;
				}, this);
				this.__redo__.push(index);
			}),
			_onDelete: d(function (index) {
				var i;
				if (index >= this.__nextIndex__) return;
				--this.__nextIndex__;
				if (!this.__redo__) return;
				i = this.__redo__.indexOf(index);
				if (i !== -1) this.__redo__.splice(i, 1);
				this.__redo__.forEach(function (redo, j) {
					if (redo > index) this.__redo__[j] = --redo;
				}, this);
			}),
			_onClear: d(function () {
				if (this.__redo__) clear.call(this.__redo__);
				this.__nextIndex__ = 0;
			})
		})
	)
);

defineProperty(
	Iterator.prototype,
	Symbol.iterator,
	d(function () {
		return this;
	})
);

},{"d":16,"d/auto-bind":15,"es5-ext/array/#/clear":19,"es5-ext/object/assign":36,"es5-ext/object/valid-callable":54,"es5-ext/object/valid-value":55,"es6-symbol":73}],64:[function(require,module,exports){
"use strict";

var isArguments = require("es5-ext/function/is-arguments")
  , isValue     = require("es5-ext/object/is-value")
  , isString    = require("es5-ext/string/is-string");

var iteratorSymbol = require("es6-symbol").iterator
  , isArray        = Array.isArray;

module.exports = function (value) {
	if (!isValue(value)) return false;
	if (isArray(value)) return true;
	if (isString(value)) return true;
	if (isArguments(value)) return true;
	return typeof value[iteratorSymbol] === "function";
};

},{"es5-ext/function/is-arguments":24,"es5-ext/object/is-value":44,"es5-ext/string/is-string":59,"es6-symbol":73}],65:[function(require,module,exports){
// Thanks @mathiasbynens
// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols

"use strict";

var setPrototypeOf = require("es5-ext/object/set-prototype-of")
  , d              = require("d")
  , Symbol         = require("es6-symbol")
  , Iterator       = require("./");

var defineProperty = Object.defineProperty, StringIterator;

StringIterator = module.exports = function (str) {
	if (!(this instanceof StringIterator)) throw new TypeError("Constructor requires 'new'");
	str = String(str);
	Iterator.call(this, str);
	defineProperty(this, "__length__", d("", str.length));
};
if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);

// Internal %ArrayIteratorPrototype% doesn't expose its constructor
delete StringIterator.prototype.constructor;

StringIterator.prototype = Object.create(Iterator.prototype, {
	_next: d(function () {
		if (!this.__list__) return undefined;
		if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
		this._unBind();
		return undefined;
	}),
	_resolve: d(function (i) {
		var char = this.__list__[i], code;
		if (this.__nextIndex__ === this.__length__) return char;
		code = char.charCodeAt(0);
		if (code >= 0xd800 && code <= 0xdbff) return char + this.__list__[this.__nextIndex__++];
		return char;
	})
});
defineProperty(StringIterator.prototype, Symbol.toStringTag, d("c", "String Iterator"));

},{"./":63,"d":16,"es5-ext/object/set-prototype-of":51,"es6-symbol":73}],66:[function(require,module,exports){
"use strict";

var isIterable = require("./is-iterable");

module.exports = function (value) {
	if (!isIterable(value)) throw new TypeError(value + " is not iterable");
	return value;
};

},{"./is-iterable":64}],67:[function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')() ? Map : require('./polyfill');

},{"./is-implemented":68,"./polyfill":72}],68:[function(require,module,exports){
'use strict';

module.exports = function () {
	var map, iterator, result;
	if (typeof Map !== 'function') return false;
	try {
		// WebKit doesn't support arguments and crashes
		map = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);
	} catch (e) {
		return false;
	}
	if (String(map) !== '[object Map]') return false;
	if (map.size !== 3) return false;
	if (typeof map.clear !== 'function') return false;
	if (typeof map.delete !== 'function') return false;
	if (typeof map.entries !== 'function') return false;
	if (typeof map.forEach !== 'function') return false;
	if (typeof map.get !== 'function') return false;
	if (typeof map.has !== 'function') return false;
	if (typeof map.keys !== 'function') return false;
	if (typeof map.set !== 'function') return false;
	if (typeof map.values !== 'function') return false;

	iterator = map.entries();
	result = iterator.next();
	if (result.done !== false) return false;
	if (!result.value) return false;
	if (result.value[0] !== 'raz') return false;
	if (result.value[1] !== 'one') return false;

	return true;
};

},{}],69:[function(require,module,exports){
// Exports true if environment provides native `Map` implementation,
// whatever that is.

'use strict';

module.exports = (function () {
	if (typeof Map === 'undefined') return false;
	return (Object.prototype.toString.call(new Map()) === '[object Map]');
}());

},{}],70:[function(require,module,exports){
'use strict';

module.exports = require('es5-ext/object/primitive-set')('key',
	'value', 'key+value');

},{"es5-ext/object/primitive-set":50}],71:[function(require,module,exports){
'use strict';

var setPrototypeOf    = require('es5-ext/object/set-prototype-of')
  , d                 = require('d')
  , Iterator          = require('es6-iterator')
  , toStringTagSymbol = require('es6-symbol').toStringTag
  , kinds             = require('./iterator-kinds')

  , defineProperties = Object.defineProperties
  , unBind = Iterator.prototype._unBind
  , MapIterator;

MapIterator = module.exports = function (map, kind) {
	if (!(this instanceof MapIterator)) return new MapIterator(map, kind);
	Iterator.call(this, map.__mapKeysData__, map);
	if (!kind || !kinds[kind]) kind = 'key+value';
	defineProperties(this, {
		__kind__: d('', kind),
		__values__: d('w', map.__mapValuesData__)
	});
};
if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);

MapIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(MapIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__values__[i];
		if (this.__kind__ === 'key') return this.__list__[i];
		return [this.__list__[i], this.__values__[i]];
	}),
	_unBind: d(function () {
		this.__values__ = null;
		unBind.call(this);
	}),
	toString: d(function () { return '[object Map Iterator]'; })
});
Object.defineProperty(MapIterator.prototype, toStringTagSymbol,
	d('c', 'Map Iterator'));

},{"./iterator-kinds":70,"d":16,"es5-ext/object/set-prototype-of":51,"es6-iterator":63,"es6-symbol":73}],72:[function(require,module,exports){
'use strict';

var clear          = require('es5-ext/array/#/clear')
  , eIndexOf       = require('es5-ext/array/#/e-index-of')
  , setPrototypeOf = require('es5-ext/object/set-prototype-of')
  , callable       = require('es5-ext/object/valid-callable')
  , validValue     = require('es5-ext/object/valid-value')
  , d              = require('d')
  , ee             = require('event-emitter')
  , Symbol         = require('es6-symbol')
  , iterator       = require('es6-iterator/valid-iterable')
  , forOf          = require('es6-iterator/for-of')
  , Iterator       = require('./lib/iterator')
  , isNative       = require('./is-native-implemented')

  , call = Function.prototype.call
  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf
  , MapPoly;

module.exports = MapPoly = function (/*iterable*/) {
	var iterable = arguments[0], keys, values, self;
	if (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \'new\'');
	if (isNative && setPrototypeOf && (Map !== MapPoly)) {
		self = setPrototypeOf(new Map(), getPrototypeOf(this));
	} else {
		self = this;
	}
	if (iterable != null) iterator(iterable);
	defineProperties(self, {
		__mapKeysData__: d('c', keys = []),
		__mapValuesData__: d('c', values = [])
	});
	if (!iterable) return self;
	forOf(iterable, function (value) {
		var key = validValue(value)[0];
		value = value[1];
		if (eIndexOf.call(keys, key) !== -1) return;
		keys.push(key);
		values.push(value);
	}, self);
	return self;
};

if (isNative) {
	if (setPrototypeOf) setPrototypeOf(MapPoly, Map);
	MapPoly.prototype = Object.create(Map.prototype, {
		constructor: d(MapPoly)
	});
}

ee(defineProperties(MapPoly.prototype, {
	clear: d(function () {
		if (!this.__mapKeysData__.length) return;
		clear.call(this.__mapKeysData__);
		clear.call(this.__mapValuesData__);
		this.emit('_clear');
	}),
	delete: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return false;
		this.__mapKeysData__.splice(index, 1);
		this.__mapValuesData__.splice(index, 1);
		this.emit('_delete', index, key);
		return true;
	}),
	entries: d(function () { return new Iterator(this, 'key+value'); }),
	forEach: d(function (cb/*, thisArg*/) {
		var thisArg = arguments[1], iterator, result;
		callable(cb);
		iterator = this.entries();
		result = iterator._next();
		while (result !== undefined) {
			call.call(cb, thisArg, this.__mapValuesData__[result],
				this.__mapKeysData__[result], this);
			result = iterator._next();
		}
	}),
	get: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return;
		return this.__mapValuesData__[index];
	}),
	has: d(function (key) {
		return (eIndexOf.call(this.__mapKeysData__, key) !== -1);
	}),
	keys: d(function () { return new Iterator(this, 'key'); }),
	set: d(function (key, value) {
		var index = eIndexOf.call(this.__mapKeysData__, key), emit;
		if (index === -1) {
			index = this.__mapKeysData__.push(key) - 1;
			emit = true;
		}
		this.__mapValuesData__[index] = value;
		if (emit) this.emit('_add', index, key);
		return this;
	}),
	size: d.gs(function () { return this.__mapKeysData__.length; }),
	values: d(function () { return new Iterator(this, 'value'); }),
	toString: d(function () { return '[object Map]'; })
}));
Object.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {
	return this.entries();
}));
Object.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));

},{"./is-native-implemented":69,"./lib/iterator":71,"d":16,"es5-ext/array/#/clear":19,"es5-ext/array/#/e-index-of":20,"es5-ext/object/set-prototype-of":51,"es5-ext/object/valid-callable":54,"es5-ext/object/valid-value":55,"es6-iterator/for-of":61,"es6-iterator/valid-iterable":66,"es6-symbol":73,"event-emitter":78}],73:[function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')() ? Symbol : require('./polyfill');

},{"./is-implemented":74,"./polyfill":76}],74:[function(require,module,exports){
'use strict';

var validTypes = { object: true, symbol: true };

module.exports = function () {
	var symbol;
	if (typeof Symbol !== 'function') return false;
	symbol = Symbol('test symbol');
	try { String(symbol); } catch (e) { return false; }

	// Return 'true' also for polyfills
	if (!validTypes[typeof Symbol.iterator]) return false;
	if (!validTypes[typeof Symbol.toPrimitive]) return false;
	if (!validTypes[typeof Symbol.toStringTag]) return false;

	return true;
};

},{}],75:[function(require,module,exports){
'use strict';

module.exports = function (x) {
	if (!x) return false;
	if (typeof x === 'symbol') return true;
	if (!x.constructor) return false;
	if (x.constructor.name !== 'Symbol') return false;
	return (x[x.constructor.toStringTag] === 'Symbol');
};

},{}],76:[function(require,module,exports){
// ES2015 Symbol polyfill for environments that do not (or partially) support it

'use strict';

var d              = require('d')
  , validateSymbol = require('./validate-symbol')

  , create = Object.create, defineProperties = Object.defineProperties
  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)
  , isNativeSafe;

if (typeof Symbol === 'function') {
	NativeSymbol = Symbol;
	try {
		String(NativeSymbol());
		isNativeSafe = true;
	} catch (ignore) {}
}

var generateName = (function () {
	var created = create(null);
	return function (desc) {
		var postfix = 0, name, ie11BugWorkaround;
		while (created[desc + (postfix || '')]) ++postfix;
		desc += (postfix || '');
		created[desc] = true;
		name = '@@' + desc;
		defineProperty(objPrototype, name, d.gs(null, function (value) {
			// For IE11 issue see:
			// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
			//    ie11-broken-getters-on-dom-objects
			// https://github.com/medikoo/es6-symbol/issues/12
			if (ie11BugWorkaround) return;
			ie11BugWorkaround = true;
			defineProperty(this, name, d(value));
			ie11BugWorkaround = false;
		}));
		return name;
	};
}());

// Internal constructor (not one exposed) for creating Symbol instances.
// This one is used to ensure that `someSymbol instanceof Symbol` always return false
HiddenSymbol = function Symbol(description) {
	if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
	return SymbolPolyfill(description);
};

// Exposed `Symbol` constructor
// (returns instances of HiddenSymbol)
module.exports = SymbolPolyfill = function Symbol(description) {
	var symbol;
	if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
	if (isNativeSafe) return NativeSymbol(description);
	symbol = create(HiddenSymbol.prototype);
	description = (description === undefined ? '' : String(description));
	return defineProperties(symbol, {
		__description__: d('', description),
		__name__: d('', generateName(description))
	});
};
defineProperties(SymbolPolyfill, {
	for: d(function (key) {
		if (globalSymbols[key]) return globalSymbols[key];
		return (globalSymbols[key] = SymbolPolyfill(String(key)));
	}),
	keyFor: d(function (s) {
		var key;
		validateSymbol(s);
		for (key in globalSymbols) if (globalSymbols[key] === s) return key;
	}),

	// To ensure proper interoperability with other native functions (e.g. Array.from)
	// fallback to eventual native implementation of given symbol
	hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
	isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
		SymbolPolyfill('isConcatSpreadable')),
	iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
	match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
	replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
	search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
	species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
	split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
	toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
	toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
	unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
});

// Internal tweaks for real symbol producer
defineProperties(HiddenSymbol.prototype, {
	constructor: d(SymbolPolyfill),
	toString: d('', function () { return this.__name__; })
});

// Proper implementation of methods exposed on Symbol.prototype
// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
defineProperties(SymbolPolyfill.prototype, {
	toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
	valueOf: d(function () { return validateSymbol(this); })
});
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
	var symbol = validateSymbol(this);
	if (typeof symbol === 'symbol') return symbol;
	return symbol.toString();
}));
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));

// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

// Note: It's important to define `toPrimitive` as last one, as some implementations
// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
// And that may invoke error in definition flow:
// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

},{"./validate-symbol":77,"d":16}],77:[function(require,module,exports){
'use strict';

var isSymbol = require('./is-symbol');

module.exports = function (value) {
	if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
	return value;
};

},{"./is-symbol":75}],78:[function(require,module,exports){
'use strict';

var d        = require('d')
  , callable = require('es5-ext/object/valid-callable')

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;

},{"d":16,"es5-ext/object/valid-callable":54}],79:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],80:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],81:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],82:[function(require,module,exports){
'use strict'

var Buffer = require('safe-buffer').Buffer

/* Protocol - protocol constants */
var protocol = module.exports

/* Command code => mnemonic */
protocol.types = {
  0: 'reserved',
  1: 'connect',
  2: 'connack',
  3: 'publish',
  4: 'puback',
  5: 'pubrec',
  6: 'pubrel',
  7: 'pubcomp',
  8: 'subscribe',
  9: 'suback',
  10: 'unsubscribe',
  11: 'unsuback',
  12: 'pingreq',
  13: 'pingresp',
  14: 'disconnect',
  15: 'auth'
}

/* Mnemonic => Command code */
protocol.codes = {}
for (var k in protocol.types) {
  var v = protocol.types[k]
  protocol.codes[v] = k
}

/* Header */
protocol.CMD_SHIFT = 4
protocol.CMD_MASK = 0xF0
protocol.DUP_MASK = 0x08
protocol.QOS_MASK = 0x03
protocol.QOS_SHIFT = 1
protocol.RETAIN_MASK = 0x01

/* Length */
protocol.LENGTH_MASK = 0x7F
protocol.LENGTH_FIN_MASK = 0x80

/* Connack */
protocol.SESSIONPRESENT_MASK = 0x01
protocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK])
protocol.CONNACK_HEADER = Buffer.from([protocol.codes['connack'] << protocol.CMD_SHIFT])

/* Connect */
protocol.USERNAME_MASK = 0x80
protocol.PASSWORD_MASK = 0x40
protocol.WILL_RETAIN_MASK = 0x20
protocol.WILL_QOS_MASK = 0x18
protocol.WILL_QOS_SHIFT = 3
protocol.WILL_FLAG_MASK = 0x04
protocol.CLEAN_SESSION_MASK = 0x02
protocol.CONNECT_HEADER = Buffer.from([protocol.codes['connect'] << protocol.CMD_SHIFT])

/* Properties */
protocol.properties = {
  sessionExpiryInterval: 17,
  willDelayInterval: 24,
  receiveMaximum: 33,
  maximumPacketSize: 39,
  topicAliasMaximum: 34,
  requestResponseInformation: 25,
  requestProblemInformation: 23,
  userProperties: 38,
  authenticationMethod: 21,
  authenticationData: 22,
  payloadFormatIndicator: 1,
  messageExpiryInterval: 2,
  contentType: 3,
  responseTopic: 8,
  correlationData: 9,
  maximumQoS: 36,
  retainAvailable: 37,
  assignedClientIdentifier: 18,
  reasonString: 31,
  wildcardSubscriptionAvailable: 40,
  subscriptionIdentifiersAvailable: 41,
  sharedSubscriptionAvailable: 42,
  serverKeepAlive: 19,
  responseInformation: 26,
  serverReference: 28,
  topicAlias: 35,
  subscriptionIdentifier: 11
}
protocol.propertiesCodes = {}
for (var prop in protocol.properties) {
  var id = protocol.properties[prop]
  protocol.propertiesCodes[id] = prop
}
protocol.propertiesTypes = {
  sessionExpiryInterval: 'int32',
  willDelayInterval: 'int32',
  receiveMaximum: 'int16',
  maximumPacketSize: 'int32',
  topicAliasMaximum: 'int16',
  requestResponseInformation: 'byte',
  requestProblemInformation: 'byte',
  userProperties: 'pair',
  authenticationMethod: 'string',
  authenticationData: 'binary',
  payloadFormatIndicator: 'byte',
  messageExpiryInterval: 'int32',
  contentType: 'string',
  responseTopic: 'string',
  correlationData: 'binary',
  maximumQoS: 'int8',
  retainAvailable: 'byte',
  assignedClientIdentifier: 'string',
  reasonString: 'string',
  wildcardSubscriptionAvailable: 'byte',
  subscriptionIdentifiersAvailable: 'byte',
  sharedSubscriptionAvailable: 'byte',
  serverKeepAlive: 'int32',
  responseInformation: 'string',
  serverReference: 'string',
  topicAlias: 'int16',
  subscriptionIdentifier: 'var'
}

function genHeader (type) {
  return [0, 1, 2].map(function (qos) {
    return [0, 1].map(function (dup) {
      return [0, 1].map(function (retain) {
        var buf = new Buffer(1)
        buf.writeUInt8(
          protocol.codes[type] << protocol.CMD_SHIFT |
          (dup ? protocol.DUP_MASK : 0) |
          qos << protocol.QOS_SHIFT | retain, 0, true)
        return buf
      })
    })
  })
}

/* Publish */
protocol.PUBLISH_HEADER = genHeader('publish')

/* Subscribe */
protocol.SUBSCRIBE_HEADER = genHeader('subscribe')
protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 0x03
protocol.SUBSCRIBE_OPTIONS_NL_MASK = 0x01
protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2
protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 0x01
protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3
protocol.SUBSCRIBE_OPTIONS_RH_MASK = 0x03
protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4
protocol.SUBSCRIBE_OPTIONS_RH = [0x00, 0x10, 0x20]
protocol.SUBSCRIBE_OPTIONS_NL = 0x04
protocol.SUBSCRIBE_OPTIONS_RAP = 0x08
protocol.SUBSCRIBE_OPTIONS_QOS = [0x00, 0x01, 0x02]

/* Unsubscribe */
protocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe')

/* Confirmations */
protocol.ACKS = {
  unsuback: genHeader('unsuback'),
  puback: genHeader('puback'),
  pubcomp: genHeader('pubcomp'),
  pubrel: genHeader('pubrel'),
  pubrec: genHeader('pubrec')
}

protocol.SUBACK_HEADER = Buffer.from([protocol.codes['suback'] << protocol.CMD_SHIFT])

/* Protocol versions */
protocol.VERSION3 = Buffer.from([3])
protocol.VERSION4 = Buffer.from([4])
protocol.VERSION5 = Buffer.from([5])

/* QoS */
protocol.QOS = [0, 1, 2].map(function (qos) {
  return Buffer.from([qos])
})

/* Empty packets */
protocol.EMPTY = {
  pingreq: Buffer.from([protocol.codes['pingreq'] << 4, 0]),
  pingresp: Buffer.from([protocol.codes['pingresp'] << 4, 0]),
  disconnect: Buffer.from([protocol.codes['disconnect'] << 4, 0])
}

},{"safe-buffer":110}],83:[function(require,module,exports){
'use strict'

var Buffer = require('safe-buffer').Buffer
var writeToStream = require('./writeToStream')
var EE = require('events').EventEmitter
var inherits = require('inherits')

function generate (packet, opts) {
  var stream = new Accumulator()
  writeToStream(packet, stream, opts)
  return stream.concat()
}

function Accumulator () {
  this._array = new Array(20)
  this._i = 0
}

inherits(Accumulator, EE)

Accumulator.prototype.write = function (chunk) {
  this._array[this._i++] = chunk
  return true
}

Accumulator.prototype.concat = function () {
  var length = 0
  var lengths = new Array(this._array.length)
  var list = this._array
  var pos = 0
  var i
  var result

  for (i = 0; i < list.length && list[i] !== undefined; i++) {
    if (typeof list[i] !== 'string') lengths[i] = list[i].length
    else lengths[i] = Buffer.byteLength(list[i])

    length += lengths[i]
  }

  result = Buffer.allocUnsafe(length)

  for (i = 0; i < list.length && list[i] !== undefined; i++) {
    if (typeof list[i] !== 'string') {
      list[i].copy(result, pos)
      pos += lengths[i]
    } else {
      result.write(list[i], pos)
      pos += lengths[i]
    }
  }

  return result
}

module.exports = generate

},{"./writeToStream":89,"events":13,"inherits":80,"safe-buffer":110}],84:[function(require,module,exports){
'use strict'

exports.parser = require('./parser')
exports.generate = require('./generate')
exports.writeToStream = require('./writeToStream')

},{"./generate":83,"./parser":88,"./writeToStream":89}],85:[function(require,module,exports){
var DuplexStream = require('readable-stream/duplex')
  , util         = require('util')
  , Buffer       = require('safe-buffer').Buffer


function BufferList (callback) {
  if (!(this instanceof BufferList))
    return new BufferList(callback)

  this._bufs  = []
  this.length = 0

  if (typeof callback == 'function') {
    this._callback = callback

    var piper = function piper (err) {
      if (this._callback) {
        this._callback(err)
        this._callback = null
      }
    }.bind(this)

    this.on('pipe', function onPipe (src) {
      src.on('error', piper)
    })
    this.on('unpipe', function onUnpipe (src) {
      src.removeListener('error', piper)
    })
  } else {
    this.append(callback)
  }

  DuplexStream.call(this)
}


util.inherits(BufferList, DuplexStream)


BufferList.prototype._offset = function _offset (offset) {
  var tot = 0, i = 0, _t
  if (offset === 0) return [ 0, 0 ]
  for (; i < this._bufs.length; i++) {
    _t = tot + this._bufs[i].length
    if (offset < _t || i == this._bufs.length - 1)
      return [ i, offset - tot ]
    tot = _t
  }
}


BufferList.prototype.append = function append (buf) {
  var i = 0

  if (Buffer.isBuffer(buf)) {
    this._appendBuffer(buf);
  } else if (Array.isArray(buf)) {
    for (; i < buf.length; i++)
      this.append(buf[i])
  } else if (buf instanceof BufferList) {
    // unwrap argument into individual BufferLists
    for (; i < buf._bufs.length; i++)
      this.append(buf._bufs[i])
  } else if (buf != null) {
    // coerce number arguments to strings, since Buffer(number) does
    // uninitialized memory allocation
    if (typeof buf == 'number')
      buf = buf.toString()

    this._appendBuffer(Buffer.from(buf));
  }

  return this
}


BufferList.prototype._appendBuffer = function appendBuffer (buf) {
  this._bufs.push(buf)
  this.length += buf.length
}


BufferList.prototype._write = function _write (buf, encoding, callback) {
  this._appendBuffer(buf)

  if (typeof callback == 'function')
    callback()
}


BufferList.prototype._read = function _read (size) {
  if (!this.length)
    return this.push(null)

  size = Math.min(size, this.length)
  this.push(this.slice(0, size))
  this.consume(size)
}


BufferList.prototype.end = function end (chunk) {
  DuplexStream.prototype.end.call(this, chunk)

  if (this._callback) {
    this._callback(null, this.slice())
    this._callback = null
  }
}


BufferList.prototype.get = function get (index) {
  return this.slice(index, index + 1)[0]
}


BufferList.prototype.slice = function slice (start, end) {
  if (typeof start == 'number' && start < 0)
    start += this.length
  if (typeof end == 'number' && end < 0)
    end += this.length
  return this.copy(null, 0, start, end)
}


BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart != 'number' || srcStart < 0)
    srcStart = 0
  if (typeof srcEnd != 'number' || srcEnd > this.length)
    srcEnd = this.length
  if (srcStart >= this.length)
    return dst || Buffer.alloc(0)
  if (srcEnd <= 0)
    return dst || Buffer.alloc(0)

  var copy   = !!dst
    , off    = this._offset(srcStart)
    , len    = srcEnd - srcStart
    , bytes  = len
    , bufoff = (copy && dstStart) || 0
    , start  = off[1]
    , l
    , i

  // copy/slice everything
  if (srcStart === 0 && srcEnd == this.length) {
    if (!copy) { // slice, but full concat if multiple buffers
      return this._bufs.length === 1
        ? this._bufs[0]
        : Buffer.concat(this._bufs, this.length)
    }

    // copy, need to copy individual buffers
    for (i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff)
      bufoff += this._bufs[i].length
    }

    return dst
  }

  // easy, cheap case where it's a subset of one of the buffers
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy
      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
      : this._bufs[off[0]].slice(start, start + bytes)
  }

  if (!copy) // a slice, we need something to copy in to
    dst = Buffer.allocUnsafe(len)

  for (i = off[0]; i < this._bufs.length; i++) {
    l = this._bufs[i].length - start

    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start)
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes)
      break
    }

    bufoff += l
    bytes -= l

    if (start)
      start = 0
  }

  return dst
}

BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
  start = start || 0
  end = end || this.length

  if (start < 0)
    start += this.length
  if (end < 0)
    end += this.length

  var startOffset = this._offset(start)
    , endOffset = this._offset(end)
    , buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)

  if (endOffset[1] == 0)
    buffers.pop()
  else
    buffers[buffers.length-1] = buffers[buffers.length-1].slice(0, endOffset[1])

  if (startOffset[1] != 0)
    buffers[0] = buffers[0].slice(startOffset[1])

  return new BufferList(buffers)
}

BufferList.prototype.toString = function toString (encoding, start, end) {
  return this.slice(start, end).toString(encoding)
}

BufferList.prototype.consume = function consume (bytes) {
  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length
      this.length -= this._bufs[0].length
      this._bufs.shift()
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes)
      this.length -= bytes
      break
    }
  }
  return this
}


BufferList.prototype.duplicate = function duplicate () {
  var i = 0
    , copy = new BufferList()

  for (; i < this._bufs.length; i++)
    copy.append(this._bufs[i])

  return copy
}


BufferList.prototype.destroy = function destroy () {
  this._bufs.length = 0
  this.length = 0
  this.push(null)
}


;(function () {
  var methods = {
      'readDoubleBE' : 8
    , 'readDoubleLE' : 8
    , 'readFloatBE'  : 4
    , 'readFloatLE'  : 4
    , 'readInt32BE'  : 4
    , 'readInt32LE'  : 4
    , 'readUInt32BE' : 4
    , 'readUInt32LE' : 4
    , 'readInt16BE'  : 2
    , 'readInt16LE'  : 2
    , 'readUInt16BE' : 2
    , 'readUInt16LE' : 2
    , 'readInt8'     : 1
    , 'readUInt8'    : 1
  }

  for (var m in methods) {
    (function (m) {
      BufferList.prototype[m] = function (offset) {
        return this.slice(offset, offset + methods[m])[m](0)
      }
    }(m))
  }
}())


module.exports = BufferList

},{"readable-stream/duplex":97,"safe-buffer":110,"util":117}],86:[function(require,module,exports){
'use strict'

var Buffer = require('safe-buffer').Buffer
var max = 65536
var cache = {}

function generateBuffer (i) {
  var buffer = Buffer.allocUnsafe(2)
  buffer.writeUInt8(i >> 8, 0)
  buffer.writeUInt8(i & 0x00FF, 0 + 1)

  return buffer
}

function generateCache () {
  for (var i = 0; i < max; i++) {
    cache[i] = generateBuffer(i)
  }
}

/**
 * calcVariableByteIntLength - calculate the variable byte integer
 * length field
 *
 * @api private
 */
function calcVariableByteIntLength (length) {
  if (length >= 0 && length < 128) return 1
  else if (length >= 128 && length < 16384) return 2
  else if (length >= 16384 && length < 2097152) return 3
  else if (length >= 2097152 && length < 268435456) return 4
  else return 0
}

function genBufVariableByteInt (num) {
  var digit = 0
  var pos = 0
  var length = calcVariableByteIntLength(num)
  var buffer = Buffer.allocUnsafe(length)

  do {
    digit = num % 128 | 0
    num = num / 128 | 0
    if (num > 0) digit = digit | 0x80

    buffer.writeUInt8(digit, pos++)
  } while (num > 0)

  return {
    data: buffer,
    length: length
  }
}

function generate4ByteBuffer (num) {
  var buffer = Buffer.allocUnsafe(4)
  buffer.writeUInt32BE(num, 0)
  return buffer
}

module.exports = {
  cache: cache,
  generateCache: generateCache,
  generateNumber: generateBuffer,
  genBufVariableByteInt: genBufVariableByteInt,
  generate4ByteBuffer: generate4ByteBuffer
}

},{"safe-buffer":110}],87:[function(require,module,exports){

function Packet () {
  this.cmd = null
  this.retain = false
  this.qos = 0
  this.dup = false
  this.length = -1
  this.topic = null
  this.payload = null
}

module.exports = Packet

},{}],88:[function(require,module,exports){
'use strict'

var bl = require('bl')
var inherits = require('inherits')
var EE = require('events').EventEmitter
var Packet = require('./packet')
var constants = require('./constants')

function Parser (opt) {
  if (!(this instanceof Parser)) return new Parser(opt)

  this.settings = opt || {}

  this._states = [
    '_parseHeader',
    '_parseLength',
    '_parsePayload',
    '_newPacket'
  ]

  this._resetState()
}

inherits(Parser, EE)

Parser.prototype._resetState = function () {
  this.packet = new Packet()
  this.error = null
  this._list = bl()
  this._stateCounter = 0
}

Parser.prototype.parse = function (buf) {
  if (this.error) this._resetState()

  this._list.append(buf)

  while ((this.packet.length !== -1 || this._list.length > 0) &&
  this[this._states[this._stateCounter]]() &&
  !this.error) {
    this._stateCounter++

    if (this._stateCounter >= this._states.length) this._stateCounter = 0
  }

  return this._list.length
}

Parser.prototype._parseHeader = function () {
  // There is at least one byte in the buffer
  var zero = this._list.readUInt8(0)
  this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT]
  this.packet.retain = (zero & constants.RETAIN_MASK) !== 0
  this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK
  this.packet.dup = (zero & constants.DUP_MASK) !== 0

  this._list.consume(1)

  return true
}

Parser.prototype._parseLength = function () {
  // There is at least one byte in the list
  var result = this._parseVarByteNum(true)

  if (result) {
    this.packet.length = result.value
    this._list.consume(result.bytes)
  }

  return !!result
}

Parser.prototype._parsePayload = function () {
  var result = false

  // Do we have a payload? Do we have enough data to complete the payload?
  // PINGs have no payload
  if (this.packet.length === 0 || this._list.length >= this.packet.length) {
    this._pos = 0

    switch (this.packet.cmd) {
      case 'connect':
        this._parseConnect()
        break
      case 'connack':
        this._parseConnack()
        break
      case 'publish':
        this._parsePublish()
        break
      case 'puback':
      case 'pubrec':
      case 'pubrel':
      case 'pubcomp':
        this._parseConfirmation()
        break
      case 'subscribe':
        this._parseSubscribe()
        break
      case 'suback':
        this._parseSuback()
        break
      case 'unsubscribe':
        this._parseUnsubscribe()
        break
      case 'unsuback':
        this._parseUnsuback()
        break
      case 'pingreq':
      case 'pingresp':
        // These are empty, nothing to do
        break
      case 'disconnect':
        this._parseDisconnect()
        break
      case 'auth':
        this._parseAuth()
        break
      default:
        this._emitError(new Error('Not supported'))
    }

    result = true
  }

  return result
}

Parser.prototype._parseConnect = function () {
  var protocolId // Protocol ID
  var clientId // Client ID
  var topic // Will topic
  var payload // Will payload
  var password // Password
  var username // Username
  var flags = {}
  var packet = this.packet

  // Parse protocolId
  protocolId = this._parseString()

  if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'))
  if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {
    return this._emitError(new Error('Invalid protocolId'))
  }

  packet.protocolId = protocolId

  // Parse constants version number
  if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'))

  packet.protocolVersion = this._list.readUInt8(this._pos)

  if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {
    return this._emitError(new Error('Invalid protocol version'))
  }

  this._pos++

  if (this._pos >= this._list.length) {
    return this._emitError(new Error('Packet too short'))
  }

  // Parse connect flags
  flags.username = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)
  flags.password = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)
  flags.will = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)

  if (flags.will) {
    packet.will = {}
    packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0
    packet.will.qos = (this._list.readUInt8(this._pos) &
                          constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT
  }

  packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0
  this._pos++

  // Parse keepalive
  packet.keepalive = this._parseNum()
  if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'))

  // parse properties
  if (packet.protocolVersion === 5) {
    var properties = this._parseProperties()
    if (Object.getOwnPropertyNames(properties).length) {
      packet.properties = properties
    }
  }
  // Parse clientId
  clientId = this._parseString()
  if (clientId === null) return this._emitError(new Error('Packet too short'))
  packet.clientId = clientId

  if (flags.will) {
    if (packet.protocolVersion === 5) {
      var willProperties = this._parseProperties()
      if (Object.getOwnPropertyNames(willProperties).length) {
        packet.will.properties = willProperties
      }
    }
    // Parse will topic
    topic = this._parseString()
    if (topic === null) return this._emitError(new Error('Cannot parse will topic'))
    packet.will.topic = topic

    // Parse will payload
    payload = this._parseBuffer()
    if (payload === null) return this._emitError(new Error('Cannot parse will payload'))
    packet.will.payload = payload
  }

  // Parse username
  if (flags.username) {
    username = this._parseString()
    if (username === null) return this._emitError(new Error('Cannot parse username'))
    packet.username = username
  }

  // Parse password
  if (flags.password) {
    password = this._parseBuffer()
    if (password === null) return this._emitError(new Error('Cannot parse password'))
    packet.password = password
  }
  // need for right parse auth packet and self set up
  this.settings = packet

  return packet
}

Parser.prototype._parseConnack = function () {
  var packet = this.packet

  if (this._list.length < 2) return null

  packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK)
  if (this.settings.protocolVersion === 5) {
    packet.reasonCode = this._list.readUInt8(this._pos++)
  } else {
    packet.returnCode = this._list.readUInt8(this._pos++)
  }

  if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'))
  // mqtt 5 properties
  if (this.settings.protocolVersion === 5) {
    var properties = this._parseProperties()
    if (Object.getOwnPropertyNames(properties).length) {
      packet.properties = properties
    }
  }
}

Parser.prototype._parsePublish = function () {
  var packet = this.packet
  packet.topic = this._parseString()

  if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'))

  // Parse messageId
  if (packet.qos > 0) if (!this._parseMessageId()) { return }

  // Properties mqtt 5
  if (this.settings.protocolVersion === 5) {
    var properties = this._parseProperties()
    if (Object.getOwnPropertyNames(properties).length) {
      packet.properties = properties
    }
  }

  packet.payload = this._list.slice(this._pos, packet.length)
}

Parser.prototype._parseSubscribe = function () {
  var packet = this.packet
  var topic
  var options
  var qos
  var rh
  var rap
  var nl
  var subscription

  if (packet.qos !== 1) {
    return this._emitError(new Error('Wrong subscribe header'))
  }

  packet.subscriptions = []

  if (!this._parseMessageId()) { return }

  // Properties mqtt 5
  if (this.settings.protocolVersion === 5) {
    var properties = this._parseProperties()
    if (Object.getOwnPropertyNames(properties).length) {
      packet.properties = properties
    }
  }

  while (this._pos < packet.length) {
    // Parse topic
    topic = this._parseString()
    if (topic === null) return this._emitError(new Error('Cannot parse topic'))

    options = this._parseByte()
    qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK
    nl = ((options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT) & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0
    rap = ((options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT) & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0
    rh = (options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT) & constants.SUBSCRIBE_OPTIONS_RH_MASK

    subscription = { topic: topic, qos: qos }

    // mqtt 5 options
    if (this.settings.protocolVersion === 5) {
      subscription.nl = nl
      subscription.rap = rap
      subscription.rh = rh
    }

    // Push pair to subscriptions
    packet.subscriptions.push(subscription)
  }
}

Parser.prototype._parseSuback = function () {
  var packet = this.packet
  this.packet.granted = []

  if (!this._parseMessageId()) { return }

  // Properties mqtt 5
  if (this.settings.protocolVersion === 5) {
    var properties = this._parseProperties()
    if (Object.getOwnPropertyNames(properties).length) {
      packet.properties = properties
    }
  }

  // Parse granted QoSes
  while (this._pos < this.packet.length) {
    this.packet.granted.push(this._list.readUInt8(this._pos++))
  }
}

Parser.prototype._parseUnsubscribe = function () {
  var packet = this.packet

  packet.unsubscriptions = []

  // Parse messageId
  if (!this._parseMessageId()) { return }

  // Properties mqtt 5
  if (this.settings.protocolVersion === 5) {
    var properties = this._parseProperties()
    if (Object.getOwnPropertyNames(properties).length) {
      packet.properties = properties
    }
  }

  while (this._pos < packet.length) {
    var topic

    // Parse topic
    topic = this._parseString()
    if (topic === null) return this._emitError(new Error('Cannot parse topic'))

    // Push topic to unsubscriptions
    packet.unsubscriptions.push(topic)
  }
}

Parser.prototype._parseUnsuback = function () {
  var packet = this.packet
  if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'))
  // Properties mqtt 5
  if (this.settings.protocolVersion === 5) {
    var properties = this._parseProperties()
    if (Object.getOwnPropertyNames(properties).length) {
      packet.properties = properties
    }
    // Parse granted QoSes
    packet.granted = []
    while (this._pos < this.packet.length) {
      this.packet.granted.push(this._list.readUInt8(this._pos++))
    }
  }
}

// parse packets like puback, pubrec, pubrel, pubcomp
Parser.prototype._parseConfirmation = function () {
  var packet = this.packet

  this._parseMessageId()

  if (this.settings.protocolVersion === 5) {
    if (packet.length > 2) {
      // response code
      packet.reasonCode = this._parseByte()
      // properies mqtt 5
      var properties = this._parseProperties()
      if (Object.getOwnPropertyNames(properties).length) {
        packet.properties = properties
      }
    }
  }

  return true
}

// parse disconnect packet
Parser.prototype._parseDisconnect = function () {
  var packet = this.packet

  if (this.settings.protocolVersion === 5) {
    // response code
    packet.reasonCode = this._parseByte()
    // properies mqtt 5
    var properties = this._parseProperties()
    if (Object.getOwnPropertyNames(properties).length) {
      packet.properties = properties
    }
  }

  return true
}

// parse auth packet
Parser.prototype._parseAuth = function () {
  var packet = this.packet

  if (this.settings.protocolVersion !== 5) {
    return this._emitError(new Error('Not supported auth packet for this version MQTT'))
  }

  // response code
  packet.reasonCode = this._parseByte()
  // properies mqtt 5
  var properties = this._parseProperties()
  if (Object.getOwnPropertyNames(properties).length) {
    packet.properties = properties
  }

  return true
}

Parser.prototype._parseMessageId = function () {
  var packet = this.packet

  packet.messageId = this._parseNum()

  if (packet.messageId === null) {
    this._emitError(new Error('Cannot parse messageId'))
    return false
  }

  return true
}

Parser.prototype._parseString = function (maybeBuffer) {
  var length = this._parseNum()
  var result
  var end = length + this._pos

  if (length === -1 || end > this._list.length || end > this.packet.length) return null

  result = this._list.toString('utf8', this._pos, end)
  this._pos += length

  return result
}

Parser.prototype._parseStringPair = function () {
  return {
    name: this._parseString(),
    value: this._parseString()
  }
}

Parser.prototype._parseBuffer = function () {
  var length = this._parseNum()
  var result
  var end = length + this._pos

  if (length === -1 || end > this._list.length || end > this.packet.length) return null

  result = this._list.slice(this._pos, end)

  this._pos += length

  return result
}

Parser.prototype._parseNum = function () {
  if (this._list.length - this._pos < 2) return -1

  var result = this._list.readUInt16BE(this._pos)
  this._pos += 2

  return result
}

Parser.prototype._parse4ByteNum = function () {
  if (this._list.length - this._pos < 4) return -1

  var result = this._list.readUInt32BE(this._pos)
  this._pos += 4

  return result
}

Parser.prototype._parseVarByteNum = function (fullInfoFlag) {
  var bytes = 0
  var mul = 1
  var length = 0
  var result = true
  var current
  var padding = this._pos ? this._pos : 0

  while (bytes < 5) {
    current = this._list.readUInt8(padding + bytes++)
    length += mul * (current & constants.LENGTH_MASK)
    mul *= 0x80

    if ((current & constants.LENGTH_FIN_MASK) === 0) break
    if (this._list.length <= bytes) {
      result = false
      break
    }
  }

  if (padding) {
    this._pos += bytes
  }

  result = result
    ? fullInfoFlag ? {
      bytes: bytes,
      value: length
    } : length
    : false

  return result
}

Parser.prototype._parseByte = function () {
  var result = this._list.readUInt8(this._pos)
  this._pos++
  return result
}

Parser.prototype._parseByType = function (type) {
  switch (type) {
    case 'byte': {
      return this._parseByte() !== 0
    }
    case 'int8': {
      return this._parseByte()
    }
    case 'int16': {
      return this._parseNum()
    }
    case 'int32': {
      return this._parse4ByteNum()
    }
    case 'var': {
      return this._parseVarByteNum()
    }
    case 'string': {
      return this._parseString()
    }
    case 'pair': {
      return this._parseStringPair()
    }
    case 'binary': {
      return this._parseBuffer()
    }
  }
}

Parser.prototype._parseProperties = function () {
  var length = this._parseVarByteNum()
  var start = this._pos
  var end = start + length
  var result = {}
  while (this._pos < end) {
    var type = this._parseByte()
    var name = constants.propertiesCodes[type]
    if (!name) {
      this._emitError(new Error('Unknown property'))
      return false
    }
    // user properties process
    if (name === 'userProperties') {
      if (!result[name]) {
        result[name] = {}
      }
      var currentUserProperty = this._parseByType(constants.propertiesTypes[name])
      result[name][currentUserProperty.name] = currentUserProperty.value
      continue
    }
    result[name] = this._parseByType(constants.propertiesTypes[name])
  }
  return result
}

Parser.prototype._newPacket = function () {
  if (this.packet) {
    this._list.consume(this.packet.length)
    this.emit('packet', this.packet)
  }

  this.packet = new Packet()

  this._pos = 0

  return true
}

Parser.prototype._emitError = function (err) {
  this.error = err
  this.emit('error', err)
}

module.exports = Parser

},{"./constants":82,"./packet":87,"bl":85,"events":13,"inherits":80}],89:[function(require,module,exports){
'use strict'

var protocol = require('./constants')
var Buffer = require('safe-buffer').Buffer
var empty = Buffer.allocUnsafe(0)
var zeroBuf = Buffer.from([0])
var numbers = require('./numbers')
var nextTick = require('process-nextick-args').nextTick

var numCache = numbers.cache
var generateNumber = numbers.generateNumber
var generateCache = numbers.generateCache
var genBufVariableByteInt = numbers.genBufVariableByteInt
var generate4ByteBuffer = numbers.generate4ByteBuffer
var writeNumber = writeNumberCached
var toGenerate = true

function generate (packet, stream, opts) {
  if (stream.cork) {
    stream.cork()
    nextTick(uncork, stream)
  }

  if (toGenerate) {
    toGenerate = false
    generateCache()
  }

  switch (packet.cmd) {
    case 'connect':
      return connect(packet, stream, opts)
    case 'connack':
      return connack(packet, stream, opts)
    case 'publish':
      return publish(packet, stream, opts)
    case 'puback':
    case 'pubrec':
    case 'pubrel':
    case 'pubcomp':
      return confirmation(packet, stream, opts)
    case 'subscribe':
      return subscribe(packet, stream, opts)
    case 'suback':
      return suback(packet, stream, opts)
    case 'unsubscribe':
      return unsubscribe(packet, stream, opts)
    case 'unsuback':
      return unsuback(packet, stream, opts)
    case 'pingreq':
    case 'pingresp':
      return emptyPacket(packet, stream, opts)
    case 'disconnect':
      return disconnect(packet, stream, opts)
    case 'auth':
      return auth(packet, stream, opts)
    default:
      stream.emit('error', new Error('Unknown command'))
      return false
  }
}
/**
 * Controls numbers cache.
 * Set to "false" to allocate buffers on-the-flight instead of pre-generated cache
 */
Object.defineProperty(generate, 'cacheNumbers', {
  get: function () {
    return writeNumber === writeNumberCached
  },
  set: function (value) {
    if (value) {
      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true
      writeNumber = writeNumberCached
    } else {
      toGenerate = false
      writeNumber = writeNumberGenerated
    }
  }
})

function uncork (stream) {
  stream.uncork()
}

function connect (packet, stream, opts) {
  var settings = packet || {}
  var protocolId = settings.protocolId || 'MQTT'
  var protocolVersion = settings.protocolVersion || 4
  var will = settings.will
  var clean = settings.clean
  var keepalive = settings.keepalive || 0
  var clientId = settings.clientId || ''
  var username = settings.username
  var password = settings.password
  /* mqtt5 new oprions */
  var properties = settings.properties

  if (clean === undefined) clean = true

  var length = 0

  // Must be a string and non-falsy
  if (!protocolId ||
     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {
    stream.emit('error', new Error('Invalid protocolId'))
    return false
  } else length += protocolId.length + 2

  // Must be 3 or 4 or 5
  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {
    stream.emit('error', new Error('Invalid protocol version'))
    return false
  } else length += 1

  // ClientId might be omitted in 3.1.1, but only if cleanSession is set to 1
  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&
     (clientId || protocolVersion === 4) && (clientId || clean)) {
    length += clientId.length + 2
  } else {
    if (protocolVersion < 4) {
      stream.emit('error', new Error('clientId must be supplied before 3.1.1'))
      return false
    }
    if ((clean * 1) === 0) {
      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'))
      return false
    }
  }

  // Must be a two byte number
  if (typeof keepalive !== 'number' ||
      keepalive < 0 ||
      keepalive > 65535 ||
      keepalive % 1 !== 0) {
    stream.emit('error', new Error('Invalid keepalive'))
    return false
  } else length += 2

  // Connect flags
  length += 1

  // Properties
  if (protocolVersion === 5) {
    var propertiesData = getProperties(stream, properties)
    length += propertiesData.length
  }

  // If will exists...
  if (will) {
    // It must be an object
    if (typeof will !== 'object') {
      stream.emit('error', new Error('Invalid will'))
      return false
    }
    // It must have topic typeof string
    if (!will.topic || typeof will.topic !== 'string') {
      stream.emit('error', new Error('Invalid will topic'))
      return false
    } else {
      length += Buffer.byteLength(will.topic) + 2
    }

    // Payload
    if (will.payload) {
      if (will.payload.length >= 0) {
        if (typeof will.payload === 'string') {
          length += Buffer.byteLength(will.payload) + 2
        } else {
          length += will.payload.length + 2
        }
      } else {
        stream.emit('error', new Error('Invalid will payload'))
        return false
      }

      // will properties
      var willProperties = {}
      if (protocolVersion === 5) {
        willProperties = getProperties(stream, will.properties)
        length += willProperties.length
      }
    }
  }

  // Username
  var providedUsername = false
  if (username != null) {
    if (isStringOrBuffer(username)) {
      providedUsername = true
      length += Buffer.byteLength(username) + 2
    } else {
      stream.emit('error', new Error('Invalid username'))
      return false
    }
  }

  // Password
  if (password != null) {
    if (!providedUsername) {
      stream.emit('error', new Error('Username is required to use password'))
      return false
    }

    if (isStringOrBuffer(password)) {
      length += byteLength(password) + 2
    } else {
      stream.emit('error', new Error('Invalid password'))
      return false
    }
  }

  // Generate header
  stream.write(protocol.CONNECT_HEADER)

  // Generate length
  writeVarByteInt(stream, length)

  // Generate protocol ID
  writeStringOrBuffer(stream, protocolId)
  stream.write(
    protocolVersion === 4
      ? protocol.VERSION4
      : protocolVersion === 5
        ? protocol.VERSION5
        : protocol.VERSION3
  )

  // Connect flags
  var flags = 0
  flags |= (username != null) ? protocol.USERNAME_MASK : 0
  flags |= (password != null) ? protocol.PASSWORD_MASK : 0
  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0
  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0
  flags |= will ? protocol.WILL_FLAG_MASK : 0
  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0

  stream.write(Buffer.from([flags]))

  // Keepalive
  writeNumber(stream, keepalive)

  // Properties
  if (protocolVersion === 5) {
    propertiesData.write()
  }

  // Client ID
  writeStringOrBuffer(stream, clientId)

  // Will
  if (will) {
    if (protocolVersion === 5) {
      willProperties.write()
    }
    writeString(stream, will.topic)
    writeStringOrBuffer(stream, will.payload)
  }

  // Username and password
  if (username != null) {
    writeStringOrBuffer(stream, username)
  }
  if (password != null) {
    writeStringOrBuffer(stream, password)
  }
  // This is a small packet that happens only once on a stream
  // We assume the stream is always free to receive more data after this
  return true
}

function connack (packet, stream, opts) {
  var version = opts ? opts.protocolVersion : 4
  var settings = packet || {}
  var rc = version === 5 ? settings.reasonCode : settings.returnCode
  var properties = settings.properties
  var length = 2 // length of rc and sessionHeader

  // Check return code
  if (typeof rc !== 'number') {
    stream.emit('error', new Error('Invalid return code'))
    return false
  }
  // mqtt5 properties
  var propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    length += propertiesData.length
  }

  stream.write(protocol.CONNACK_HEADER)
  // length
  writeVarByteInt(stream, length)
  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)

  stream.write(Buffer.from([rc]))
  if (propertiesData != null) {
    propertiesData.write()
  }
  return true
}

function publish (packet, stream, opts) {
  var version = opts ? opts.protocolVersion : 4
  var settings = packet || {}
  var qos = settings.qos || 0
  var retain = settings.retain ? protocol.RETAIN_MASK : 0
  var topic = settings.topic
  var payload = settings.payload || empty
  var id = settings.messageId
  var properties = settings.properties

  var length = 0

  // Topic must be a non-empty string or Buffer
  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2
  else if (Buffer.isBuffer(topic)) length += topic.length + 2
  else {
    stream.emit('error', new Error('Invalid topic'))
    return false
  }

  // Get the payload length
  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)
  else length += payload.length

  // Message ID must a number if qos > 0
  if (qos && typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  } else if (qos) length += 2

  // mqtt5 properties
  var propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    length += propertiesData.length
  }

  // Header
  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0])

  // Remaining length
  writeVarByteInt(stream, length)

  // Topic
  writeNumber(stream, byteLength(topic))
  stream.write(topic)

  // Message ID
  if (qos > 0) writeNumber(stream, id)

  // Properties
  if (propertiesData != null) {
    propertiesData.write()
  }

  // Payload
  return stream.write(payload)
}

/* Puback, pubrec, pubrel and pubcomp */
function confirmation (packet, stream, opts) {
  var version = opts ? opts.protocolVersion : 4
  var settings = packet || {}
  var type = settings.cmd || 'puback'
  var id = settings.messageId
  var dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0
  var qos = 0
  var reasonCode = settings.reasonCode
  var properties = settings.properties
  var length = version === 5 ? 3 : 2

  if (type === 'pubrel') qos = 1

  // Check message ID
  if (typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  }

  // properies mqtt 5
  var propertiesData = null
  if (version === 5) {
    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Header
  stream.write(protocol.ACKS[type][qos][dup][0])

  // Length
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // reason code in header
  if (version === 5) {
    stream.write(Buffer.from([reasonCode]))
  }

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }
  return true
}

function subscribe (packet, stream, opts) {
  var version = opts ? opts.protocolVersion : 4
  var settings = packet || {}
  var dup = settings.dup ? protocol.DUP_MASK : 0
  var id = settings.messageId
  var subs = settings.subscriptions
  var properties = settings.properties

  var length = 0

  // Check message ID
  if (typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  } else length += 2

  // properies mqtt 5
  var propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    length += propertiesData.length
  }

  // Check subscriptions
  if (typeof subs === 'object' && subs.length) {
    for (var i = 0; i < subs.length; i += 1) {
      var itopic = subs[i].topic
      var iqos = subs[i].qos

      if (typeof itopic !== 'string') {
        stream.emit('error', new Error('Invalid subscriptions - invalid topic'))
        return false
      }
      if (typeof iqos !== 'number') {
        stream.emit('error', new Error('Invalid subscriptions - invalid qos'))
        return false
      }

      if (version === 5) {
        var nl = subs[i].nl || false
        if (typeof nl !== 'boolean') {
          stream.emit('error', new Error('Invalid subscriptions - invalid No Local'))
          return false
        }
        var rap = subs[i].rap || false
        if (typeof rap !== 'boolean') {
          stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'))
          return false
        }
        var rh = subs[i].rh || 0
        if (typeof rh !== 'number' || rh > 2) {
          stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'))
          return false
        }
      }

      length += Buffer.byteLength(itopic) + 2 + 1
    }
  } else {
    stream.emit('error', new Error('Invalid subscriptions'))
    return false
  }

  // Generate header
  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])

  // Generate length
  writeVarByteInt(stream, length)

  // Generate message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  var result = true

  // Generate subs
  for (var j = 0; j < subs.length; j++) {
    var sub = subs[j]
    var jtopic = sub.topic
    var jqos = sub.qos
    var jnl = +sub.nl
    var jrap = +sub.rap
    var jrh = sub.rh
    var joptions

    // Write topic string
    writeString(stream, jtopic)

    // options process
    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos]
    if (version === 5) {
      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0
      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0
      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0
    }
    // Write options
    result = stream.write(Buffer.from([joptions]))
  }

  return result
}

function suback (packet, stream, opts) {
  var version = opts ? opts.protocolVersion : 4
  var settings = packet || {}
  var id = settings.messageId
  var granted = settings.granted
  var properties = settings.properties
  var length = 0

  // Check message ID
  if (typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  } else length += 2

  // Check granted qos vector
  if (typeof granted === 'object' && granted.length) {
    for (var i = 0; i < granted.length; i += 1) {
      if (typeof granted[i] !== 'number') {
        stream.emit('error', new Error('Invalid qos vector'))
        return false
      }
      length += 1
    }
  } else {
    stream.emit('error', new Error('Invalid qos vector'))
    return false
  }

  // properies mqtt 5
  var propertiesData = null
  if (version === 5) {
    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // header
  stream.write(protocol.SUBACK_HEADER)

  // Length
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  return stream.write(Buffer.from(granted))
}

function unsubscribe (packet, stream, opts) {
  var version = opts ? opts.protocolVersion : 4
  var settings = packet || {}
  var id = settings.messageId
  var dup = settings.dup ? protocol.DUP_MASK : 0
  var unsubs = settings.unsubscriptions
  var properties = settings.properties

  var length = 0

  // Check message ID
  if (typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  } else {
    length += 2
  }
  // Check unsubs
  if (typeof unsubs === 'object' && unsubs.length) {
    for (var i = 0; i < unsubs.length; i += 1) {
      if (typeof unsubs[i] !== 'string') {
        stream.emit('error', new Error('Invalid unsubscriptions'))
        return false
      }
      length += Buffer.byteLength(unsubs[i]) + 2
    }
  } else {
    stream.emit('error', new Error('Invalid unsubscriptions'))
    return false
  }
  // properies mqtt 5
  var propertiesData = null
  if (version === 5) {
    propertiesData = getProperties(stream, properties)
    length += propertiesData.length
  }

  // Header
  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])

  // Length
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  // Unsubs
  var result = true
  for (var j = 0; j < unsubs.length; j++) {
    result = writeString(stream, unsubs[j])
  }

  return result
}

function unsuback (packet, stream, opts) {
  var version = opts ? opts.protocolVersion : 4
  var settings = packet || {}
  var id = settings.messageId
  var dup = settings.dup ? protocol.DUP_MASK : 0
  var granted = settings.granted
  var properties = settings.properties
  var type = settings.cmd
  var qos = 0

  var length = 2

  // Check message ID
  if (typeof id !== 'number') {
    stream.emit('error', new Error('Invalid messageId'))
    return false
  }

  // Check granted
  if (version === 5) {
    if (typeof granted === 'object' && granted.length) {
      for (var i = 0; i < granted.length; i += 1) {
        if (typeof granted[i] !== 'number') {
          stream.emit('error', new Error('Invalid qos vector'))
          return false
        }
        length += 1
      }
    } else {
      stream.emit('error', new Error('Invalid qos vector'))
      return false
    }
  }

  // properies mqtt 5
  var propertiesData = null
  if (version === 5) {
    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Header
  stream.write(protocol.ACKS[type][qos][dup][0])

  // Length
  writeVarByteInt(stream, length)

  // Message ID
  writeNumber(stream, id)

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  // payload
  if (version === 5) {
    stream.write(Buffer.from(granted))
  }
  return true
}

function emptyPacket (packet, stream, opts) {
  return stream.write(protocol.EMPTY[packet.cmd])
}

function disconnect (packet, stream, opts) {
  var version = opts ? opts.protocolVersion : 4
  var settings = packet || {}
  var reasonCode = settings.reasonCode
  var properties = settings.properties
  var length = version === 5 ? 1 : 0

  // properies mqtt 5
  var propertiesData = null
  if (version === 5) {
    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
    if (!propertiesData) { return false }
    length += propertiesData.length
  }

  // Header
  stream.write(Buffer.from([protocol.codes['disconnect'] << 4]))

  // Length
  writeVarByteInt(stream, length)

  // reason code in header
  if (version === 5) {
    stream.write(Buffer.from([reasonCode]))
  }

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }

  return true
}

function auth (packet, stream, opts) {
  var version = opts ? opts.protocolVersion : 4
  var settings = packet || {}
  var reasonCode = settings.reasonCode
  var properties = settings.properties
  var length = version === 5 ? 1 : 0

  if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet'))

  // properies mqtt 5
  var propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)
  if (!propertiesData) { return false }
  length += propertiesData.length

  // Header
  stream.write(Buffer.from([protocol.codes['auth'] << 4]))

  // Length
  writeVarByteInt(stream, length)

  // reason code in header
  stream.write(Buffer.from([reasonCode]))

  // properies mqtt 5
  if (propertiesData !== null) {
    propertiesData.write()
  }
  return true
}

/**
 * writeVarByteInt - write an MQTT style variable byte integer to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <Number> length - length (>0)
 * @returns <Number> number of bytes written
 *
 * @api private
 */

var varByteIntCache = {}
function writeVarByteInt (stream, num) {
  var buffer = varByteIntCache[num]

  if (!buffer) {
    buffer = genBufVariableByteInt(num).data
    if (num < 16384) varByteIntCache[num] = buffer
  }

  stream.write(buffer)
}

/**
 * writeString - write a utf8 string to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <String> string - string to write
 * @return <Number> number of bytes written
 *
 * @api private
 */

function writeString (stream, string) {
  var strlen = Buffer.byteLength(string)
  writeNumber(stream, strlen)

  stream.write(string, 'utf8')
}

/**
 * writeStringPair - write a utf8 string pairs to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <String> name - string name to write
 * @param <String> value - string value to write
 * @return <Number> number of bytes written
 *
 * @api private
 */
function writeStringPair (stream, name, value) {
  writeString(stream, name)
  writeString(stream, value)
}

/**
 * writeNumber - write a two byte number to the buffer
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <String> number - number to write
 * @return <Number> number of bytes written
 *
 * @api private
 */
function writeNumberCached (stream, number) {
  return stream.write(numCache[number])
}
function writeNumberGenerated (stream, number) {
  return stream.write(generateNumber(number))
}
function write4ByteNumber (stream, number) {
  return stream.write(generate4ByteBuffer(number))
}
/**
 * writeStringOrBuffer - write a String or Buffer with the its length prefix
 *
 * @param <Buffer> buffer - destination
 * @param <Number> pos - offset
 * @param <String> toWrite - String or Buffer
 * @return <Number> number of bytes written
 */
function writeStringOrBuffer (stream, toWrite) {
  if (typeof toWrite === 'string') {
    writeString(stream, toWrite)
  } else if (toWrite) {
    writeNumber(stream, toWrite.length)
    stream.write(toWrite)
  } else writeNumber(stream, 0)
}

function getProperties (stream, properties) {
  /* connect properties */
  if (typeof properties !== 'object' || properties.length != null) {
    return {
      length: 1,
      write: function () {
        writeProperties(stream, {}, 0)
      }
    }
  }
  var propertiesLength = 0
  function getLengthProperty (name) {
    var type = protocol.propertiesTypes[name]
    var value = properties[name]
    var length = 0
    switch (type) {
      case 'byte': {
        if (typeof value !== 'boolean') {
          stream.emit('error', new Error('Invalid ' + name))
          return false
        }
        length += 1 + 1
        break
      }
      case 'int8': {
        if (typeof value !== 'number') {
          stream.emit('error', new Error('Invalid ' + name))
          return false
        }
        length += 1 + 1
        break
      }
      case 'binary': {
        if (value && value === null) {
          stream.emit('error', new Error('Invalid ' + name))
          return false
        }
        length += 1 + Buffer.byteLength(value) + 2
        break
      }
      case 'int16': {
        if (typeof value !== 'number') {
          stream.emit('error', new Error('Invalid ' + name))
          return false
        }
        length += 1 + 2
        break
      }
      case 'int32': {
        if (typeof value !== 'number') {
          stream.emit('error', new Error('Invalid ' + name))
          return false
        }
        length += 1 + 4
        break
      }
      case 'var': {
        if (typeof value !== 'number') {
          stream.emit('error', new Error('Invalid ' + name))
          return false
        }
        length += 1 + genBufVariableByteInt(value).length
        break
      }
      case 'string': {
        if (typeof value !== 'string') {
          stream.emit('error', new Error('Invalid ' + name))
          return false
        }
        length += 1 + 2 + Buffer.byteLength(value.toString())
        break
      }
      case 'pair': {
        if (typeof value !== 'object') {
          stream.emit('error', new Error('Invalid ' + name))
          return false
        }
        length += Object.getOwnPropertyNames(value).reduce(function (result, name) {
          result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString())
          return result
        }, 0)
        break
      }
      default: {
        stream.emit('error', new Error('Invalid property ' + name))
        return false
      }
    }
    return length
  }
  if (properties) {
    for (var propName in properties) {
      var propLength = getLengthProperty(propName)
      if (!propLength) return false
      propertiesLength += propLength
    }
  }
  var propertiesLengthLength = genBufVariableByteInt(propertiesLength).length

  return {
    length: propertiesLengthLength + propertiesLength,
    write: function () {
      writeProperties(stream, properties, propertiesLength)
    }
  }
}

function getPropertiesByMaximumPacketSize (stream, properties, opts, length) {
  var mayEmptyProps = ['reasonString', 'userProperties']
  var maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0

  var propertiesData = getProperties(stream, properties)
  if (maximumPacketSize) {
    while (length + propertiesData.length > maximumPacketSize) {
      var currentMayEmptyProp = mayEmptyProps.shift()
      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {
        delete properties[currentMayEmptyProp]
        propertiesData = getProperties(stream, properties)
      } else {
        return false
      }
    }
  }
  return propertiesData
}

function writeProperties (stream, properties, propertiesLength) {
  /* write properties to stream */
  writeVarByteInt(stream, propertiesLength)
  for (var propName in properties) {
    if (properties.hasOwnProperty(propName) && properties[propName] !== null) {
      var value = properties[propName]
      var type = protocol.propertiesTypes[propName]
      switch (type) {
        case 'byte': {
          stream.write(Buffer.from([protocol.properties[propName]]))
          stream.write(Buffer.from([+value]))
          break
        }
        case 'int8': {
          stream.write(Buffer.from([protocol.properties[propName]]))
          stream.write(Buffer.from([value]))
          break
        }
        case 'binary': {
          stream.write(Buffer.from([protocol.properties[propName]]))
          writeStringOrBuffer(stream, value)
          break
        }
        case 'int16': {
          stream.write(Buffer.from([protocol.properties[propName]]))
          writeNumber(stream, value)
          break
        }
        case 'int32': {
          stream.write(Buffer.from([protocol.properties[propName]]))
          write4ByteNumber(stream, value)
          break
        }
        case 'var': {
          stream.write(Buffer.from([protocol.properties[propName]]))
          writeVarByteInt(stream, value)
          break
        }
        case 'string': {
          stream.write(Buffer.from([protocol.properties[propName]]))
          writeString(stream, value)
          break
        }
        case 'pair': {
          Object.getOwnPropertyNames(value).forEach(function (name) {
            stream.write(Buffer.from([protocol.properties[propName]]))
            writeStringPair(stream, name.toString(), value[name].toString())
          })
          break
        }
        default: {
          stream.emit('error', new Error('Invalid property ' + propName))
          return false
        }
      }
    }
  }
}

function byteLength (bufOrString) {
  if (!bufOrString) return 0
  else if (bufOrString instanceof Buffer) return bufOrString.length
  else return Buffer.byteLength(bufOrString)
}

function isStringOrBuffer (field) {
  return typeof field === 'string' || field instanceof Buffer
}

module.exports = generate

},{"./constants":82,"./numbers":86,"process-nextick-args":91,"safe-buffer":110}],90:[function(require,module,exports){
var wrappy = require('wrappy')
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}

},{"wrappy":120}],91:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":92}],92:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],93:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],94:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],95:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],96:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":94,"./encode":95}],97:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":98}],98:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":100,"./_stream_writable":102,"core-util-is":14,"inherits":80,"process-nextick-args":91}],99:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":101,"core-util-is":14,"inherits":80}],100:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":98,"./internal/streams/BufferList":103,"./internal/streams/destroy":104,"./internal/streams/stream":105,"_process":92,"core-util-is":14,"events":13,"inherits":80,"isarray":106,"process-nextick-args":91,"safe-buffer":110,"string_decoder/":107,"util":11}],101:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":98,"core-util-is":14,"inherits":80}],102:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":98,"./internal/streams/destroy":104,"./internal/streams/stream":105,"_process":92,"core-util-is":14,"inherits":80,"process-nextick-args":91,"safe-buffer":110,"timers":112,"util-deprecate":115}],103:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":110,"util":11}],104:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":91}],105:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":13}],106:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],107:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":110}],108:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":98,"./lib/_stream_passthrough.js":99,"./lib/_stream_readable.js":100,"./lib/_stream_transform.js":101,"./lib/_stream_writable.js":102}],109:[function(require,module,exports){
'use strict'

function ReInterval (callback, interval, args) {
  var self = this;

  this._callback = callback;
  this._args = args;

  this._interval = setInterval(callback, interval, this._args);

  this.reschedule = function (interval) {
    // if no interval entered, use the interval passed in on creation
    if (!interval)
      interval = self._interval;

    if (self._interval)
      clearInterval(self._interval);
    self._interval = setInterval(self._callback, interval, self._args);
  };

  this.clear = function () {
    if (self._interval) {
      clearInterval(self._interval);
      self._interval = undefined;
    }
  };
  
  this.destroy = function () {
    if (self._interval) {
      clearInterval(self._interval);
    }
    self._callback = undefined;
    self._interval = undefined;
    self._args = undefined;
  };
}

function reInterval () {
  if (typeof arguments[0] !== 'function')
    throw new Error('callback needed');
  if (typeof arguments[1] !== 'number')
    throw new Error('interval needed');

  var args;

  if (arguments.length > 0) {
    args = new Array(arguments.length - 2);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 2];
    }
  }

  return new ReInterval(arguments[0], arguments[1], args);
}

module.exports = reInterval;

},{}],110:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":12}],111:[function(require,module,exports){
module.exports = shift

function shift (stream) {
  var rs = stream._readableState
  if (!rs) return null
  return rs.objectMode ? stream.read() : stream.read(getStateLength(rs))
}

function getStateLength (state) {
  if (state.buffer.length) {
    // Since node 6.3.0 state.buffer is a BufferList not an array
    if (state.buffer.head) {
      return state.buffer.head.data.length
    }

    return state.buffer[0].length
  }

  return state.length
}

},{}],112:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":92,"timers":112}],113:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":114,"punycode":93,"querystring":96}],114:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],115:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],116:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],117:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":116,"_process":92,"inherits":80}],118:[function(require,module,exports){
(function (process,global){
'use strict'

var Transform = require('readable-stream').Transform
var duplexify = require('duplexify')
var WS = require('ws')
var Buffer = require('safe-buffer').Buffer

module.exports = WebSocketStream

function buildProxy (options, socketWrite, socketEnd) {
  var proxy = new Transform({
    objectMode: options.objectMode
  })

  proxy._write = socketWrite
  proxy._flush = socketEnd

  return proxy
}

function WebSocketStream(target, protocols, options) {
  var stream, socket

  var isBrowser = process.title === 'browser'
  var isNative = !!global.WebSocket
  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode

  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {
    // accept the "options" Object as the 2nd argument
    options = protocols
    protocols = null

    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {
      protocols = options.protocol;
    }
  }

  if (!options) options = {}

  if (options.objectMode === undefined) {
    options.objectMode = !(options.binary === true || options.binary === undefined)
  }

  var proxy = buildProxy(options, socketWrite, socketEnd)

  if (!options.objectMode) {
    proxy._writev = writev
  }

  // browser only: sets the maximum socket buffer size before throttling
  var bufferSize = options.browserBufferSize || 1024 * 512

  // browser only: how long to wait when throttling
  var bufferTimeout = options.browserBufferTimeout || 1000

  // use existing WebSocket object that was passed in
  if (typeof target === 'object') {
    socket = target
  // otherwise make a new one
  } else {
    // special constructor treatment for native websockets in browsers, see
    // https://github.com/maxogden/websocket-stream/issues/82
    if (isNative && isBrowser) {
      socket = new WS(target, protocols)
    } else {
      socket = new WS(target, protocols, options)
    }

    socket.binaryType = 'arraybuffer'
  }

  // was already open when passed in
  if (socket.readyState === socket.OPEN) {
    stream = proxy
  } else {
    stream = duplexify.obj()
    socket.onopen = onopen
  }

  stream.socket = socket

  socket.onclose = onclose
  socket.onerror = onerror
  socket.onmessage = onmessage

  proxy.on('close', destroy)

  var coerceToBuffer = !options.objectMode

  function socketWriteNode(chunk, enc, next) {
    // avoid errors, this never happens unless
    // destroy() is called
    if (socket.readyState !== socket.OPEN) {
      next()
      return
    }

    if (coerceToBuffer && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, 'utf8')
    }
    socket.send(chunk, next)
  }

  function socketWriteBrowser(chunk, enc, next) {
    if (socket.bufferedAmount > bufferSize) {
      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)
      return
    }

    if (coerceToBuffer && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, 'utf8')
    }

    try {
      socket.send(chunk)
    } catch(err) {
      return next(err)
    }

    next()
  }

  function socketEnd(done) {
    socket.close()
    done()
  }

  function onopen() {
    stream.setReadable(proxy)
    stream.setWritable(proxy)
    stream.emit('connect')
  }

  function onclose() {
    stream.end()
    stream.destroy()
  }

  function onerror(err) {
    stream.destroy(err)
  }

  function onmessage(event) {
    var data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(data)
    else data = Buffer.from(data, 'utf8')
    proxy.push(data)
  }

  function destroy() {
    socket.close()
  }

  // this is to be enabled only if objectMode is false
  function writev (chunks, cb) {
    var buffers = new Array(chunks.length)
    for (var i = 0; i < chunks.length; i++) {
      if (typeof chunks[i].chunk === 'string') {
        buffers[i] = Buffer.from(chunks[i], 'utf8')
      } else {
        buffers[i] = chunks[i].chunk
      }
    }

    this._write(Buffer.concat(buffers), 'binary', cb)
  }

  return stream
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":92,"duplexify":17,"readable-stream":108,"safe-buffer":110,"ws":119}],119:[function(require,module,exports){

var ws = null

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket
}

module.exports = ws

},{}],120:[function(require,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],121:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}]},{},[9])(9)
});
=======
"use strict";
var mqtt = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/esbuild-plugin-polyfill-node/polyfills/navigator.js
  var navigator;
  var init_navigator = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/navigator.js"() {
      navigator = {
        deviceMemory: 8,
        // Highest allowed value
        hardwareConcurrency: 8,
        // Fairly common default
        language: "en-US"
        // Most common default
      };
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/process.js
  var process_exports = {};
  __export(process_exports, {
    _debugEnd: () => _debugEnd,
    _debugProcess: () => _debugProcess,
    _events: () => _events,
    _eventsCount: () => _eventsCount,
    _exiting: () => _exiting,
    _fatalExceptions: () => _fatalExceptions,
    _getActiveHandles: () => _getActiveHandles,
    _getActiveRequests: () => _getActiveRequests,
    _kill: () => _kill,
    _linkedBinding: () => _linkedBinding,
    _maxListeners: () => _maxListeners,
    _preload_modules: () => _preload_modules,
    _rawDebug: () => _rawDebug,
    _startProfilerIdleNotifier: () => _startProfilerIdleNotifier,
    _stopProfilerIdleNotifier: () => _stopProfilerIdleNotifier,
    _tickCallback: () => _tickCallback,
    abort: () => abort,
    addListener: () => addListener,
    allowedNodeEnvironmentFlags: () => allowedNodeEnvironmentFlags,
    arch: () => arch,
    argv: () => argv,
    argv0: () => argv0,
    assert: () => assert,
    binding: () => binding,
    chdir: () => chdir,
    config: () => config,
    cpuUsage: () => cpuUsage,
    cwd: () => cwd,
    debugPort: () => debugPort,
    default: () => process,
    dlopen: () => dlopen,
    domain: () => domain,
    emit: () => emit,
    emitWarning: () => emitWarning,
    env: () => env,
    execArgv: () => execArgv,
    execPath: () => execPath,
    exit: () => exit,
    features: () => features,
    hasUncaughtExceptionCaptureCallback: () => hasUncaughtExceptionCaptureCallback,
    hrtime: () => hrtime,
    kill: () => kill,
    listeners: () => listeners,
    memoryUsage: () => memoryUsage,
    moduleLoadList: () => moduleLoadList,
    nextTick: () => nextTick,
    off: () => off,
    on: () => on,
    once: () => once,
    openStdin: () => openStdin,
    pid: () => pid,
    platform: () => platform,
    ppid: () => ppid,
    prependListener: () => prependListener,
    prependOnceListener: () => prependOnceListener,
    reallyExit: () => reallyExit,
    release: () => release,
    removeAllListeners: () => removeAllListeners,
    removeListener: () => removeListener,
    resourceUsage: () => resourceUsage,
    setSourceMapsEnabled: () => setSourceMapsEnabled,
    setUncaughtExceptionCaptureCallback: () => setUncaughtExceptionCaptureCallback,
    stderr: () => stderr,
    stdin: () => stdin,
    stdout: () => stdout,
    title: () => title,
    umask: () => umask,
    uptime: () => uptime,
    version: () => version,
    versions: () => versions
  });
  function unimplemented(name2) {
    throw new Error("Node.js process " + name2 + " is not supported by JSPM core outside of Node.js");
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue)
      return;
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length)
      drainQueue();
  }
  function drainQueue() {
    if (draining)
      return;
    var timeout = setTimeout(cleanUpNextTick, 0);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue)
          currentQueue[queueIndex].run();
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i6 = 1; i6 < arguments.length; i6++)
        args[i6 - 1] = arguments[i6];
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining)
      setTimeout(drainQueue, 0);
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  function _linkedBinding(name2) {
    unimplemented("_linkedBinding");
  }
  function dlopen(name2) {
    unimplemented("dlopen");
  }
  function _getActiveRequests() {
    return [];
  }
  function _getActiveHandles() {
    return [];
  }
  function assert(condition, message) {
    if (!condition)
      throw new Error(message || "assertion error");
  }
  function hasUncaughtExceptionCaptureCallback() {
    return false;
  }
  function uptime() {
    return _performance.now() / 1e3;
  }
  function hrtime(previousTimestamp) {
    var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
    var clocktime = _performance.now() * 1e-3;
    var seconds = Math.floor(clocktime) + baseNow;
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += nanoPerSec;
      }
    }
    return [seconds, nanoseconds];
  }
  function on() {
    return process;
  }
  function listeners(name2) {
    return [];
  }
  var queue, draining, currentQueue, queueIndex, title, arch, platform, env, argv, execArgv, version, versions, emitWarning, binding, umask, cwd, chdir, release, _rawDebug, moduleLoadList, domain, _exiting, config, reallyExit, _kill, cpuUsage, resourceUsage, memoryUsage, kill, exit, openStdin, allowedNodeEnvironmentFlags, features, _fatalExceptions, setUncaughtExceptionCaptureCallback, _tickCallback, _debugProcess, _debugEnd, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, stdout, stderr, stdin, abort, pid, ppid, execPath, debugPort, argv0, _preload_modules, setSourceMapsEnabled, _performance, nowOffset, nanoPerSec, _maxListeners, _events, _eventsCount, addListener, once, off, removeListener, removeAllListeners, emit, prependListener, prependOnceListener, process;
  var init_process = __esm({
    "node_modules/@jspm/core/nodelibs/browser/process.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      queue = [];
      draining = false;
      queueIndex = -1;
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      arch = "x64";
      platform = "browser";
      env = {
        PATH: "/usr/bin",
        LANG: navigator.language + ".UTF-8",
        PWD: "/",
        HOME: "/home",
        TMP: "/tmp"
      };
      argv = ["/usr/bin/node"];
      execArgv = [];
      version = "v16.8.0";
      versions = {};
      emitWarning = function(message, type) {
        console.warn((type ? type + ": " : "") + message);
      };
      binding = function(name2) {
        unimplemented("binding");
      };
      umask = function(mask) {
        return 0;
      };
      cwd = function() {
        return "/";
      };
      chdir = function(dir) {
      };
      release = {
        name: "node",
        sourceUrl: "",
        headersUrl: "",
        libUrl: ""
      };
      _rawDebug = noop;
      moduleLoadList = [];
      domain = {};
      _exiting = false;
      config = {};
      reallyExit = noop;
      _kill = noop;
      cpuUsage = function() {
        return {};
      };
      resourceUsage = cpuUsage;
      memoryUsage = cpuUsage;
      kill = noop;
      exit = noop;
      openStdin = noop;
      allowedNodeEnvironmentFlags = {};
      features = {
        inspector: false,
        debug: false,
        uv: false,
        ipv6: false,
        tls_alpn: false,
        tls_sni: false,
        tls_ocsp: false,
        tls: false,
        cached_builtins: true
      };
      _fatalExceptions = noop;
      setUncaughtExceptionCaptureCallback = noop;
      _tickCallback = noop;
      _debugProcess = noop;
      _debugEnd = noop;
      _startProfilerIdleNotifier = noop;
      _stopProfilerIdleNotifier = noop;
      stdout = void 0;
      stderr = void 0;
      stdin = void 0;
      abort = noop;
      pid = 2;
      ppid = 1;
      execPath = "/bin/usr/node";
      debugPort = 9229;
      argv0 = "node";
      _preload_modules = [];
      setSourceMapsEnabled = noop;
      _performance = {
        now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
        timing: typeof performance !== "undefined" ? performance.timing : void 0
      };
      if (_performance.now === void 0) {
        nowOffset = Date.now();
        if (_performance.timing && _performance.timing.navigationStart) {
          nowOffset = _performance.timing.navigationStart;
        }
        _performance.now = () => Date.now() - nowOffset;
      }
      nanoPerSec = 1e9;
      hrtime.bigint = function(time) {
        var diff = hrtime(time);
        if (typeof BigInt === "undefined") {
          return diff[0] * nanoPerSec + diff[1];
        }
        return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
      };
      _maxListeners = 10;
      _events = {};
      _eventsCount = 0;
      addListener = on;
      once = on;
      off = on;
      removeListener = on;
      removeAllListeners = on;
      emit = noop;
      prependListener = on;
      prependOnceListener = on;
      process = {
        version,
        versions,
        arch,
        platform,
        release,
        _rawDebug,
        moduleLoadList,
        binding,
        _linkedBinding,
        _events,
        _eventsCount,
        _maxListeners,
        on,
        addListener,
        once,
        off,
        removeListener,
        removeAllListeners,
        emit,
        prependListener,
        prependOnceListener,
        listeners,
        domain,
        _exiting,
        config,
        dlopen,
        uptime,
        _getActiveRequests,
        _getActiveHandles,
        reallyExit,
        _kill,
        cpuUsage,
        resourceUsage,
        memoryUsage,
        kill,
        exit,
        openStdin,
        allowedNodeEnvironmentFlags,
        assert,
        features,
        _fatalExceptions,
        setUncaughtExceptionCaptureCallback,
        hasUncaughtExceptionCaptureCallback,
        emitWarning,
        nextTick,
        _tickCallback,
        _debugProcess,
        _debugEnd,
        _startProfilerIdleNotifier,
        _stopProfilerIdleNotifier,
        stdout,
        stdin,
        stderr,
        abort,
        umask,
        chdir,
        cwd,
        env,
        title,
        argv,
        execArgv,
        pid,
        ppid,
        execPath,
        debugPort,
        hrtime,
        argv0,
        _preload_modules,
        setSourceMapsEnabled
      };
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/process.js
  var init_process2 = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/process.js"() {
      init_process();
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/buffer.js
  var buffer_exports = {};
  __export(buffer_exports, {
    Buffer: () => Buffer2,
    INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
    default: () => exports,
    kMaxLength: () => kMaxLength
  });
  function dew$2() {
    if (_dewExec$2)
      return exports$3;
    _dewExec$2 = true;
    exports$3.byteLength = byteLength;
    exports$3.toByteArray = toByteArray;
    exports$3.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i6 = 0, len = code.length; i6 < len; ++i6) {
      lookup[i6] = code[i6];
      revLookup[code.charCodeAt(i6)] = i6;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i7;
      for (i7 = 0; i7 < len2; i7 += 4) {
        tmp = revLookup[b64.charCodeAt(i7)] << 18 | revLookup[b64.charCodeAt(i7 + 1)] << 12 | revLookup[b64.charCodeAt(i7 + 2)] << 6 | revLookup[b64.charCodeAt(i7 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i7)] << 2 | revLookup[b64.charCodeAt(i7 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i7)] << 10 | revLookup[b64.charCodeAt(i7 + 1)] << 4 | revLookup[b64.charCodeAt(i7 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i7 = start; i7 < end; i7 += 3) {
        tmp = (uint8[i7] << 16 & 16711680) + (uint8[i7 + 1] << 8 & 65280) + (uint8[i7 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i7 = 0, len22 = len2 - extraBytes; i7 < len22; i7 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i7, i7 + maxChunkLength > len22 ? len22 : i7 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    return exports$3;
  }
  function dew$1() {
    if (_dewExec$1)
      return exports$2;
    _dewExec$1 = true;
    exports$2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e7, m4;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i6 = isLE ? nBytes - 1 : 0;
      var d4 = isLE ? -1 : 1;
      var s5 = buffer[offset + i6];
      i6 += d4;
      e7 = s5 & (1 << -nBits) - 1;
      s5 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e7 = e7 * 256 + buffer[offset + i6], i6 += d4, nBits -= 8) {
      }
      m4 = e7 & (1 << -nBits) - 1;
      e7 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m4 = m4 * 256 + buffer[offset + i6], i6 += d4, nBits -= 8) {
      }
      if (e7 === 0) {
        e7 = 1 - eBias;
      } else if (e7 === eMax) {
        return m4 ? NaN : (s5 ? -1 : 1) * Infinity;
      } else {
        m4 = m4 + Math.pow(2, mLen);
        e7 = e7 - eBias;
      }
      return (s5 ? -1 : 1) * m4 * Math.pow(2, e7 - mLen);
    };
    exports$2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e7, m4, c6;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i6 = isLE ? 0 : nBytes - 1;
      var d4 = isLE ? 1 : -1;
      var s5 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m4 = isNaN(value) ? 1 : 0;
        e7 = eMax;
      } else {
        e7 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c6 = Math.pow(2, -e7)) < 1) {
          e7--;
          c6 *= 2;
        }
        if (e7 + eBias >= 1) {
          value += rt / c6;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c6 >= 2) {
          e7++;
          c6 /= 2;
        }
        if (e7 + eBias >= eMax) {
          m4 = 0;
          e7 = eMax;
        } else if (e7 + eBias >= 1) {
          m4 = (value * c6 - 1) * Math.pow(2, mLen);
          e7 = e7 + eBias;
        } else {
          m4 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e7 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i6] = m4 & 255, i6 += d4, m4 /= 256, mLen -= 8) {
      }
      e7 = e7 << mLen | m4;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i6] = e7 & 255, i6 += d4, e7 /= 256, eLen -= 8) {
      }
      buffer[offset + i6 - d4] |= s5 * 128;
    };
    return exports$2;
  }
  function dew() {
    if (_dewExec)
      return exports$1;
    _dewExec = true;
    const base64 = dew$2();
    const ieee754 = dew$1();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports$1.Buffer = Buffer3;
    exports$1.SlowBuffer = SlowBuffer;
    exports$1.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports$1.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e7) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b3 = fromObject(value);
      if (b3)
        return b3;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i6 = 0; i6 < length; i6 += 1) {
        buf[i6] = array[i6] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b3) {
      return b3 != null && b3._isBuffer === true && b3 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a6, b3) {
      if (isInstance(a6, Uint8Array))
        a6 = Buffer3.from(a6, a6.offset, a6.byteLength);
      if (isInstance(b3, Uint8Array))
        b3 = Buffer3.from(b3, b3.offset, b3.byteLength);
      if (!Buffer3.isBuffer(a6) || !Buffer3.isBuffer(b3)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a6 === b3)
        return 0;
      let x2 = a6.length;
      let y4 = b3.length;
      for (let i6 = 0, len = Math.min(x2, y4); i6 < len; ++i6) {
        if (a6[i6] !== b3[i6]) {
          x2 = a6[i6];
          y4 = b3[i6];
          break;
        }
      }
      if (x2 < y4)
        return -1;
      if (y4 < x2)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i6;
      if (length === void 0) {
        length = 0;
        for (i6 = 0; i6 < list.length; ++i6) {
          length += list[i6].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i6 = 0; i6 < list.length; ++i6) {
        let buf = list[i6];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b3, n7, m4) {
      const i6 = b3[n7];
      b3[n7] = b3[m4];
      b3[m4] = i6;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i6 = 0; i6 < len; i6 += 2) {
        swap(this, i6, i6 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i6 = 0; i6 < len; i6 += 4) {
        swap(this, i6, i6 + 3);
        swap(this, i6 + 1, i6 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i6 = 0; i6 < len; i6 += 8) {
        swap(this, i6, i6 + 7);
        swap(this, i6 + 1, i6 + 6);
        swap(this, i6 + 2, i6 + 5);
        swap(this, i6 + 3, i6 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b3) {
      if (!Buffer3.isBuffer(b3))
        throw new TypeError("Argument must be a Buffer");
      if (this === b3)
        return true;
      return Buffer3.compare(this, b3) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports$1.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x2 = thisEnd - thisStart;
      let y4 = end - start;
      const len = Math.min(x2, y4);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i6 = 0; i6 < len; ++i6) {
        if (thisCopy[i6] !== targetCopy[i6]) {
          x2 = thisCopy[i6];
          y4 = targetCopy[i6];
          break;
        }
      }
      if (x2 < y4)
        return -1;
      if (y4 < x2)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i7) {
        if (indexSize === 1) {
          return buf[i7];
        } else {
          return buf.readUInt16BE(i7 * indexSize);
        }
      }
      let i6;
      if (dir) {
        let foundIndex = -1;
        for (i6 = byteOffset; i6 < arrLength; i6++) {
          if (read(arr, i6) === read(val, foundIndex === -1 ? 0 : i6 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i6;
            if (i6 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i6 -= i6 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i6 = byteOffset; i6 >= 0; i6--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i6 + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found)
            return i6;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i6;
      for (i6 = 0; i6 < length; ++i6) {
        const parsed = parseInt(string.substr(i6 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i6;
        buf[offset + i6] = parsed;
      }
      return i6;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i6 = start;
      while (i6 < end) {
        const firstByte = buf[i6];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i6 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i6 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i6 + 1];
              thirdByte = buf[i6 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i6 + 1];
              thirdByte = buf[i6 + 2];
              fourthByte = buf[i6 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i6 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i6 = 0;
      while (i6 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i6, i6 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i6 = start; i6 < end; ++i6) {
        ret += String.fromCharCode(buf[i6] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i6 = start; i6 < end; ++i6) {
        ret += String.fromCharCode(buf[i6]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i6 = start; i6 < end; ++i6) {
        out += hexSliceLookupTable[buf[i6]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i6 = 0; i6 < bytes.length - 1; i6 += 2) {
        res += String.fromCharCode(bytes[i6] + bytes[i6 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i6 = 0;
      while (++i6 < byteLength2 && (mul *= 256)) {
        val += this[offset + i6] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i6 = 0;
      while (++i6 < byteLength2 && (mul *= 256)) {
        val += this[offset + i6] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i6 = byteLength2;
      let mul = 1;
      let val = this[offset + --i6];
      while (i6 > 0 && (mul *= 256)) {
        val += this[offset + --i6] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i6 = 0;
      this[offset] = value & 255;
      while (++i6 < byteLength2 && (mul *= 256)) {
        this[offset + i6] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i6 = byteLength2 - 1;
      let mul = 1;
      this[offset + i6] = value & 255;
      while (--i6 >= 0 && (mul *= 256)) {
        this[offset + i6] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i6 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i6 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i6 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i6] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i6 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i6] = value & 255;
      while (--i6 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i6 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i6] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i6;
      if (typeof val === "number") {
        for (i6 = start; i6 < end; ++i6) {
          this[i6] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i6 = 0; i6 < end - start; ++i6) {
          this[i6 + start] = bytes[i6 % len];
        }
      }
      return this;
    };
    const errors = {};
    function E2(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E2("ERR_INVALID_ARG_TYPE", function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E2("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i6 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i6 >= start + 4; i6 -= 3) {
        res = `_${val.slice(i6 - 3, i6)}${res}`;
      }
      return `${val.slice(0, i6)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n7 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n7} and < 2${n7} ** ${(byteLength2 + 1) * 8}${n7}`;
          } else {
            range = `>= -(2${n7} ** ${(byteLength2 + 1) * 8 - 1}${n7}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n7}`;
          }
        } else {
          range = `>= ${min}${n7} and <= ${max}${n7}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i6 = 0; i6 < length; ++i6) {
        codePoint = string.charCodeAt(i6);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i6 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i6 = 0; i6 < str.length; ++i6) {
        byteArray.push(str.charCodeAt(i6) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c6, hi, lo;
      const byteArray = [];
      for (let i6 = 0; i6 < str.length; ++i6) {
        if ((units -= 2) < 0)
          break;
        c6 = str.charCodeAt(i6);
        hi = c6 >> 8;
        lo = c6 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i6;
      for (i6 = 0; i6 < length; ++i6) {
        if (i6 + offset >= dst.length || i6 >= src.length)
          break;
        dst[i6 + offset] = src[i6];
      }
      return i6;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i6 = 0; i6 < 16; ++i6) {
        const i16 = i6 * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i6] + alphabet[j2];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    return exports$1;
  }
  var exports$3, _dewExec$2, exports$2, _dewExec$1, exports$1, _dewExec, exports, Buffer2, INSPECT_MAX_BYTES, kMaxLength;
  var init_buffer = __esm({
    "node_modules/@jspm/core/nodelibs/browser/buffer.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      exports$3 = {};
      _dewExec$2 = false;
      exports$2 = {};
      _dewExec$1 = false;
      exports$1 = {};
      _dewExec = false;
      exports = dew();
      exports["Buffer"];
      exports["SlowBuffer"];
      exports["INSPECT_MAX_BYTES"];
      exports["kMaxLength"];
      Buffer2 = exports.Buffer;
      INSPECT_MAX_BYTES = exports.INSPECT_MAX_BYTES;
      kMaxLength = exports.kMaxLength;
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
  var init_buffer2 = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
      init_buffer();
    }
  });

  // build/lib/topic-alias-recv.js
  var require_topic_alias_recv = __commonJS({
    "build/lib/topic-alias-recv.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      var TopicAliasRecv = class {
        constructor(max) {
          this.aliasToTopic = {};
          this.max = max;
        }
        put(topic, alias) {
          if (alias === 0 || alias > this.max) {
            return false;
          }
          this.aliasToTopic[alias] = topic;
          this.length = Object.keys(this.aliasToTopic).length;
          return true;
        }
        getTopicByAlias(alias) {
          return this.aliasToTopic[alias];
        }
        clear() {
          this.aliasToTopic = {};
        }
      };
      exports5.default = TopicAliasRecv;
    }
  });

  // node_modules/readable-stream/lib/ours/primordials.js
  var require_primordials = __commonJS({
    "node_modules/readable-stream/lib/ours/primordials.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      module.exports = {
        ArrayIsArray(self2) {
          return Array.isArray(self2);
        },
        ArrayPrototypeIncludes(self2, el) {
          return self2.includes(el);
        },
        ArrayPrototypeIndexOf(self2, el) {
          return self2.indexOf(el);
        },
        ArrayPrototypeJoin(self2, sep) {
          return self2.join(sep);
        },
        ArrayPrototypeMap(self2, fn) {
          return self2.map(fn);
        },
        ArrayPrototypePop(self2, el) {
          return self2.pop(el);
        },
        ArrayPrototypePush(self2, el) {
          return self2.push(el);
        },
        ArrayPrototypeSlice(self2, start, end) {
          return self2.slice(start, end);
        },
        Error,
        FunctionPrototypeCall(fn, thisArgs, ...args) {
          return fn.call(thisArgs, ...args);
        },
        FunctionPrototypeSymbolHasInstance(self2, instance) {
          return Function.prototype[Symbol.hasInstance].call(self2, instance);
        },
        MathFloor: Math.floor,
        Number,
        NumberIsInteger: Number.isInteger,
        NumberIsNaN: Number.isNaN,
        NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
        NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
        NumberParseInt: Number.parseInt,
        ObjectDefineProperties(self2, props) {
          return Object.defineProperties(self2, props);
        },
        ObjectDefineProperty(self2, name2, prop) {
          return Object.defineProperty(self2, name2, prop);
        },
        ObjectGetOwnPropertyDescriptor(self2, name2) {
          return Object.getOwnPropertyDescriptor(self2, name2);
        },
        ObjectKeys(obj) {
          return Object.keys(obj);
        },
        ObjectSetPrototypeOf(target, proto) {
          return Object.setPrototypeOf(target, proto);
        },
        Promise,
        PromisePrototypeCatch(self2, fn) {
          return self2.catch(fn);
        },
        PromisePrototypeThen(self2, thenFn, catchFn) {
          return self2.then(thenFn, catchFn);
        },
        PromiseReject(err) {
          return Promise.reject(err);
        },
        ReflectApply: Reflect.apply,
        RegExpPrototypeTest(self2, value) {
          return self2.test(value);
        },
        SafeSet: Set,
        String,
        StringPrototypeSlice(self2, start, end) {
          return self2.slice(start, end);
        },
        StringPrototypeToLowerCase(self2) {
          return self2.toLowerCase();
        },
        StringPrototypeToUpperCase(self2) {
          return self2.toUpperCase();
        },
        StringPrototypeTrim(self2) {
          return self2.trim();
        },
        Symbol,
        SymbolFor: Symbol.for,
        SymbolAsyncIterator: Symbol.asyncIterator,
        SymbolHasInstance: Symbol.hasInstance,
        SymbolIterator: Symbol.iterator,
        TypedArrayPrototypeSet(self2, buf, len) {
          return self2.set(buf, len);
        },
        Uint8Array
      };
    }
  });

  // node_modules/readable-stream/lib/ours/util.js
  var require_util = __commonJS({
    "node_modules/readable-stream/lib/ours/util.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var bufferModule = (init_buffer(), __toCommonJS(buffer_exports));
      var AsyncFunction = Object.getPrototypeOf(async function() {
      }).constructor;
      var Blob2 = globalThis.Blob || bufferModule.Blob;
      var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b3) {
        return b3 instanceof Blob2;
      } : function isBlob2(b3) {
        return false;
      };
      var AggregateError = class extends Error {
        constructor(errors) {
          if (!Array.isArray(errors)) {
            throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
          }
          let message = "";
          for (let i6 = 0; i6 < errors.length; i6++) {
            message += `    ${errors[i6].stack}
`;
          }
          super(message);
          this.name = "AggregateError";
          this.errors = errors;
        }
      };
      module.exports = {
        AggregateError,
        kEmptyObject: Object.freeze({}),
        once(callback) {
          let called = false;
          return function(...args) {
            if (called) {
              return;
            }
            called = true;
            callback.apply(this, args);
          };
        },
        createDeferredPromise: function() {
          let resolve2;
          let reject;
          const promise = new Promise((res, rej) => {
            resolve2 = res;
            reject = rej;
          });
          return {
            promise,
            resolve: resolve2,
            reject
          };
        },
        promisify(fn) {
          return new Promise((resolve2, reject) => {
            fn((err, ...args) => {
              if (err) {
                return reject(err);
              }
              return resolve2(...args);
            });
          });
        },
        debuglog() {
          return function() {
          };
        },
        format(format2, ...args) {
          return format2.replace(/%([sdifj])/g, function(...[_unused, type]) {
            const replacement = args.shift();
            if (type === "f") {
              return replacement.toFixed(6);
            } else if (type === "j") {
              return JSON.stringify(replacement);
            } else if (type === "s" && typeof replacement === "object") {
              const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
              return `${ctor} {}`.trim();
            } else {
              return replacement.toString();
            }
          });
        },
        inspect(value) {
          switch (typeof value) {
            case "string":
              if (value.includes("'")) {
                if (!value.includes('"')) {
                  return `"${value}"`;
                } else if (!value.includes("`") && !value.includes("${")) {
                  return `\`${value}\``;
                }
              }
              return `'${value}'`;
            case "number":
              if (isNaN(value)) {
                return "NaN";
              } else if (Object.is(value, -0)) {
                return String(value);
              }
              return value;
            case "bigint":
              return `${String(value)}n`;
            case "boolean":
            case "undefined":
              return String(value);
            case "object":
              return "{}";
          }
        },
        types: {
          isAsyncFunction(fn) {
            return fn instanceof AsyncFunction;
          },
          isArrayBufferView(arr) {
            return ArrayBuffer.isView(arr);
          }
        },
        isBlob
      };
      module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
    }
  });

  // node_modules/abort-controller/browser.js
  var require_browser = __commonJS({
    "node_modules/abort-controller/browser.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { AbortController, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
        /* otherwise */
        void 0
      );
      module.exports = AbortController;
      module.exports.AbortSignal = AbortSignal;
      module.exports.default = AbortController;
    }
  });

  // node_modules/readable-stream/lib/ours/errors.js
  var require_errors = __commonJS({
    "node_modules/readable-stream/lib/ours/errors.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { format: format2, inspect, AggregateError: CustomAggregateError } = require_util();
      var AggregateError = globalThis.AggregateError || CustomAggregateError;
      var kIsNodeError = Symbol("kIsNodeError");
      var kTypes = [
        "string",
        "function",
        "number",
        "object",
        // Accept 'Function' and 'Object' as alternative to the lower cased version.
        "Function",
        "Object",
        "boolean",
        "bigint",
        "symbol"
      ];
      var classRegExp = /^([A-Z][a-z0-9]*)+$/;
      var nodeInternalPrefix = "__node_internal_";
      var codes = {};
      function assert2(value, message) {
        if (!value) {
          throw new codes.ERR_INTERNAL_ASSERTION(message);
        }
      }
      function addNumericalSeparator(val) {
        let res = "";
        let i6 = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i6 >= start + 4; i6 -= 3) {
          res = `_${val.slice(i6 - 3, i6)}${res}`;
        }
        return `${val.slice(0, i6)}${res}`;
      }
      function getMessage(key, msg, args) {
        if (typeof msg === "function") {
          assert2(
            msg.length <= args.length,
            // Default options do not count.
            `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
          );
          return msg(...args);
        }
        const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
        assert2(
          expectedLength === args.length,
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
        );
        if (args.length === 0) {
          return msg;
        }
        return format2(msg, ...args);
      }
      function E2(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        class NodeError extends Base {
          constructor(...args) {
            super(getMessage(code, message, args));
          }
          toString() {
            return `${this.name} [${code}]: ${this.message}`;
          }
        }
        Object.defineProperties(NodeError.prototype, {
          name: {
            value: Base.name,
            writable: true,
            enumerable: false,
            configurable: true
          },
          toString: {
            value() {
              return `${this.name} [${code}]: ${this.message}`;
            },
            writable: true,
            enumerable: false,
            configurable: true
          }
        });
        NodeError.prototype.code = code;
        NodeError.prototype[kIsNodeError] = true;
        codes[code] = NodeError;
      }
      function hideStackFrames(fn) {
        const hidden = nodeInternalPrefix + fn.name;
        Object.defineProperty(fn, "name", {
          value: hidden
        });
        return fn;
      }
      function aggregateTwoErrors(innerError, outerError) {
        if (innerError && outerError && innerError !== outerError) {
          if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
          }
          const err = new AggregateError([outerError, innerError], outerError.message);
          err.code = outerError.code;
          return err;
        }
        return innerError || outerError;
      }
      var AbortError = class extends Error {
        constructor(message = "The operation was aborted", options = void 0) {
          if (options !== void 0 && typeof options !== "object") {
            throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
          }
          super(message, options);
          this.code = "ABORT_ERR";
          this.name = "AbortError";
        }
      };
      E2("ERR_ASSERTION", "%s", Error);
      E2(
        "ERR_INVALID_ARG_TYPE",
        (name2, expected, actual) => {
          assert2(typeof name2 === "string", "'name' must be a string");
          if (!Array.isArray(expected)) {
            expected = [expected];
          }
          let msg = "The ";
          if (name2.endsWith(" argument")) {
            msg += `${name2} `;
          } else {
            msg += `"${name2}" ${name2.includes(".") ? "property" : "argument"} `;
          }
          msg += "must be ";
          const types = [];
          const instances = [];
          const other = [];
          for (const value of expected) {
            assert2(typeof value === "string", "All expected entries have to be of type string");
            if (kTypes.includes(value)) {
              types.push(value.toLowerCase());
            } else if (classRegExp.test(value)) {
              instances.push(value);
            } else {
              assert2(value !== "object", 'The value "object" should be written as "Object"');
              other.push(value);
            }
          }
          if (instances.length > 0) {
            const pos = types.indexOf("object");
            if (pos !== -1) {
              types.splice(types, pos, 1);
              instances.push("Object");
            }
          }
          if (types.length > 0) {
            switch (types.length) {
              case 1:
                msg += `of type ${types[0]}`;
                break;
              case 2:
                msg += `one of type ${types[0]} or ${types[1]}`;
                break;
              default: {
                const last = types.pop();
                msg += `one of type ${types.join(", ")}, or ${last}`;
              }
            }
            if (instances.length > 0 || other.length > 0) {
              msg += " or ";
            }
          }
          if (instances.length > 0) {
            switch (instances.length) {
              case 1:
                msg += `an instance of ${instances[0]}`;
                break;
              case 2:
                msg += `an instance of ${instances[0]} or ${instances[1]}`;
                break;
              default: {
                const last = instances.pop();
                msg += `an instance of ${instances.join(", ")}, or ${last}`;
              }
            }
            if (other.length > 0) {
              msg += " or ";
            }
          }
          switch (other.length) {
            case 0:
              break;
            case 1:
              if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
              }
              msg += `${other[0]}`;
              break;
            case 2:
              msg += `one of ${other[0]} or ${other[1]}`;
              break;
            default: {
              const last = other.pop();
              msg += `one of ${other.join(", ")}, or ${last}`;
            }
          }
          if (actual == null) {
            msg += `. Received ${actual}`;
          } else if (typeof actual === "function" && actual.name) {
            msg += `. Received function ${actual.name}`;
          } else if (typeof actual === "object") {
            var _actual$constructor;
            if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
              msg += `. Received an instance of ${actual.constructor.name}`;
            } else {
              const inspected = inspect(actual, {
                depth: -1
              });
              msg += `. Received ${inspected}`;
            }
          } else {
            let inspected = inspect(actual, {
              colors: false
            });
            if (inspected.length > 25) {
              inspected = `${inspected.slice(0, 25)}...`;
            }
            msg += `. Received type ${typeof actual} (${inspected})`;
          }
          return msg;
        },
        TypeError
      );
      E2(
        "ERR_INVALID_ARG_VALUE",
        (name2, value, reason = "is invalid") => {
          let inspected = inspect(value);
          if (inspected.length > 128) {
            inspected = inspected.slice(0, 128) + "...";
          }
          const type = name2.includes(".") ? "property" : "argument";
          return `The ${type} '${name2}' ${reason}. Received ${inspected}`;
        },
        TypeError
      );
      E2(
        "ERR_INVALID_RETURN_VALUE",
        (input, name2, value) => {
          var _value$constructor;
          const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
          return `Expected ${input} to be returned from the "${name2}" function but got ${type}.`;
        },
        TypeError
      );
      E2(
        "ERR_MISSING_ARGS",
        (...args) => {
          assert2(args.length > 0, "At least one arg needs to be specified");
          let msg;
          const len = args.length;
          args = (Array.isArray(args) ? args : [args]).map((a6) => `"${a6}"`).join(" or ");
          switch (len) {
            case 1:
              msg += `The ${args[0]} argument`;
              break;
            case 2:
              msg += `The ${args[0]} and ${args[1]} arguments`;
              break;
            default:
              {
                const last = args.pop();
                msg += `The ${args.join(", ")}, and ${last} arguments`;
              }
              break;
          }
          return `${msg} must be specified`;
        },
        TypeError
      );
      E2(
        "ERR_OUT_OF_RANGE",
        (str, range, input) => {
          assert2(range, 'Missing "range" argument');
          let received;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          } else {
            received = inspect(input);
          }
          return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
        },
        RangeError
      );
      E2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
      E2("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
      E2("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
      E2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
      E2("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
      E2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      E2("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
      E2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
      E2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
      E2("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
      E2("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
      module.exports = {
        AbortError,
        aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
        hideStackFrames,
        codes
      };
    }
  });

  // node_modules/readable-stream/lib/internal/validators.js
  var require_validators = __commonJS({
    "node_modules/readable-stream/lib/internal/validators.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var {
        ArrayIsArray,
        ArrayPrototypeIncludes,
        ArrayPrototypeJoin,
        ArrayPrototypeMap,
        NumberIsInteger,
        NumberIsNaN,
        NumberMAX_SAFE_INTEGER,
        NumberMIN_SAFE_INTEGER,
        NumberParseInt,
        ObjectPrototypeHasOwnProperty,
        RegExpPrototypeExec,
        String: String2,
        StringPrototypeToUpperCase,
        StringPrototypeTrim
      } = require_primordials();
      var {
        hideStackFrames,
        codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
      } = require_errors();
      var { normalizeEncoding } = require_util();
      var { isAsyncFunction, isArrayBufferView } = require_util().types;
      var signals = {};
      function isInt32(value) {
        return value === (value | 0);
      }
      function isUint32(value) {
        return value === value >>> 0;
      }
      var octalReg = /^[0-7]+$/;
      var modeDesc = "must be a 32-bit unsigned integer or an octal string";
      function parseFileMode(value, name2, def) {
        if (typeof value === "undefined") {
          value = def;
        }
        if (typeof value === "string") {
          if (RegExpPrototypeExec(octalReg, value) === null) {
            throw new ERR_INVALID_ARG_VALUE(name2, value, modeDesc);
          }
          value = NumberParseInt(value, 8);
        }
        validateUint32(value, name2);
        return value;
      }
      var validateInteger = hideStackFrames((value, name2, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
        if (typeof value !== "number")
          throw new ERR_INVALID_ARG_TYPE(name2, "number", value);
        if (!NumberIsInteger(value))
          throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
        if (value < min || value > max)
          throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
      });
      var validateInt32 = hideStackFrames((value, name2, min = -2147483648, max = 2147483647) => {
        if (typeof value !== "number") {
          throw new ERR_INVALID_ARG_TYPE(name2, "number", value);
        }
        if (!NumberIsInteger(value)) {
          throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
        }
        if (value < min || value > max) {
          throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
        }
      });
      var validateUint32 = hideStackFrames((value, name2, positive = false) => {
        if (typeof value !== "number") {
          throw new ERR_INVALID_ARG_TYPE(name2, "number", value);
        }
        if (!NumberIsInteger(value)) {
          throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
        }
        const min = positive ? 1 : 0;
        const max = 4294967295;
        if (value < min || value > max) {
          throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
        }
      });
      function validateString(value, name2) {
        if (typeof value !== "string")
          throw new ERR_INVALID_ARG_TYPE(name2, "string", value);
      }
      function validateNumber(value, name2, min = void 0, max) {
        if (typeof value !== "number")
          throw new ERR_INVALID_ARG_TYPE(name2, "number", value);
        if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
          throw new ERR_OUT_OF_RANGE(
            name2,
            `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
            value
          );
        }
      }
      var validateOneOf = hideStackFrames((value, name2, oneOf) => {
        if (!ArrayPrototypeIncludes(oneOf, value)) {
          const allowed = ArrayPrototypeJoin(
            ArrayPrototypeMap(oneOf, (v4) => typeof v4 === "string" ? `'${v4}'` : String2(v4)),
            ", "
          );
          const reason = "must be one of: " + allowed;
          throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
        }
      });
      function validateBoolean(value, name2) {
        if (typeof value !== "boolean")
          throw new ERR_INVALID_ARG_TYPE(name2, "boolean", value);
      }
      function getOwnPropertyValueOrDefault(options, key, defaultValue) {
        return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
      }
      var validateObject = hideStackFrames((value, name2, options = null) => {
        const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
        const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
        const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
        if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
          throw new ERR_INVALID_ARG_TYPE(name2, "Object", value);
        }
      });
      var validateDictionary = hideStackFrames((value, name2) => {
        if (value != null && typeof value !== "object" && typeof value !== "function") {
          throw new ERR_INVALID_ARG_TYPE(name2, "a dictionary", value);
        }
      });
      var validateArray = hideStackFrames((value, name2, minLength = 0) => {
        if (!ArrayIsArray(value)) {
          throw new ERR_INVALID_ARG_TYPE(name2, "Array", value);
        }
        if (value.length < minLength) {
          const reason = `must be longer than ${minLength}`;
          throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
        }
      });
      function validateStringArray(value, name2) {
        validateArray(value, name2);
        for (let i6 = 0; i6 < value.length; i6++) {
          validateString(value[i6], `${name2}[${i6}]`);
        }
      }
      function validateBooleanArray(value, name2) {
        validateArray(value, name2);
        for (let i6 = 0; i6 < value.length; i6++) {
          validateBoolean(value[i6], `${name2}[${i6}]`);
        }
      }
      function validateSignalName(signal, name2 = "signal") {
        validateString(signal, name2);
        if (signals[signal] === void 0) {
          if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
            throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
          }
          throw new ERR_UNKNOWN_SIGNAL(signal);
        }
      }
      var validateBuffer = hideStackFrames((buffer, name2 = "buffer") => {
        if (!isArrayBufferView(buffer)) {
          throw new ERR_INVALID_ARG_TYPE(name2, ["Buffer", "TypedArray", "DataView"], buffer);
        }
      });
      function validateEncoding(data, encoding) {
        const normalizedEncoding = normalizeEncoding(encoding);
        const length = data.length;
        if (normalizedEncoding === "hex" && length % 2 !== 0) {
          throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
        }
      }
      function validatePort(port, name2 = "Port", allowZero = true) {
        if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
          throw new ERR_SOCKET_BAD_PORT(name2, port, allowZero);
        }
        return port | 0;
      }
      var validateAbortSignal = hideStackFrames((signal, name2) => {
        if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
          throw new ERR_INVALID_ARG_TYPE(name2, "AbortSignal", signal);
        }
      });
      var validateFunction = hideStackFrames((value, name2) => {
        if (typeof value !== "function")
          throw new ERR_INVALID_ARG_TYPE(name2, "Function", value);
      });
      var validatePlainFunction = hideStackFrames((value, name2) => {
        if (typeof value !== "function" || isAsyncFunction(value))
          throw new ERR_INVALID_ARG_TYPE(name2, "Function", value);
      });
      var validateUndefined = hideStackFrames((value, name2) => {
        if (value !== void 0)
          throw new ERR_INVALID_ARG_TYPE(name2, "undefined", value);
      });
      function validateUnion(value, name2, union) {
        if (!ArrayPrototypeIncludes(union, value)) {
          throw new ERR_INVALID_ARG_TYPE(name2, `('${ArrayPrototypeJoin(union, "|")}')`, value);
        }
      }
      var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
      function validateLinkHeaderFormat(value, name2) {
        if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
          throw new ERR_INVALID_ARG_VALUE(
            name2,
            value,
            'must be an array or string of format "</styles.css>; rel=preload; as=style"'
          );
        }
      }
      function validateLinkHeaderValue(hints) {
        if (typeof hints === "string") {
          validateLinkHeaderFormat(hints, "hints");
          return hints;
        } else if (ArrayIsArray(hints)) {
          const hintsLength = hints.length;
          let result = "";
          if (hintsLength === 0) {
            return result;
          }
          for (let i6 = 0; i6 < hintsLength; i6++) {
            const link = hints[i6];
            validateLinkHeaderFormat(link, "hints");
            result += link;
            if (i6 !== hintsLength - 1) {
              result += ", ";
            }
          }
          return result;
        }
        throw new ERR_INVALID_ARG_VALUE(
          "hints",
          hints,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
      module.exports = {
        isInt32,
        isUint32,
        parseFileMode,
        validateArray,
        validateStringArray,
        validateBooleanArray,
        validateBoolean,
        validateBuffer,
        validateDictionary,
        validateEncoding,
        validateFunction,
        validateInt32,
        validateInteger,
        validateNumber,
        validateObject,
        validateOneOf,
        validatePlainFunction,
        validatePort,
        validateSignalName,
        validateString,
        validateUint32,
        validateUndefined,
        validateUnion,
        validateAbortSignal,
        validateLinkHeaderValue
      };
    }
  });

  // node_modules/process/browser.js
  var require_browser2 = __commonJS({
    "node_modules/process/browser.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var process3 = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e7) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e7) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e7) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e8) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e7) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e8) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue2 = [];
      var draining2 = false;
      var currentQueue2;
      var queueIndex2 = -1;
      function cleanUpNextTick2() {
        if (!draining2 || !currentQueue2) {
          return;
        }
        draining2 = false;
        if (currentQueue2.length) {
          queue2 = currentQueue2.concat(queue2);
        } else {
          queueIndex2 = -1;
        }
        if (queue2.length) {
          drainQueue2();
        }
      }
      function drainQueue2() {
        if (draining2) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick2);
        draining2 = true;
        var len = queue2.length;
        while (len) {
          currentQueue2 = queue2;
          queue2 = [];
          while (++queueIndex2 < len) {
            if (currentQueue2) {
              currentQueue2[queueIndex2].run();
            }
          }
          queueIndex2 = -1;
          len = queue2.length;
        }
        currentQueue2 = null;
        draining2 = false;
        runClearTimeout(timeout);
      }
      process3.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i6 = 1; i6 < arguments.length; i6++) {
            args[i6 - 1] = arguments[i6];
          }
        }
        queue2.push(new Item2(fun, args));
        if (queue2.length === 1 && !draining2) {
          runTimeout(drainQueue2);
        }
      };
      function Item2(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item2.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process3.title = "browser";
      process3.browser = true;
      process3.env = {};
      process3.argv = [];
      process3.version = "";
      process3.versions = {};
      function noop2() {
      }
      process3.on = noop2;
      process3.addListener = noop2;
      process3.once = noop2;
      process3.off = noop2;
      process3.removeListener = noop2;
      process3.removeAllListeners = noop2;
      process3.emit = noop2;
      process3.prependListener = noop2;
      process3.prependOnceListener = noop2;
      process3.listeners = function(name2) {
        return [];
      };
      process3.binding = function(name2) {
        throw new Error("process.binding is not supported");
      };
      process3.cwd = function() {
        return "/";
      };
      process3.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process3.umask = function() {
        return 0;
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/utils.js
  var require_utils = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/utils.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
      var kDestroyed = Symbol2("kDestroyed");
      var kIsErrored = Symbol2("kIsErrored");
      var kIsReadable = Symbol2("kIsReadable");
      var kIsDisturbed = Symbol2("kIsDisturbed");
      var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
      var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
      function isReadableNodeStream(obj, strict = false) {
        var _obj$_readableState;
        return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
        (!obj._writableState || obj._readableState));
      }
      function isWritableNodeStream(obj) {
        var _obj$_writableState;
        return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
      }
      function isDuplexNodeStream(obj) {
        return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
      }
      function isNodeStream(obj) {
        return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
      }
      function isReadableStream(obj) {
        return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
      }
      function isWritableStream(obj) {
        return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
      }
      function isTransformStream(obj) {
        return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
      }
      function isWebStream(obj) {
        return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
      }
      function isIterable(obj, isAsync) {
        if (obj == null)
          return false;
        if (isAsync === true)
          return typeof obj[SymbolAsyncIterator] === "function";
        if (isAsync === false)
          return typeof obj[SymbolIterator] === "function";
        return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
      }
      function isDestroyed(stream) {
        if (!isNodeStream(stream))
          return null;
        const wState = stream._writableState;
        const rState = stream._readableState;
        const state = wState || rState;
        return !!(stream.destroyed || stream[kDestroyed] || state !== null && state !== void 0 && state.destroyed);
      }
      function isWritableEnded(stream) {
        if (!isWritableNodeStream(stream))
          return null;
        if (stream.writableEnded === true)
          return true;
        const wState = stream._writableState;
        if (wState !== null && wState !== void 0 && wState.errored)
          return false;
        if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
          return null;
        return wState.ended;
      }
      function isWritableFinished(stream, strict) {
        if (!isWritableNodeStream(stream))
          return null;
        if (stream.writableFinished === true)
          return true;
        const wState = stream._writableState;
        if (wState !== null && wState !== void 0 && wState.errored)
          return false;
        if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
          return null;
        return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
      }
      function isReadableEnded(stream) {
        if (!isReadableNodeStream(stream))
          return null;
        if (stream.readableEnded === true)
          return true;
        const rState = stream._readableState;
        if (!rState || rState.errored)
          return false;
        if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
          return null;
        return rState.ended;
      }
      function isReadableFinished(stream, strict) {
        if (!isReadableNodeStream(stream))
          return null;
        const rState = stream._readableState;
        if (rState !== null && rState !== void 0 && rState.errored)
          return false;
        if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
          return null;
        return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
      }
      function isReadable(stream) {
        if (stream && stream[kIsReadable] != null)
          return stream[kIsReadable];
        if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
          return null;
        if (isDestroyed(stream))
          return false;
        return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
      }
      function isWritable(stream) {
        if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
          return null;
        if (isDestroyed(stream))
          return false;
        return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
      }
      function isFinished(stream, opts) {
        if (!isNodeStream(stream)) {
          return null;
        }
        if (isDestroyed(stream)) {
          return true;
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
          return false;
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
          return false;
        }
        return true;
      }
      function isWritableErrored(stream) {
        var _stream$_writableStat, _stream$_writableStat2;
        if (!isNodeStream(stream)) {
          return null;
        }
        if (stream.writableErrored) {
          return stream.writableErrored;
        }
        return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
      }
      function isReadableErrored(stream) {
        var _stream$_readableStat, _stream$_readableStat2;
        if (!isNodeStream(stream)) {
          return null;
        }
        if (stream.readableErrored) {
          return stream.readableErrored;
        }
        return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
      }
      function isClosed(stream) {
        if (!isNodeStream(stream)) {
          return null;
        }
        if (typeof stream.closed === "boolean") {
          return stream.closed;
        }
        const wState = stream._writableState;
        const rState = stream._readableState;
        if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
          return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
        }
        if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
          return stream._closed;
        }
        return null;
      }
      function isOutgoingMessage(stream) {
        return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
      }
      function isServerResponse(stream) {
        return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
      }
      function isServerRequest(stream) {
        var _stream$req;
        return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
      }
      function willEmitClose(stream) {
        if (!isNodeStream(stream))
          return null;
        const wState = stream._writableState;
        const rState = stream._readableState;
        const state = wState || rState;
        return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
      }
      function isDisturbed(stream) {
        var _stream$kIsDisturbed;
        return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
      }
      function isErrored(stream) {
        var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
        return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
      }
      module.exports = {
        kDestroyed,
        isDisturbed,
        kIsDisturbed,
        isErrored,
        kIsErrored,
        isReadable,
        kIsReadable,
        kIsClosedPromise,
        kControllerErrorFunction,
        isClosed,
        isDestroyed,
        isDuplexNodeStream,
        isFinished,
        isIterable,
        isReadableNodeStream,
        isReadableStream,
        isReadableEnded,
        isReadableFinished,
        isReadableErrored,
        isNodeStream,
        isWebStream,
        isWritable,
        isWritableNodeStream,
        isWritableStream,
        isWritableEnded,
        isWritableFinished,
        isWritableErrored,
        isServerRequest,
        isServerResponse,
        willEmitClose,
        isTransformStream
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var process3 = require_browser2();
      var { AbortError, codes } = require_errors();
      var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
      var { kEmptyObject, once: once3 } = require_util();
      var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
      var { Promise: Promise2, PromisePrototypeThen } = require_primordials();
      var {
        isClosed,
        isReadable,
        isReadableNodeStream,
        isReadableStream,
        isReadableFinished,
        isReadableErrored,
        isWritable,
        isWritableNodeStream,
        isWritableStream,
        isWritableFinished,
        isWritableErrored,
        isNodeStream,
        willEmitClose: _willEmitClose,
        kIsClosedPromise
      } = require_utils();
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      var nop = () => {
      };
      function eos(stream, options, callback) {
        var _options$readable, _options$writable;
        if (arguments.length === 2) {
          callback = options;
          options = kEmptyObject;
        } else if (options == null) {
          options = kEmptyObject;
        } else {
          validateObject(options, "options");
        }
        validateFunction(callback, "callback");
        validateAbortSignal(options.signal, "options.signal");
        callback = once3(callback);
        if (isReadableStream(stream) || isWritableStream(stream)) {
          return eosWeb(stream, options, callback);
        }
        if (!isNodeStream(stream)) {
          throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
        }
        const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
        const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
        const wState = stream._writableState;
        const rState = stream._readableState;
        const onlegacyfinish = () => {
          if (!stream.writable) {
            onfinish();
          }
        };
        let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
        let writableFinished = isWritableFinished(stream, false);
        const onfinish = () => {
          writableFinished = true;
          if (stream.destroyed) {
            willEmitClose = false;
          }
          if (willEmitClose && (!stream.readable || readable)) {
            return;
          }
          if (!readable || readableFinished) {
            callback.call(stream);
          }
        };
        let readableFinished = isReadableFinished(stream, false);
        const onend = () => {
          readableFinished = true;
          if (stream.destroyed) {
            willEmitClose = false;
          }
          if (willEmitClose && (!stream.writable || writable)) {
            return;
          }
          if (!writable || writableFinished) {
            callback.call(stream);
          }
        };
        const onerror = (err) => {
          callback.call(stream, err);
        };
        let closed = isClosed(stream);
        const onclose = () => {
          closed = true;
          const errored = isWritableErrored(stream) || isReadableErrored(stream);
          if (errored && typeof errored !== "boolean") {
            return callback.call(stream, errored);
          }
          if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
            if (!isReadableFinished(stream, false))
              return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
          }
          if (writable && !writableFinished) {
            if (!isWritableFinished(stream, false))
              return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
          }
          callback.call(stream);
        };
        const onclosed = () => {
          closed = true;
          const errored = isWritableErrored(stream) || isReadableErrored(stream);
          if (errored && typeof errored !== "boolean") {
            return callback.call(stream, errored);
          }
          callback.call(stream);
        };
        const onrequest = () => {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          if (!willEmitClose) {
            stream.on("abort", onclose);
          }
          if (stream.req) {
            onrequest();
          } else {
            stream.on("request", onrequest);
          }
        } else if (writable && !wState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        if (!willEmitClose && typeof stream.aborted === "boolean") {
          stream.on("aborted", onclose);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (options.error !== false) {
          stream.on("error", onerror);
        }
        stream.on("close", onclose);
        if (closed) {
          process3.nextTick(onclose);
        } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
          if (!willEmitClose) {
            process3.nextTick(onclosed);
          }
        } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
          process3.nextTick(onclosed);
        } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
          process3.nextTick(onclosed);
        } else if (rState && stream.req && stream.aborted) {
          process3.nextTick(onclosed);
        }
        const cleanup = () => {
          callback = nop;
          stream.removeListener("aborted", onclose);
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
        if (options.signal && !closed) {
          const abort2 = () => {
            const endCallback = callback;
            cleanup();
            endCallback.call(
              stream,
              new AbortError(void 0, {
                cause: options.signal.reason
              })
            );
          };
          if (options.signal.aborted) {
            process3.nextTick(abort2);
          } else {
            const originalCallback = callback;
            callback = once3((...args) => {
              options.signal.removeEventListener("abort", abort2);
              originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort2);
          }
        }
        return cleanup;
      }
      function eosWeb(stream, options, callback) {
        let isAborted = false;
        let abort2 = nop;
        if (options.signal) {
          abort2 = () => {
            isAborted = true;
            callback.call(
              stream,
              new AbortError(void 0, {
                cause: options.signal.reason
              })
            );
          };
          if (options.signal.aborted) {
            process3.nextTick(abort2);
          } else {
            const originalCallback = callback;
            callback = once3((...args) => {
              options.signal.removeEventListener("abort", abort2);
              originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort2);
          }
        }
        const resolverFn = (...args) => {
          if (!isAborted) {
            process3.nextTick(() => callback.apply(stream, args));
          }
        };
        PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
        return nop;
      }
      function finished(stream, opts) {
        var _opts;
        let autoCleanup = false;
        if (opts === null) {
          opts = kEmptyObject;
        }
        if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
          validateBoolean(opts.cleanup, "cleanup");
          autoCleanup = opts.cleanup;
        }
        return new Promise2((resolve2, reject) => {
          const cleanup = eos(stream, opts, (err) => {
            if (autoCleanup) {
              cleanup();
            }
            if (err) {
              reject(err);
            } else {
              resolve2();
            }
          });
        });
      }
      module.exports = eos;
      module.exports.finished = finished;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var process3 = require_browser2();
      var {
        aggregateTwoErrors,
        codes: { ERR_MULTIPLE_CALLBACK },
        AbortError
      } = require_errors();
      var { Symbol: Symbol2 } = require_primordials();
      var { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
      var kDestroy = Symbol2("kDestroy");
      var kConstruct = Symbol2("kConstruct");
      function checkError(err, w2, r7) {
        if (err) {
          err.stack;
          if (w2 && !w2.errored) {
            w2.errored = err;
          }
          if (r7 && !r7.errored) {
            r7.errored = err;
          }
        }
      }
      function destroy(err, cb) {
        const r7 = this._readableState;
        const w2 = this._writableState;
        const s5 = w2 || r7;
        if (w2 !== null && w2 !== void 0 && w2.destroyed || r7 !== null && r7 !== void 0 && r7.destroyed) {
          if (typeof cb === "function") {
            cb();
          }
          return this;
        }
        checkError(err, w2, r7);
        if (w2) {
          w2.destroyed = true;
        }
        if (r7) {
          r7.destroyed = true;
        }
        if (!s5.constructed) {
          this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
          });
        } else {
          _destroy(this, err, cb);
        }
        return this;
      }
      function _destroy(self2, err, cb) {
        let called = false;
        function onDestroy(err2) {
          if (called) {
            return;
          }
          called = true;
          const r7 = self2._readableState;
          const w2 = self2._writableState;
          checkError(err2, w2, r7);
          if (w2) {
            w2.closed = true;
          }
          if (r7) {
            r7.closed = true;
          }
          if (typeof cb === "function") {
            cb(err2);
          }
          if (err2) {
            process3.nextTick(emitErrorCloseNT, self2, err2);
          } else {
            process3.nextTick(emitCloseNT, self2);
          }
        }
        try {
          self2._destroy(err || null, onDestroy);
        } catch (err2) {
          onDestroy(err2);
        }
      }
      function emitErrorCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        const r7 = self2._readableState;
        const w2 = self2._writableState;
        if (w2) {
          w2.closeEmitted = true;
        }
        if (r7) {
          r7.closeEmitted = true;
        }
        if (w2 !== null && w2 !== void 0 && w2.emitClose || r7 !== null && r7 !== void 0 && r7.emitClose) {
          self2.emit("close");
        }
      }
      function emitErrorNT(self2, err) {
        const r7 = self2._readableState;
        const w2 = self2._writableState;
        if (w2 !== null && w2 !== void 0 && w2.errorEmitted || r7 !== null && r7 !== void 0 && r7.errorEmitted) {
          return;
        }
        if (w2) {
          w2.errorEmitted = true;
        }
        if (r7) {
          r7.errorEmitted = true;
        }
        self2.emit("error", err);
      }
      function undestroy() {
        const r7 = this._readableState;
        const w2 = this._writableState;
        if (r7) {
          r7.constructed = true;
          r7.closed = false;
          r7.closeEmitted = false;
          r7.destroyed = false;
          r7.errored = null;
          r7.errorEmitted = false;
          r7.reading = false;
          r7.ended = r7.readable === false;
          r7.endEmitted = r7.readable === false;
        }
        if (w2) {
          w2.constructed = true;
          w2.destroyed = false;
          w2.closed = false;
          w2.closeEmitted = false;
          w2.errored = null;
          w2.errorEmitted = false;
          w2.finalCalled = false;
          w2.prefinished = false;
          w2.ended = w2.writable === false;
          w2.ending = w2.writable === false;
          w2.finished = w2.writable === false;
        }
      }
      function errorOrDestroy(stream, err, sync) {
        const r7 = stream._readableState;
        const w2 = stream._writableState;
        if (w2 !== null && w2 !== void 0 && w2.destroyed || r7 !== null && r7 !== void 0 && r7.destroyed) {
          return this;
        }
        if (r7 !== null && r7 !== void 0 && r7.autoDestroy || w2 !== null && w2 !== void 0 && w2.autoDestroy)
          stream.destroy(err);
        else if (err) {
          err.stack;
          if (w2 && !w2.errored) {
            w2.errored = err;
          }
          if (r7 && !r7.errored) {
            r7.errored = err;
          }
          if (sync) {
            process3.nextTick(emitErrorNT, stream, err);
          } else {
            emitErrorNT(stream, err);
          }
        }
      }
      function construct(stream, cb) {
        if (typeof stream._construct !== "function") {
          return;
        }
        const r7 = stream._readableState;
        const w2 = stream._writableState;
        if (r7) {
          r7.constructed = false;
        }
        if (w2) {
          w2.constructed = false;
        }
        stream.once(kConstruct, cb);
        if (stream.listenerCount(kConstruct) > 1) {
          return;
        }
        process3.nextTick(constructNT, stream);
      }
      function constructNT(stream) {
        let called = false;
        function onConstruct(err) {
          if (called) {
            errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
            return;
          }
          called = true;
          const r7 = stream._readableState;
          const w2 = stream._writableState;
          const s5 = w2 || r7;
          if (r7) {
            r7.constructed = true;
          }
          if (w2) {
            w2.constructed = true;
          }
          if (s5.destroyed) {
            stream.emit(kDestroy, err);
          } else if (err) {
            errorOrDestroy(stream, err, true);
          } else {
            process3.nextTick(emitConstructNT, stream);
          }
        }
        try {
          stream._construct((err) => {
            process3.nextTick(onConstruct, err);
          });
        } catch (err) {
          process3.nextTick(onConstruct, err);
        }
      }
      function emitConstructNT(stream) {
        stream.emit(kConstruct);
      }
      function isRequest(stream) {
        return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
      }
      function emitCloseLegacy(stream) {
        stream.emit("close");
      }
      function emitErrorCloseLegacy(stream, err) {
        stream.emit("error", err);
        process3.nextTick(emitCloseLegacy, stream);
      }
      function destroyer(stream, err) {
        if (!stream || isDestroyed(stream)) {
          return;
        }
        if (!err && !isFinished(stream)) {
          err = new AbortError();
        }
        if (isServerRequest(stream)) {
          stream.socket = null;
          stream.destroy(err);
        } else if (isRequest(stream)) {
          stream.abort();
        } else if (isRequest(stream.req)) {
          stream.req.abort();
        } else if (typeof stream.destroy === "function") {
          stream.destroy(err);
        } else if (typeof stream.close === "function") {
          stream.close();
        } else if (err) {
          process3.nextTick(emitErrorCloseLegacy, stream, err);
        } else {
          process3.nextTick(emitCloseLegacy, stream);
        }
        if (!stream.destroyed) {
          stream[kDestroyed] = true;
        }
      }
      module.exports = {
        construct,
        destroyer,
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js
  function o() {
    o.init.call(this);
  }
  function u(e7) {
    if ("function" != typeof e7)
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e7);
  }
  function f(e7) {
    return void 0 === e7._maxListeners ? o.defaultMaxListeners : e7._maxListeners;
  }
  function v(e7, t6, n7, r7) {
    var i6, o7, s5, v4;
    if (u(n7), void 0 === (o7 = e7._events) ? (o7 = e7._events = /* @__PURE__ */ Object.create(null), e7._eventsCount = 0) : (void 0 !== o7.newListener && (e7.emit("newListener", t6, n7.listener ? n7.listener : n7), o7 = e7._events), s5 = o7[t6]), void 0 === s5)
      s5 = o7[t6] = n7, ++e7._eventsCount;
    else if ("function" == typeof s5 ? s5 = o7[t6] = r7 ? [n7, s5] : [s5, n7] : r7 ? s5.unshift(n7) : s5.push(n7), (i6 = f(e7)) > 0 && s5.length > i6 && !s5.warned) {
      s5.warned = true;
      var a6 = new Error("Possible EventEmitter memory leak detected. " + s5.length + " " + String(t6) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a6.name = "MaxListenersExceededWarning", a6.emitter = e7, a6.type = t6, a6.count = s5.length, v4 = a6, console && console.warn && console.warn(v4);
    }
    return e7;
  }
  function a() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function l(e7, t6, n7) {
    var r7 = { fired: false, wrapFn: void 0, target: e7, type: t6, listener: n7 }, i6 = a.bind(r7);
    return i6.listener = n7, r7.wrapFn = i6, i6;
  }
  function h(e7, t6, n7) {
    var r7 = e7._events;
    if (void 0 === r7)
      return [];
    var i6 = r7[t6];
    return void 0 === i6 ? [] : "function" == typeof i6 ? n7 ? [i6.listener || i6] : [i6] : n7 ? function(e8) {
      for (var t7 = new Array(e8.length), n8 = 0; n8 < t7.length; ++n8)
        t7[n8] = e8[n8].listener || e8[n8];
      return t7;
    }(i6) : c(i6, i6.length);
  }
  function p(e7) {
    var t6 = this._events;
    if (void 0 !== t6) {
      var n7 = t6[e7];
      if ("function" == typeof n7)
        return 1;
      if (void 0 !== n7)
        return n7.length;
    }
    return 0;
  }
  function c(e7, t6) {
    for (var n7 = new Array(t6), r7 = 0; r7 < t6; ++r7)
      n7[r7] = e7[r7];
    return n7;
  }
  var e, t, n, r, i, s, y;
  var init_chunk_4bd36a8f = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      n = "object" == typeof Reflect ? Reflect : null;
      r = n && "function" == typeof n.apply ? n.apply : function(e7, t6, n7) {
        return Function.prototype.apply.call(e7, t6, n7);
      };
      t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e7) {
        return Object.getOwnPropertyNames(e7).concat(Object.getOwnPropertySymbols(e7));
      } : function(e7) {
        return Object.getOwnPropertyNames(e7);
      };
      i = Number.isNaN || function(e7) {
        return e7 != e7;
      };
      e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
      s = 10;
      Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
        return s;
      }, set: function(e7) {
        if ("number" != typeof e7 || e7 < 0 || i(e7))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e7 + ".");
        s = e7;
      } }), o.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, o.prototype.setMaxListeners = function(e7) {
        if ("number" != typeof e7 || e7 < 0 || i(e7))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e7 + ".");
        return this._maxListeners = e7, this;
      }, o.prototype.getMaxListeners = function() {
        return f(this);
      }, o.prototype.emit = function(e7) {
        for (var t6 = [], n7 = 1; n7 < arguments.length; n7++)
          t6.push(arguments[n7]);
        var i6 = "error" === e7, o7 = this._events;
        if (void 0 !== o7)
          i6 = i6 && void 0 === o7.error;
        else if (!i6)
          return false;
        if (i6) {
          var s5;
          if (t6.length > 0 && (s5 = t6[0]), s5 instanceof Error)
            throw s5;
          var u6 = new Error("Unhandled error." + (s5 ? " (" + s5.message + ")" : ""));
          throw u6.context = s5, u6;
        }
        var f6 = o7[e7];
        if (void 0 === f6)
          return false;
        if ("function" == typeof f6)
          r(f6, this, t6);
        else {
          var v4 = f6.length, a6 = c(f6, v4);
          for (n7 = 0; n7 < v4; ++n7)
            r(a6[n7], this, t6);
        }
        return true;
      }, o.prototype.addListener = function(e7, t6) {
        return v(this, e7, t6, false);
      }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e7, t6) {
        return v(this, e7, t6, true);
      }, o.prototype.once = function(e7, t6) {
        return u(t6), this.on(e7, l(this, e7, t6)), this;
      }, o.prototype.prependOnceListener = function(e7, t6) {
        return u(t6), this.prependListener(e7, l(this, e7, t6)), this;
      }, o.prototype.removeListener = function(e7, t6) {
        var n7, r7, i6, o7, s5;
        if (u(t6), void 0 === (r7 = this._events))
          return this;
        if (void 0 === (n7 = r7[e7]))
          return this;
        if (n7 === t6 || n7.listener === t6)
          0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r7[e7], r7.removeListener && this.emit("removeListener", e7, n7.listener || t6));
        else if ("function" != typeof n7) {
          for (i6 = -1, o7 = n7.length - 1; o7 >= 0; o7--)
            if (n7[o7] === t6 || n7[o7].listener === t6) {
              s5 = n7[o7].listener, i6 = o7;
              break;
            }
          if (i6 < 0)
            return this;
          0 === i6 ? n7.shift() : !function(e8, t7) {
            for (; t7 + 1 < e8.length; t7++)
              e8[t7] = e8[t7 + 1];
            e8.pop();
          }(n7, i6), 1 === n7.length && (r7[e7] = n7[0]), void 0 !== r7.removeListener && this.emit("removeListener", e7, s5 || t6);
        }
        return this;
      }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e7) {
        var t6, n7, r7;
        if (void 0 === (n7 = this._events))
          return this;
        if (void 0 === n7.removeListener)
          return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n7[e7] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n7[e7]), this;
        if (0 === arguments.length) {
          var i6, o7 = Object.keys(n7);
          for (r7 = 0; r7 < o7.length; ++r7)
            "removeListener" !== (i6 = o7[r7]) && this.removeAllListeners(i6);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (t6 = n7[e7]))
          this.removeListener(e7, t6);
        else if (void 0 !== t6)
          for (r7 = t6.length - 1; r7 >= 0; r7--)
            this.removeListener(e7, t6[r7]);
        return this;
      }, o.prototype.listeners = function(e7) {
        return h(this, e7, true);
      }, o.prototype.rawListeners = function(e7) {
        return h(this, e7, false);
      }, o.listenerCount = function(e7, t6) {
        return "function" == typeof e7.listenerCount ? e7.listenerCount(t6) : p.call(e7, t6);
      }, o.prototype.listenerCount = p, o.prototype.eventNames = function() {
        return this._eventsCount > 0 ? t(this._events) : [];
      };
      y = e;
      y.EventEmitter;
      y.defaultMaxListeners;
      y.init;
      y.listenerCount;
      y.EventEmitter;
      y.defaultMaxListeners;
      y.init;
      y.listenerCount;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/events.js
  var events_exports = {};
  __export(events_exports, {
    EventEmitter: () => EventEmitter,
    default: () => y,
    defaultMaxListeners: () => defaultMaxListeners,
    init: () => init,
    listenerCount: () => listenerCount,
    on: () => on2,
    once: () => once2
  });
  var EventEmitter, defaultMaxListeners, init, listenerCount, on2, once2;
  var init_events = __esm({
    "node_modules/@jspm/core/nodelibs/browser/events.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      init_chunk_4bd36a8f();
      init_chunk_4bd36a8f();
      y.once = function(emitter, event) {
        return new Promise((resolve2, reject) => {
          function eventListener(...args) {
            if (errorListener !== void 0) {
              emitter.removeListener("error", errorListener);
            }
            resolve2(args);
          }
          let errorListener;
          if (event !== "error") {
            errorListener = (err) => {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          emitter.once(event, eventListener);
        });
      };
      y.on = function(emitter, event) {
        const unconsumedEventValues = [];
        const unconsumedPromises = [];
        let error = null;
        let finished = false;
        const iterator = {
          async next() {
            const value = unconsumedEventValues.shift();
            if (value) {
              return createIterResult(value, false);
            }
            if (error) {
              const p6 = Promise.reject(error);
              error = null;
              return p6;
            }
            if (finished) {
              return createIterResult(void 0, true);
            }
            return new Promise((resolve2, reject) => unconsumedPromises.push({ resolve: resolve2, reject }));
          },
          async return() {
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
            finished = true;
            for (const promise of unconsumedPromises) {
              promise.resolve(createIterResult(void 0, true));
            }
            return createIterResult(void 0, true);
          },
          throw(err) {
            error = err;
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
        emitter.on(event, eventHandler);
        emitter.on("error", errorHandler);
        return iterator;
        function eventHandler(...args) {
          const promise = unconsumedPromises.shift();
          if (promise) {
            promise.resolve(createIterResult(args, false));
          } else {
            unconsumedEventValues.push(args);
          }
        }
        function errorHandler(err) {
          finished = true;
          const toError = unconsumedPromises.shift();
          if (toError) {
            toError.reject(err);
          } else {
            error = err;
          }
          iterator.return();
        }
      };
      ({
        EventEmitter,
        defaultMaxListeners,
        init,
        listenerCount,
        on: on2,
        once: once2
      } = y);
    }
  });

  // node_modules/readable-stream/lib/internal/streams/legacy.js
  var require_legacy = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/legacy.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
      var { EventEmitter: EE } = (init_events(), __toCommonJS(events_exports));
      function Stream(opts) {
        EE.call(this, opts);
      }
      ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
      ObjectSetPrototypeOf(Stream, EE);
      Stream.prototype.pipe = function(dest, options) {
        const source = this;
        function ondata(chunk) {
          if (dest.writable && dest.write(chunk) === false && source.pause) {
            source.pause();
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend);
          source.on("close", onclose);
        }
        let didOnEnd = false;
        function onend() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EE.listenerCount(this, "error") === 0) {
            this.emit("error", er);
          }
        }
        prependListener2(source, "error", onerror);
        prependListener2(dest, "error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
      function prependListener2(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (ArrayIsArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      module.exports = {
        Stream,
        prependListener: prependListener2
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
  var require_add_abort_signal = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { AbortError, codes } = require_errors();
      var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
      var eos = require_end_of_stream();
      var { ERR_INVALID_ARG_TYPE } = codes;
      var validateAbortSignal = (signal, name2) => {
        if (typeof signal !== "object" || !("aborted" in signal)) {
          throw new ERR_INVALID_ARG_TYPE(name2, "AbortSignal", signal);
        }
      };
      module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
        validateAbortSignal(signal, "signal");
        if (!isNodeStream(stream) && !isWebStream(stream)) {
          throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
        }
        return module.exports.addAbortSignalNoValidate(signal, stream);
      };
      module.exports.addAbortSignalNoValidate = function(signal, stream) {
        if (typeof signal !== "object" || !("aborted" in signal)) {
          return stream;
        }
        const onAbort = isNodeStream(stream) ? () => {
          stream.destroy(
            new AbortError(void 0, {
              cause: signal.reason
            })
          );
        } : () => {
          stream[kControllerErrorFunction](
            new AbortError(void 0, {
              cause: signal.reason
            })
          );
        };
        if (signal.aborted) {
          onAbort();
        } else {
          signal.addEventListener("abort", onAbort);
          eos(stream, () => signal.removeEventListener("abort", onAbort));
        }
        return stream;
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var { inspect } = require_util();
      module.exports = class BufferList {
        constructor() {
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        push(v4) {
          const entry = {
            data: v4,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
        unshift(v4) {
          const entry = {
            data: v4,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
        shift() {
          if (this.length === 0)
            return;
          const ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
        clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
        join(s5) {
          if (this.length === 0)
            return "";
          let p6 = this.head;
          let ret = "" + p6.data;
          while ((p6 = p6.next) !== null)
            ret += s5 + p6.data;
          return ret;
        }
        concat(n7) {
          if (this.length === 0)
            return Buffer3.alloc(0);
          const ret = Buffer3.allocUnsafe(n7 >>> 0);
          let p6 = this.head;
          let i6 = 0;
          while (p6) {
            TypedArrayPrototypeSet(ret, p6.data, i6);
            i6 += p6.data.length;
            p6 = p6.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
        consume(n7, hasStrings) {
          const data = this.head.data;
          if (n7 < data.length) {
            const slice = data.slice(0, n7);
            this.head.data = data.slice(n7);
            return slice;
          }
          if (n7 === data.length) {
            return this.shift();
          }
          return hasStrings ? this._getString(n7) : this._getBuffer(n7);
        }
        first() {
          return this.head.data;
        }
        *[SymbolIterator]() {
          for (let p6 = this.head; p6; p6 = p6.next) {
            yield p6.data;
          }
        }
        // Consumes a specified amount of characters from the buffered data.
        _getString(n7) {
          let ret = "";
          let p6 = this.head;
          let c6 = 0;
          do {
            const str = p6.data;
            if (n7 > str.length) {
              ret += str;
              n7 -= str.length;
            } else {
              if (n7 === str.length) {
                ret += str;
                ++c6;
                if (p6.next)
                  this.head = p6.next;
                else
                  this.head = this.tail = null;
              } else {
                ret += StringPrototypeSlice(str, 0, n7);
                this.head = p6;
                p6.data = StringPrototypeSlice(str, n7);
              }
              break;
            }
            ++c6;
          } while ((p6 = p6.next) !== null);
          this.length -= c6;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
        _getBuffer(n7) {
          const ret = Buffer3.allocUnsafe(n7);
          const retLen = n7;
          let p6 = this.head;
          let c6 = 0;
          do {
            const buf = p6.data;
            if (n7 > buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n7);
              n7 -= buf.length;
            } else {
              if (n7 === buf.length) {
                TypedArrayPrototypeSet(ret, buf, retLen - n7);
                ++c6;
                if (p6.next)
                  this.head = p6.next;
                else
                  this.head = this.tail = null;
              } else {
                TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n7), retLen - n7);
                this.head = p6;
                p6.data = buf.slice(n7);
              }
              break;
            }
            ++c6;
          } while ((p6 = p6.next) !== null);
          this.length -= c6;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
        [Symbol.for("nodejs.util.inspect.custom")](_2, options) {
          return inspect(this, {
            ...options,
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          });
        }
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/state.js
  var require_state = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/state.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { MathFloor, NumberIsInteger } = require_primordials();
      var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getDefaultHighWaterMark(objectMode) {
        return objectMode ? 16 : 16 * 1024;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!NumberIsInteger(hwm) || hwm < 0) {
            const name2 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
            throw new ERR_INVALID_ARG_VALUE(name2, hwm);
          }
          return MathFloor(hwm);
        }
        return getDefaultHighWaterMark(state.objectMode);
      }
      module.exports = {
        getHighWaterMark,
        getDefaultHighWaterMark
      };
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js
  function u$2(r7) {
    var t6 = r7.length;
    if (t6 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var e7 = r7.indexOf("=");
    return -1 === e7 && (e7 = t6), [e7, e7 === t6 ? 0 : 4 - e7 % 4];
  }
  function c$1(r7, e7, n7) {
    for (var o7, a6, h6 = [], u6 = e7; u6 < n7; u6 += 3)
      o7 = (r7[u6] << 16 & 16711680) + (r7[u6 + 1] << 8 & 65280) + (255 & r7[u6 + 2]), h6.push(t$1[(a6 = o7) >> 18 & 63] + t$1[a6 >> 12 & 63] + t$1[a6 >> 6 & 63] + t$1[63 & a6]);
    return h6.join("");
  }
  function f$2(t6) {
    if (t6 > 2147483647)
      throw new RangeError('The value "' + t6 + '" is invalid for option "size"');
    var r7 = new Uint8Array(t6);
    return Object.setPrototypeOf(r7, u$1$1.prototype), r7;
  }
  function u$1$1(t6, r7, e7) {
    if ("number" == typeof t6) {
      if ("string" == typeof r7)
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return a$2(t6);
    }
    return s$1(t6, r7, e7);
  }
  function s$1(t6, r7, e7) {
    if ("string" == typeof t6)
      return function(t7, r8) {
        "string" == typeof r8 && "" !== r8 || (r8 = "utf8");
        if (!u$1$1.isEncoding(r8))
          throw new TypeError("Unknown encoding: " + r8);
        var e8 = 0 | y2(t7, r8), n8 = f$2(e8), i7 = n8.write(t7, r8);
        i7 !== e8 && (n8 = n8.slice(0, i7));
        return n8;
      }(t6, r7);
    if (ArrayBuffer.isView(t6))
      return p2(t6);
    if (null == t6)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t6);
    if (F(t6, ArrayBuffer) || t6 && F(t6.buffer, ArrayBuffer))
      return c$1$1(t6, r7, e7);
    if ("undefined" != typeof SharedArrayBuffer && (F(t6, SharedArrayBuffer) || t6 && F(t6.buffer, SharedArrayBuffer)))
      return c$1$1(t6, r7, e7);
    if ("number" == typeof t6)
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    var n7 = t6.valueOf && t6.valueOf();
    if (null != n7 && n7 !== t6)
      return u$1$1.from(n7, r7, e7);
    var i6 = function(t7) {
      if (u$1$1.isBuffer(t7)) {
        var r8 = 0 | l$1(t7.length), e8 = f$2(r8);
        return 0 === e8.length || t7.copy(e8, 0, 0, r8), e8;
      }
      if (void 0 !== t7.length)
        return "number" != typeof t7.length || N(t7.length) ? f$2(0) : p2(t7);
      if ("Buffer" === t7.type && Array.isArray(t7.data))
        return p2(t7.data);
    }(t6);
    if (i6)
      return i6;
    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t6[Symbol.toPrimitive])
      return u$1$1.from(t6[Symbol.toPrimitive]("string"), r7, e7);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t6);
  }
  function h$1$1(t6) {
    if ("number" != typeof t6)
      throw new TypeError('"size" argument must be of type number');
    if (t6 < 0)
      throw new RangeError('The value "' + t6 + '" is invalid for option "size"');
  }
  function a$2(t6) {
    return h$1$1(t6), f$2(t6 < 0 ? 0 : 0 | l$1(t6));
  }
  function p2(t6) {
    for (var r7 = t6.length < 0 ? 0 : 0 | l$1(t6.length), e7 = f$2(r7), n7 = 0; n7 < r7; n7 += 1)
      e7[n7] = 255 & t6[n7];
    return e7;
  }
  function c$1$1(t6, r7, e7) {
    if (r7 < 0 || t6.byteLength < r7)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (t6.byteLength < r7 + (e7 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var n7;
    return n7 = void 0 === r7 && void 0 === e7 ? new Uint8Array(t6) : void 0 === e7 ? new Uint8Array(t6, r7) : new Uint8Array(t6, r7, e7), Object.setPrototypeOf(n7, u$1$1.prototype), n7;
  }
  function l$1(t6) {
    if (t6 >= 2147483647)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
    return 0 | t6;
  }
  function y2(t6, r7) {
    if (u$1$1.isBuffer(t6))
      return t6.length;
    if (ArrayBuffer.isView(t6) || F(t6, ArrayBuffer))
      return t6.byteLength;
    if ("string" != typeof t6)
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t6);
    var e7 = t6.length, n7 = arguments.length > 2 && true === arguments[2];
    if (!n7 && 0 === e7)
      return 0;
    for (var i6 = false; ; )
      switch (r7) {
        case "ascii":
        case "latin1":
        case "binary":
          return e7;
        case "utf8":
        case "utf-8":
          return _(t6).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * e7;
        case "hex":
          return e7 >>> 1;
        case "base64":
          return z(t6).length;
        default:
          if (i6)
            return n7 ? -1 : _(t6).length;
          r7 = ("" + r7).toLowerCase(), i6 = true;
      }
  }
  function g(t6, r7, e7) {
    var n7 = false;
    if ((void 0 === r7 || r7 < 0) && (r7 = 0), r7 > this.length)
      return "";
    if ((void 0 === e7 || e7 > this.length) && (e7 = this.length), e7 <= 0)
      return "";
    if ((e7 >>>= 0) <= (r7 >>>= 0))
      return "";
    for (t6 || (t6 = "utf8"); ; )
      switch (t6) {
        case "hex":
          return O(this, r7, e7);
        case "utf8":
        case "utf-8":
          return I(this, r7, e7);
        case "ascii":
          return S(this, r7, e7);
        case "latin1":
        case "binary":
          return R(this, r7, e7);
        case "base64":
          return T(this, r7, e7);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return L(this, r7, e7);
        default:
          if (n7)
            throw new TypeError("Unknown encoding: " + t6);
          t6 = (t6 + "").toLowerCase(), n7 = true;
      }
  }
  function w(t6, r7, e7) {
    var n7 = t6[r7];
    t6[r7] = t6[e7], t6[e7] = n7;
  }
  function d(t6, r7, e7, n7, i6) {
    if (0 === t6.length)
      return -1;
    if ("string" == typeof e7 ? (n7 = e7, e7 = 0) : e7 > 2147483647 ? e7 = 2147483647 : e7 < -2147483648 && (e7 = -2147483648), N(e7 = +e7) && (e7 = i6 ? 0 : t6.length - 1), e7 < 0 && (e7 = t6.length + e7), e7 >= t6.length) {
      if (i6)
        return -1;
      e7 = t6.length - 1;
    } else if (e7 < 0) {
      if (!i6)
        return -1;
      e7 = 0;
    }
    if ("string" == typeof r7 && (r7 = u$1$1.from(r7, n7)), u$1$1.isBuffer(r7))
      return 0 === r7.length ? -1 : v2(t6, r7, e7, n7, i6);
    if ("number" == typeof r7)
      return r7 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i6 ? Uint8Array.prototype.indexOf.call(t6, r7, e7) : Uint8Array.prototype.lastIndexOf.call(t6, r7, e7) : v2(t6, [r7], e7, n7, i6);
    throw new TypeError("val must be string, number or Buffer");
  }
  function v2(t6, r7, e7, n7, i6) {
    var o7, f6 = 1, u6 = t6.length, s5 = r7.length;
    if (void 0 !== n7 && ("ucs2" === (n7 = String(n7).toLowerCase()) || "ucs-2" === n7 || "utf16le" === n7 || "utf-16le" === n7)) {
      if (t6.length < 2 || r7.length < 2)
        return -1;
      f6 = 2, u6 /= 2, s5 /= 2, e7 /= 2;
    }
    function h6(t7, r8) {
      return 1 === f6 ? t7[r8] : t7.readUInt16BE(r8 * f6);
    }
    if (i6) {
      var a6 = -1;
      for (o7 = e7; o7 < u6; o7++)
        if (h6(t6, o7) === h6(r7, -1 === a6 ? 0 : o7 - a6)) {
          if (-1 === a6 && (a6 = o7), o7 - a6 + 1 === s5)
            return a6 * f6;
        } else
          -1 !== a6 && (o7 -= o7 - a6), a6 = -1;
    } else
      for (e7 + s5 > u6 && (e7 = u6 - s5), o7 = e7; o7 >= 0; o7--) {
        for (var p6 = true, c6 = 0; c6 < s5; c6++)
          if (h6(t6, o7 + c6) !== h6(r7, c6)) {
            p6 = false;
            break;
          }
        if (p6)
          return o7;
      }
    return -1;
  }
  function b(t6, r7, e7, n7) {
    e7 = Number(e7) || 0;
    var i6 = t6.length - e7;
    n7 ? (n7 = Number(n7)) > i6 && (n7 = i6) : n7 = i6;
    var o7 = r7.length;
    n7 > o7 / 2 && (n7 = o7 / 2);
    for (var f6 = 0; f6 < n7; ++f6) {
      var u6 = parseInt(r7.substr(2 * f6, 2), 16);
      if (N(u6))
        return f6;
      t6[e7 + f6] = u6;
    }
    return f6;
  }
  function m(t6, r7, e7, n7) {
    return D(_(r7, t6.length - e7), t6, e7, n7);
  }
  function E(t6, r7, e7, n7) {
    return D(function(t7) {
      for (var r8 = [], e8 = 0; e8 < t7.length; ++e8)
        r8.push(255 & t7.charCodeAt(e8));
      return r8;
    }(r7), t6, e7, n7);
  }
  function B(t6, r7, e7, n7) {
    return E(t6, r7, e7, n7);
  }
  function A(t6, r7, e7, n7) {
    return D(z(r7), t6, e7, n7);
  }
  function U(t6, r7, e7, n7) {
    return D(function(t7, r8) {
      for (var e8, n8, i6, o7 = [], f6 = 0; f6 < t7.length && !((r8 -= 2) < 0); ++f6)
        e8 = t7.charCodeAt(f6), n8 = e8 >> 8, i6 = e8 % 256, o7.push(i6), o7.push(n8);
      return o7;
    }(r7, t6.length - e7), t6, e7, n7);
  }
  function T(t6, r7, e7) {
    return 0 === r7 && e7 === t6.length ? n$1$1.fromByteArray(t6) : n$1$1.fromByteArray(t6.slice(r7, e7));
  }
  function I(t6, r7, e7) {
    e7 = Math.min(t6.length, e7);
    for (var n7 = [], i6 = r7; i6 < e7; ) {
      var o7, f6, u6, s5, h6 = t6[i6], a6 = null, p6 = h6 > 239 ? 4 : h6 > 223 ? 3 : h6 > 191 ? 2 : 1;
      if (i6 + p6 <= e7)
        switch (p6) {
          case 1:
            h6 < 128 && (a6 = h6);
            break;
          case 2:
            128 == (192 & (o7 = t6[i6 + 1])) && (s5 = (31 & h6) << 6 | 63 & o7) > 127 && (a6 = s5);
            break;
          case 3:
            o7 = t6[i6 + 1], f6 = t6[i6 + 2], 128 == (192 & o7) && 128 == (192 & f6) && (s5 = (15 & h6) << 12 | (63 & o7) << 6 | 63 & f6) > 2047 && (s5 < 55296 || s5 > 57343) && (a6 = s5);
            break;
          case 4:
            o7 = t6[i6 + 1], f6 = t6[i6 + 2], u6 = t6[i6 + 3], 128 == (192 & o7) && 128 == (192 & f6) && 128 == (192 & u6) && (s5 = (15 & h6) << 18 | (63 & o7) << 12 | (63 & f6) << 6 | 63 & u6) > 65535 && s5 < 1114112 && (a6 = s5);
        }
      null === a6 ? (a6 = 65533, p6 = 1) : a6 > 65535 && (a6 -= 65536, n7.push(a6 >>> 10 & 1023 | 55296), a6 = 56320 | 1023 & a6), n7.push(a6), i6 += p6;
    }
    return function(t7) {
      var r8 = t7.length;
      if (r8 <= 4096)
        return String.fromCharCode.apply(String, t7);
      var e8 = "", n8 = 0;
      for (; n8 < r8; )
        e8 += String.fromCharCode.apply(String, t7.slice(n8, n8 += 4096));
      return e8;
    }(n7);
  }
  function S(t6, r7, e7) {
    var n7 = "";
    e7 = Math.min(t6.length, e7);
    for (var i6 = r7; i6 < e7; ++i6)
      n7 += String.fromCharCode(127 & t6[i6]);
    return n7;
  }
  function R(t6, r7, e7) {
    var n7 = "";
    e7 = Math.min(t6.length, e7);
    for (var i6 = r7; i6 < e7; ++i6)
      n7 += String.fromCharCode(t6[i6]);
    return n7;
  }
  function O(t6, r7, e7) {
    var n7 = t6.length;
    (!r7 || r7 < 0) && (r7 = 0), (!e7 || e7 < 0 || e7 > n7) && (e7 = n7);
    for (var i6 = "", o7 = r7; o7 < e7; ++o7)
      i6 += Y[t6[o7]];
    return i6;
  }
  function L(t6, r7, e7) {
    for (var n7 = t6.slice(r7, e7), i6 = "", o7 = 0; o7 < n7.length; o7 += 2)
      i6 += String.fromCharCode(n7[o7] + 256 * n7[o7 + 1]);
    return i6;
  }
  function x(t6, r7, e7) {
    if (t6 % 1 != 0 || t6 < 0)
      throw new RangeError("offset is not uint");
    if (t6 + r7 > e7)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function C(t6, r7, e7, n7, i6, o7) {
    if (!u$1$1.isBuffer(t6))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r7 > i6 || r7 < o7)
      throw new RangeError('"value" argument is out of bounds');
    if (e7 + n7 > t6.length)
      throw new RangeError("Index out of range");
  }
  function P(t6, r7, e7, n7, i6, o7) {
    if (e7 + n7 > t6.length)
      throw new RangeError("Index out of range");
    if (e7 < 0)
      throw new RangeError("Index out of range");
  }
  function k(t6, r7, e7, n7, o7) {
    return r7 = +r7, e7 >>>= 0, o7 || P(t6, 0, e7, 4), i$1.write(t6, r7, e7, n7, 23, 4), e7 + 4;
  }
  function M(t6, r7, e7, n7, o7) {
    return r7 = +r7, e7 >>>= 0, o7 || P(t6, 0, e7, 8), i$1.write(t6, r7, e7, n7, 52, 8), e7 + 8;
  }
  function _(t6, r7) {
    var e7;
    r7 = r7 || 1 / 0;
    for (var n7 = t6.length, i6 = null, o7 = [], f6 = 0; f6 < n7; ++f6) {
      if ((e7 = t6.charCodeAt(f6)) > 55295 && e7 < 57344) {
        if (!i6) {
          if (e7 > 56319) {
            (r7 -= 3) > -1 && o7.push(239, 191, 189);
            continue;
          }
          if (f6 + 1 === n7) {
            (r7 -= 3) > -1 && o7.push(239, 191, 189);
            continue;
          }
          i6 = e7;
          continue;
        }
        if (e7 < 56320) {
          (r7 -= 3) > -1 && o7.push(239, 191, 189), i6 = e7;
          continue;
        }
        e7 = 65536 + (i6 - 55296 << 10 | e7 - 56320);
      } else
        i6 && (r7 -= 3) > -1 && o7.push(239, 191, 189);
      if (i6 = null, e7 < 128) {
        if ((r7 -= 1) < 0)
          break;
        o7.push(e7);
      } else if (e7 < 2048) {
        if ((r7 -= 2) < 0)
          break;
        o7.push(e7 >> 6 | 192, 63 & e7 | 128);
      } else if (e7 < 65536) {
        if ((r7 -= 3) < 0)
          break;
        o7.push(e7 >> 12 | 224, e7 >> 6 & 63 | 128, 63 & e7 | 128);
      } else {
        if (!(e7 < 1114112))
          throw new Error("Invalid code point");
        if ((r7 -= 4) < 0)
          break;
        o7.push(e7 >> 18 | 240, e7 >> 12 & 63 | 128, e7 >> 6 & 63 | 128, 63 & e7 | 128);
      }
    }
    return o7;
  }
  function z(t6) {
    return n$1$1.toByteArray(function(t7) {
      if ((t7 = (t7 = t7.split("=")[0]).trim().replace(j, "")).length < 2)
        return "";
      for (; t7.length % 4 != 0; )
        t7 += "=";
      return t7;
    }(t6));
  }
  function D(t6, r7, e7, n7) {
    for (var i6 = 0; i6 < n7 && !(i6 + e7 >= r7.length || i6 >= t6.length); ++i6)
      r7[i6 + e7] = t6[i6];
    return i6;
  }
  function F(t6, r7) {
    return t6 instanceof r7 || null != t6 && null != t6.constructor && null != t6.constructor.name && t6.constructor.name === r7.name;
  }
  function N(t6) {
    return t6 != t6;
  }
  function t2(r7, e7) {
    for (var n7 in r7)
      e7[n7] = r7[n7];
  }
  function f2(r7, e7, n7) {
    return o2(r7, e7, n7);
  }
  function a2(t6) {
    var e7;
    switch (this.encoding = function(t7) {
      var e8 = function(t8) {
        if (!t8)
          return "utf8";
        for (var e9; ; )
          switch (t8) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return t8;
            default:
              if (e9)
                return;
              t8 = ("" + t8).toLowerCase(), e9 = true;
          }
      }(t7);
      if ("string" != typeof e8 && (s2.isEncoding === i2 || !i2(t7)))
        throw new Error("Unknown encoding: " + t7);
      return e8 || t7;
    }(t6), this.encoding) {
      case "utf16le":
        this.text = h2, this.end = l2, e7 = 4;
        break;
      case "utf8":
        this.fillLast = n$1, e7 = 4;
        break;
      case "base64":
        this.text = u$1, this.end = o$1, e7 = 3;
        break;
      default:
        return this.write = f$1, this.end = c2, void 0;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s2.allocUnsafe(e7);
  }
  function r2(t6) {
    return t6 <= 127 ? 0 : t6 >> 5 == 6 ? 2 : t6 >> 4 == 14 ? 3 : t6 >> 3 == 30 ? 4 : t6 >> 6 == 2 ? -1 : -2;
  }
  function n$1(t6) {
    var e7 = this.lastTotal - this.lastNeed, s5 = function(t7, e8, s6) {
      if (128 != (192 & e8[0]))
        return t7.lastNeed = 0, "\uFFFD";
      if (t7.lastNeed > 1 && e8.length > 1) {
        if (128 != (192 & e8[1]))
          return t7.lastNeed = 1, "\uFFFD";
        if (t7.lastNeed > 2 && e8.length > 2 && 128 != (192 & e8[2]))
          return t7.lastNeed = 2, "\uFFFD";
      }
    }(this, t6);
    return void 0 !== s5 ? s5 : this.lastNeed <= t6.length ? (t6.copy(this.lastChar, e7, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t6.copy(this.lastChar, e7, 0, t6.length), this.lastNeed -= t6.length, void 0);
  }
  function h2(t6, e7) {
    if ((t6.length - e7) % 2 == 0) {
      var s5 = t6.toString("utf16le", e7);
      if (s5) {
        var i6 = s5.charCodeAt(s5.length - 1);
        if (i6 >= 55296 && i6 <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t6[t6.length - 2], this.lastChar[1] = t6[t6.length - 1], s5.slice(0, -1);
      }
      return s5;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t6[t6.length - 1], t6.toString("utf16le", e7, t6.length - 1);
  }
  function l2(t6) {
    var e7 = t6 && t6.length ? this.write(t6) : "";
    if (this.lastNeed) {
      var s5 = this.lastTotal - this.lastNeed;
      return e7 + this.lastChar.toString("utf16le", 0, s5);
    }
    return e7;
  }
  function u$1(t6, e7) {
    var s5 = (t6.length - e7) % 3;
    return 0 === s5 ? t6.toString("base64", e7) : (this.lastNeed = 3 - s5, this.lastTotal = 3, 1 === s5 ? this.lastChar[0] = t6[t6.length - 1] : (this.lastChar[0] = t6[t6.length - 2], this.lastChar[1] = t6[t6.length - 1]), t6.toString("base64", e7, t6.length - s5));
  }
  function o$1(t6) {
    var e7 = t6 && t6.length ? this.write(t6) : "";
    return this.lastNeed ? e7 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e7;
  }
  function f$1(t6) {
    return t6.toString(this.encoding);
  }
  function c2(t6) {
    return t6 && t6.length ? this.write(t6) : "";
  }
  var r$1, t$1, e$2, n$2, o$2, a$1, h$1, a$1$1, e$1$1, n$1$1, i$1, o$1$1, j, Y, e2, n2, o2, u2, e$1, s2, i2;
  var init_chunk_4ccc3a29 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      for (r$1 = { byteLength: function(r7) {
        var t6 = u$2(r7), e7 = t6[0], n7 = t6[1];
        return 3 * (e7 + n7) / 4 - n7;
      }, toByteArray: function(r7) {
        var t6, o7, a6 = u$2(r7), h6 = a6[0], c6 = a6[1], d4 = new n$2(function(r8, t7, e7) {
          return 3 * (t7 + e7) / 4 - e7;
        }(0, h6, c6)), f6 = 0, A2 = c6 > 0 ? h6 - 4 : h6;
        for (o7 = 0; o7 < A2; o7 += 4)
          t6 = e$2[r7.charCodeAt(o7)] << 18 | e$2[r7.charCodeAt(o7 + 1)] << 12 | e$2[r7.charCodeAt(o7 + 2)] << 6 | e$2[r7.charCodeAt(o7 + 3)], d4[f6++] = t6 >> 16 & 255, d4[f6++] = t6 >> 8 & 255, d4[f6++] = 255 & t6;
        2 === c6 && (t6 = e$2[r7.charCodeAt(o7)] << 2 | e$2[r7.charCodeAt(o7 + 1)] >> 4, d4[f6++] = 255 & t6);
        1 === c6 && (t6 = e$2[r7.charCodeAt(o7)] << 10 | e$2[r7.charCodeAt(o7 + 1)] << 4 | e$2[r7.charCodeAt(o7 + 2)] >> 2, d4[f6++] = t6 >> 8 & 255, d4[f6++] = 255 & t6);
        return d4;
      }, fromByteArray: function(r7) {
        for (var e7, n7 = r7.length, o7 = n7 % 3, a6 = [], h6 = 0, u6 = n7 - o7; h6 < u6; h6 += 16383)
          a6.push(c$1(r7, h6, h6 + 16383 > u6 ? u6 : h6 + 16383));
        1 === o7 ? (e7 = r7[n7 - 1], a6.push(t$1[e7 >> 2] + t$1[e7 << 4 & 63] + "==")) : 2 === o7 && (e7 = (r7[n7 - 2] << 8) + r7[n7 - 1], a6.push(t$1[e7 >> 10] + t$1[e7 >> 4 & 63] + t$1[e7 << 2 & 63] + "="));
        return a6.join("");
      } }, t$1 = [], e$2 = [], n$2 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$1 = 0, h$1 = o$2.length; a$1 < h$1; ++a$1)
        t$1[a$1] = o$2[a$1], e$2[o$2.charCodeAt(a$1)] = a$1;
      e$2["-".charCodeAt(0)] = 62, e$2["_".charCodeAt(0)] = 63;
      a$1$1 = { read: function(a6, t6, o7, r7, h6) {
        var M2, f6, p6 = 8 * h6 - r7 - 1, w2 = (1 << p6) - 1, e7 = w2 >> 1, i6 = -7, N2 = o7 ? h6 - 1 : 0, n7 = o7 ? -1 : 1, u6 = a6[t6 + N2];
        for (N2 += n7, M2 = u6 & (1 << -i6) - 1, u6 >>= -i6, i6 += p6; i6 > 0; M2 = 256 * M2 + a6[t6 + N2], N2 += n7, i6 -= 8)
          ;
        for (f6 = M2 & (1 << -i6) - 1, M2 >>= -i6, i6 += r7; i6 > 0; f6 = 256 * f6 + a6[t6 + N2], N2 += n7, i6 -= 8)
          ;
        if (0 === M2)
          M2 = 1 - e7;
        else {
          if (M2 === w2)
            return f6 ? NaN : 1 / 0 * (u6 ? -1 : 1);
          f6 += Math.pow(2, r7), M2 -= e7;
        }
        return (u6 ? -1 : 1) * f6 * Math.pow(2, M2 - r7);
      }, write: function(a6, t6, o7, r7, h6, M2) {
        var f6, p6, w2, e7 = 8 * M2 - h6 - 1, i6 = (1 << e7) - 1, N2 = i6 >> 1, n7 = 23 === h6 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u6 = r7 ? 0 : M2 - 1, l6 = r7 ? 1 : -1, s5 = t6 < 0 || 0 === t6 && 1 / t6 < 0 ? 1 : 0;
        for (t6 = Math.abs(t6), isNaN(t6) || t6 === 1 / 0 ? (p6 = isNaN(t6) ? 1 : 0, f6 = i6) : (f6 = Math.floor(Math.log(t6) / Math.LN2), t6 * (w2 = Math.pow(2, -f6)) < 1 && (f6--, w2 *= 2), (t6 += f6 + N2 >= 1 ? n7 / w2 : n7 * Math.pow(2, 1 - N2)) * w2 >= 2 && (f6++, w2 /= 2), f6 + N2 >= i6 ? (p6 = 0, f6 = i6) : f6 + N2 >= 1 ? (p6 = (t6 * w2 - 1) * Math.pow(2, h6), f6 += N2) : (p6 = t6 * Math.pow(2, N2 - 1) * Math.pow(2, h6), f6 = 0)); h6 >= 8; a6[o7 + u6] = 255 & p6, u6 += l6, p6 /= 256, h6 -= 8)
          ;
        for (f6 = f6 << h6 | p6, e7 += h6; e7 > 0; a6[o7 + u6] = 255 & f6, u6 += l6, f6 /= 256, e7 -= 8)
          ;
        a6[o7 + u6 - l6] |= 128 * s5;
      } };
      e$1$1 = {};
      n$1$1 = r$1;
      i$1 = a$1$1;
      o$1$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
      e$1$1.Buffer = u$1$1, e$1$1.SlowBuffer = function(t6) {
        +t6 != t6 && (t6 = 0);
        return u$1$1.alloc(+t6);
      }, e$1$1.INSPECT_MAX_BYTES = 50;
      e$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
        try {
          var t6 = new Uint8Array(1), r7 = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(r7, Uint8Array.prototype), Object.setPrototypeOf(t6, r7), 42 === t6.foo();
        } catch (t7) {
          return false;
        }
      }(), u$1$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$1.prototype, "parent", { enumerable: true, get: function() {
        if (u$1$1.isBuffer(this))
          return this.buffer;
      } }), Object.defineProperty(u$1$1.prototype, "offset", { enumerable: true, get: function() {
        if (u$1$1.isBuffer(this))
          return this.byteOffset;
      } }), u$1$1.poolSize = 8192, u$1$1.from = function(t6, r7, e7) {
        return s$1(t6, r7, e7);
      }, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function(t6, r7, e7) {
        return function(t7, r8, e8) {
          return h$1$1(t7), t7 <= 0 ? f$2(t7) : void 0 !== r8 ? "string" == typeof e8 ? f$2(t7).fill(r8, e8) : f$2(t7).fill(r8) : f$2(t7);
        }(t6, r7, e7);
      }, u$1$1.allocUnsafe = function(t6) {
        return a$2(t6);
      }, u$1$1.allocUnsafeSlow = function(t6) {
        return a$2(t6);
      }, u$1$1.isBuffer = function(t6) {
        return null != t6 && true === t6._isBuffer && t6 !== u$1$1.prototype;
      }, u$1$1.compare = function(t6, r7) {
        if (F(t6, Uint8Array) && (t6 = u$1$1.from(t6, t6.offset, t6.byteLength)), F(r7, Uint8Array) && (r7 = u$1$1.from(r7, r7.offset, r7.byteLength)), !u$1$1.isBuffer(t6) || !u$1$1.isBuffer(r7))
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (t6 === r7)
          return 0;
        for (var e7 = t6.length, n7 = r7.length, i6 = 0, o7 = Math.min(e7, n7); i6 < o7; ++i6)
          if (t6[i6] !== r7[i6]) {
            e7 = t6[i6], n7 = r7[i6];
            break;
          }
        return e7 < n7 ? -1 : n7 < e7 ? 1 : 0;
      }, u$1$1.isEncoding = function(t6) {
        switch (String(t6).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, u$1$1.concat = function(t6, r7) {
        if (!Array.isArray(t6))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t6.length)
          return u$1$1.alloc(0);
        var e7;
        if (void 0 === r7)
          for (r7 = 0, e7 = 0; e7 < t6.length; ++e7)
            r7 += t6[e7].length;
        var n7 = u$1$1.allocUnsafe(r7), i6 = 0;
        for (e7 = 0; e7 < t6.length; ++e7) {
          var o7 = t6[e7];
          if (F(o7, Uint8Array) && (o7 = u$1$1.from(o7)), !u$1$1.isBuffer(o7))
            throw new TypeError('"list" argument must be an Array of Buffers');
          o7.copy(n7, i6), i6 += o7.length;
        }
        return n7;
      }, u$1$1.byteLength = y2, u$1$1.prototype._isBuffer = true, u$1$1.prototype.swap16 = function() {
        var t6 = this.length;
        if (t6 % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var r7 = 0; r7 < t6; r7 += 2)
          w(this, r7, r7 + 1);
        return this;
      }, u$1$1.prototype.swap32 = function() {
        var t6 = this.length;
        if (t6 % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var r7 = 0; r7 < t6; r7 += 4)
          w(this, r7, r7 + 3), w(this, r7 + 1, r7 + 2);
        return this;
      }, u$1$1.prototype.swap64 = function() {
        var t6 = this.length;
        if (t6 % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var r7 = 0; r7 < t6; r7 += 8)
          w(this, r7, r7 + 7), w(this, r7 + 1, r7 + 6), w(this, r7 + 2, r7 + 5), w(this, r7 + 3, r7 + 4);
        return this;
      }, u$1$1.prototype.toString = function() {
        var t6 = this.length;
        return 0 === t6 ? "" : 0 === arguments.length ? I(this, 0, t6) : g.apply(this, arguments);
      }, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function(t6) {
        if (!u$1$1.isBuffer(t6))
          throw new TypeError("Argument must be a Buffer");
        return this === t6 || 0 === u$1$1.compare(this, t6);
      }, u$1$1.prototype.inspect = function() {
        var t6 = "", r7 = e$1$1.INSPECT_MAX_BYTES;
        return t6 = this.toString("hex", 0, r7).replace(/(.{2})/g, "$1 ").trim(), this.length > r7 && (t6 += " ... "), "<Buffer " + t6 + ">";
      }, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function(t6, r7, e7, n7, i6) {
        if (F(t6, Uint8Array) && (t6 = u$1$1.from(t6, t6.offset, t6.byteLength)), !u$1$1.isBuffer(t6))
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t6);
        if (void 0 === r7 && (r7 = 0), void 0 === e7 && (e7 = t6 ? t6.length : 0), void 0 === n7 && (n7 = 0), void 0 === i6 && (i6 = this.length), r7 < 0 || e7 > t6.length || n7 < 0 || i6 > this.length)
          throw new RangeError("out of range index");
        if (n7 >= i6 && r7 >= e7)
          return 0;
        if (n7 >= i6)
          return -1;
        if (r7 >= e7)
          return 1;
        if (this === t6)
          return 0;
        for (var o7 = (i6 >>>= 0) - (n7 >>>= 0), f6 = (e7 >>>= 0) - (r7 >>>= 0), s5 = Math.min(o7, f6), h6 = this.slice(n7, i6), a6 = t6.slice(r7, e7), p6 = 0; p6 < s5; ++p6)
          if (h6[p6] !== a6[p6]) {
            o7 = h6[p6], f6 = a6[p6];
            break;
          }
        return o7 < f6 ? -1 : f6 < o7 ? 1 : 0;
      }, u$1$1.prototype.includes = function(t6, r7, e7) {
        return -1 !== this.indexOf(t6, r7, e7);
      }, u$1$1.prototype.indexOf = function(t6, r7, e7) {
        return d(this, t6, r7, e7, true);
      }, u$1$1.prototype.lastIndexOf = function(t6, r7, e7) {
        return d(this, t6, r7, e7, false);
      }, u$1$1.prototype.write = function(t6, r7, e7, n7) {
        if (void 0 === r7)
          n7 = "utf8", e7 = this.length, r7 = 0;
        else if (void 0 === e7 && "string" == typeof r7)
          n7 = r7, e7 = this.length, r7 = 0;
        else {
          if (!isFinite(r7))
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          r7 >>>= 0, isFinite(e7) ? (e7 >>>= 0, void 0 === n7 && (n7 = "utf8")) : (n7 = e7, e7 = void 0);
        }
        var i6 = this.length - r7;
        if ((void 0 === e7 || e7 > i6) && (e7 = i6), t6.length > 0 && (e7 < 0 || r7 < 0) || r7 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        n7 || (n7 = "utf8");
        for (var o7 = false; ; )
          switch (n7) {
            case "hex":
              return b(this, t6, r7, e7);
            case "utf8":
            case "utf-8":
              return m(this, t6, r7, e7);
            case "ascii":
              return E(this, t6, r7, e7);
            case "latin1":
            case "binary":
              return B(this, t6, r7, e7);
            case "base64":
              return A(this, t6, r7, e7);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return U(this, t6, r7, e7);
            default:
              if (o7)
                throw new TypeError("Unknown encoding: " + n7);
              n7 = ("" + n7).toLowerCase(), o7 = true;
          }
      }, u$1$1.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      u$1$1.prototype.slice = function(t6, r7) {
        var e7 = this.length;
        (t6 = ~~t6) < 0 ? (t6 += e7) < 0 && (t6 = 0) : t6 > e7 && (t6 = e7), (r7 = void 0 === r7 ? e7 : ~~r7) < 0 ? (r7 += e7) < 0 && (r7 = 0) : r7 > e7 && (r7 = e7), r7 < t6 && (r7 = t6);
        var n7 = this.subarray(t6, r7);
        return Object.setPrototypeOf(n7, u$1$1.prototype), n7;
      }, u$1$1.prototype.readUIntLE = function(t6, r7, e7) {
        t6 >>>= 0, r7 >>>= 0, e7 || x(t6, r7, this.length);
        for (var n7 = this[t6], i6 = 1, o7 = 0; ++o7 < r7 && (i6 *= 256); )
          n7 += this[t6 + o7] * i6;
        return n7;
      }, u$1$1.prototype.readUIntBE = function(t6, r7, e7) {
        t6 >>>= 0, r7 >>>= 0, e7 || x(t6, r7, this.length);
        for (var n7 = this[t6 + --r7], i6 = 1; r7 > 0 && (i6 *= 256); )
          n7 += this[t6 + --r7] * i6;
        return n7;
      }, u$1$1.prototype.readUInt8 = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 1, this.length), this[t6];
      }, u$1$1.prototype.readUInt16LE = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 2, this.length), this[t6] | this[t6 + 1] << 8;
      }, u$1$1.prototype.readUInt16BE = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 2, this.length), this[t6] << 8 | this[t6 + 1];
      }, u$1$1.prototype.readUInt32LE = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 4, this.length), (this[t6] | this[t6 + 1] << 8 | this[t6 + 2] << 16) + 16777216 * this[t6 + 3];
      }, u$1$1.prototype.readUInt32BE = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 4, this.length), 16777216 * this[t6] + (this[t6 + 1] << 16 | this[t6 + 2] << 8 | this[t6 + 3]);
      }, u$1$1.prototype.readIntLE = function(t6, r7, e7) {
        t6 >>>= 0, r7 >>>= 0, e7 || x(t6, r7, this.length);
        for (var n7 = this[t6], i6 = 1, o7 = 0; ++o7 < r7 && (i6 *= 256); )
          n7 += this[t6 + o7] * i6;
        return n7 >= (i6 *= 128) && (n7 -= Math.pow(2, 8 * r7)), n7;
      }, u$1$1.prototype.readIntBE = function(t6, r7, e7) {
        t6 >>>= 0, r7 >>>= 0, e7 || x(t6, r7, this.length);
        for (var n7 = r7, i6 = 1, o7 = this[t6 + --n7]; n7 > 0 && (i6 *= 256); )
          o7 += this[t6 + --n7] * i6;
        return o7 >= (i6 *= 128) && (o7 -= Math.pow(2, 8 * r7)), o7;
      }, u$1$1.prototype.readInt8 = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 1, this.length), 128 & this[t6] ? -1 * (255 - this[t6] + 1) : this[t6];
      }, u$1$1.prototype.readInt16LE = function(t6, r7) {
        t6 >>>= 0, r7 || x(t6, 2, this.length);
        var e7 = this[t6] | this[t6 + 1] << 8;
        return 32768 & e7 ? 4294901760 | e7 : e7;
      }, u$1$1.prototype.readInt16BE = function(t6, r7) {
        t6 >>>= 0, r7 || x(t6, 2, this.length);
        var e7 = this[t6 + 1] | this[t6] << 8;
        return 32768 & e7 ? 4294901760 | e7 : e7;
      }, u$1$1.prototype.readInt32LE = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 4, this.length), this[t6] | this[t6 + 1] << 8 | this[t6 + 2] << 16 | this[t6 + 3] << 24;
      }, u$1$1.prototype.readInt32BE = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 4, this.length), this[t6] << 24 | this[t6 + 1] << 16 | this[t6 + 2] << 8 | this[t6 + 3];
      }, u$1$1.prototype.readFloatLE = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 4, this.length), i$1.read(this, t6, true, 23, 4);
      }, u$1$1.prototype.readFloatBE = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 4, this.length), i$1.read(this, t6, false, 23, 4);
      }, u$1$1.prototype.readDoubleLE = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 8, this.length), i$1.read(this, t6, true, 52, 8);
      }, u$1$1.prototype.readDoubleBE = function(t6, r7) {
        return t6 >>>= 0, r7 || x(t6, 8, this.length), i$1.read(this, t6, false, 52, 8);
      }, u$1$1.prototype.writeUIntLE = function(t6, r7, e7, n7) {
        (t6 = +t6, r7 >>>= 0, e7 >>>= 0, n7) || C(this, t6, r7, e7, Math.pow(2, 8 * e7) - 1, 0);
        var i6 = 1, o7 = 0;
        for (this[r7] = 255 & t6; ++o7 < e7 && (i6 *= 256); )
          this[r7 + o7] = t6 / i6 & 255;
        return r7 + e7;
      }, u$1$1.prototype.writeUIntBE = function(t6, r7, e7, n7) {
        (t6 = +t6, r7 >>>= 0, e7 >>>= 0, n7) || C(this, t6, r7, e7, Math.pow(2, 8 * e7) - 1, 0);
        var i6 = e7 - 1, o7 = 1;
        for (this[r7 + i6] = 255 & t6; --i6 >= 0 && (o7 *= 256); )
          this[r7 + i6] = t6 / o7 & 255;
        return r7 + e7;
      }, u$1$1.prototype.writeUInt8 = function(t6, r7, e7) {
        return t6 = +t6, r7 >>>= 0, e7 || C(this, t6, r7, 1, 255, 0), this[r7] = 255 & t6, r7 + 1;
      }, u$1$1.prototype.writeUInt16LE = function(t6, r7, e7) {
        return t6 = +t6, r7 >>>= 0, e7 || C(this, t6, r7, 2, 65535, 0), this[r7] = 255 & t6, this[r7 + 1] = t6 >>> 8, r7 + 2;
      }, u$1$1.prototype.writeUInt16BE = function(t6, r7, e7) {
        return t6 = +t6, r7 >>>= 0, e7 || C(this, t6, r7, 2, 65535, 0), this[r7] = t6 >>> 8, this[r7 + 1] = 255 & t6, r7 + 2;
      }, u$1$1.prototype.writeUInt32LE = function(t6, r7, e7) {
        return t6 = +t6, r7 >>>= 0, e7 || C(this, t6, r7, 4, 4294967295, 0), this[r7 + 3] = t6 >>> 24, this[r7 + 2] = t6 >>> 16, this[r7 + 1] = t6 >>> 8, this[r7] = 255 & t6, r7 + 4;
      }, u$1$1.prototype.writeUInt32BE = function(t6, r7, e7) {
        return t6 = +t6, r7 >>>= 0, e7 || C(this, t6, r7, 4, 4294967295, 0), this[r7] = t6 >>> 24, this[r7 + 1] = t6 >>> 16, this[r7 + 2] = t6 >>> 8, this[r7 + 3] = 255 & t6, r7 + 4;
      }, u$1$1.prototype.writeIntLE = function(t6, r7, e7, n7) {
        if (t6 = +t6, r7 >>>= 0, !n7) {
          var i6 = Math.pow(2, 8 * e7 - 1);
          C(this, t6, r7, e7, i6 - 1, -i6);
        }
        var o7 = 0, f6 = 1, u6 = 0;
        for (this[r7] = 255 & t6; ++o7 < e7 && (f6 *= 256); )
          t6 < 0 && 0 === u6 && 0 !== this[r7 + o7 - 1] && (u6 = 1), this[r7 + o7] = (t6 / f6 >> 0) - u6 & 255;
        return r7 + e7;
      }, u$1$1.prototype.writeIntBE = function(t6, r7, e7, n7) {
        if (t6 = +t6, r7 >>>= 0, !n7) {
          var i6 = Math.pow(2, 8 * e7 - 1);
          C(this, t6, r7, e7, i6 - 1, -i6);
        }
        var o7 = e7 - 1, f6 = 1, u6 = 0;
        for (this[r7 + o7] = 255 & t6; --o7 >= 0 && (f6 *= 256); )
          t6 < 0 && 0 === u6 && 0 !== this[r7 + o7 + 1] && (u6 = 1), this[r7 + o7] = (t6 / f6 >> 0) - u6 & 255;
        return r7 + e7;
      }, u$1$1.prototype.writeInt8 = function(t6, r7, e7) {
        return t6 = +t6, r7 >>>= 0, e7 || C(this, t6, r7, 1, 127, -128), t6 < 0 && (t6 = 255 + t6 + 1), this[r7] = 255 & t6, r7 + 1;
      }, u$1$1.prototype.writeInt16LE = function(t6, r7, e7) {
        return t6 = +t6, r7 >>>= 0, e7 || C(this, t6, r7, 2, 32767, -32768), this[r7] = 255 & t6, this[r7 + 1] = t6 >>> 8, r7 + 2;
      }, u$1$1.prototype.writeInt16BE = function(t6, r7, e7) {
        return t6 = +t6, r7 >>>= 0, e7 || C(this, t6, r7, 2, 32767, -32768), this[r7] = t6 >>> 8, this[r7 + 1] = 255 & t6, r7 + 2;
      }, u$1$1.prototype.writeInt32LE = function(t6, r7, e7) {
        return t6 = +t6, r7 >>>= 0, e7 || C(this, t6, r7, 4, 2147483647, -2147483648), this[r7] = 255 & t6, this[r7 + 1] = t6 >>> 8, this[r7 + 2] = t6 >>> 16, this[r7 + 3] = t6 >>> 24, r7 + 4;
      }, u$1$1.prototype.writeInt32BE = function(t6, r7, e7) {
        return t6 = +t6, r7 >>>= 0, e7 || C(this, t6, r7, 4, 2147483647, -2147483648), t6 < 0 && (t6 = 4294967295 + t6 + 1), this[r7] = t6 >>> 24, this[r7 + 1] = t6 >>> 16, this[r7 + 2] = t6 >>> 8, this[r7 + 3] = 255 & t6, r7 + 4;
      }, u$1$1.prototype.writeFloatLE = function(t6, r7, e7) {
        return k(this, t6, r7, true, e7);
      }, u$1$1.prototype.writeFloatBE = function(t6, r7, e7) {
        return k(this, t6, r7, false, e7);
      }, u$1$1.prototype.writeDoubleLE = function(t6, r7, e7) {
        return M(this, t6, r7, true, e7);
      }, u$1$1.prototype.writeDoubleBE = function(t6, r7, e7) {
        return M(this, t6, r7, false, e7);
      }, u$1$1.prototype.copy = function(t6, r7, e7, n7) {
        if (!u$1$1.isBuffer(t6))
          throw new TypeError("argument should be a Buffer");
        if (e7 || (e7 = 0), n7 || 0 === n7 || (n7 = this.length), r7 >= t6.length && (r7 = t6.length), r7 || (r7 = 0), n7 > 0 && n7 < e7 && (n7 = e7), n7 === e7)
          return 0;
        if (0 === t6.length || 0 === this.length)
          return 0;
        if (r7 < 0)
          throw new RangeError("targetStart out of bounds");
        if (e7 < 0 || e7 >= this.length)
          throw new RangeError("Index out of range");
        if (n7 < 0)
          throw new RangeError("sourceEnd out of bounds");
        n7 > this.length && (n7 = this.length), t6.length - r7 < n7 - e7 && (n7 = t6.length - r7 + e7);
        var i6 = n7 - e7;
        if (this === t6 && "function" == typeof Uint8Array.prototype.copyWithin)
          this.copyWithin(r7, e7, n7);
        else if (this === t6 && e7 < r7 && r7 < n7)
          for (var o7 = i6 - 1; o7 >= 0; --o7)
            t6[o7 + r7] = this[o7 + e7];
        else
          Uint8Array.prototype.set.call(t6, this.subarray(e7, n7), r7);
        return i6;
      }, u$1$1.prototype.fill = function(t6, r7, e7, n7) {
        if ("string" == typeof t6) {
          if ("string" == typeof r7 ? (n7 = r7, r7 = 0, e7 = this.length) : "string" == typeof e7 && (n7 = e7, e7 = this.length), void 0 !== n7 && "string" != typeof n7)
            throw new TypeError("encoding must be a string");
          if ("string" == typeof n7 && !u$1$1.isEncoding(n7))
            throw new TypeError("Unknown encoding: " + n7);
          if (1 === t6.length) {
            var i6 = t6.charCodeAt(0);
            ("utf8" === n7 && i6 < 128 || "latin1" === n7) && (t6 = i6);
          }
        } else
          "number" == typeof t6 ? t6 &= 255 : "boolean" == typeof t6 && (t6 = Number(t6));
        if (r7 < 0 || this.length < r7 || this.length < e7)
          throw new RangeError("Out of range index");
        if (e7 <= r7)
          return this;
        var o7;
        if (r7 >>>= 0, e7 = void 0 === e7 ? this.length : e7 >>> 0, t6 || (t6 = 0), "number" == typeof t6)
          for (o7 = r7; o7 < e7; ++o7)
            this[o7] = t6;
        else {
          var f6 = u$1$1.isBuffer(t6) ? t6 : u$1$1.from(t6, n7), s5 = f6.length;
          if (0 === s5)
            throw new TypeError('The value "' + t6 + '" is invalid for argument "value"');
          for (o7 = 0; o7 < e7 - r7; ++o7)
            this[o7 + r7] = f6[o7 % s5];
        }
        return this;
      };
      j = /[^+/0-9A-Za-z-_]/g;
      Y = function() {
        for (var t6 = new Array(256), r7 = 0; r7 < 16; ++r7)
          for (var e7 = 16 * r7, n7 = 0; n7 < 16; ++n7)
            t6[e7 + n7] = "0123456789abcdef"[r7] + "0123456789abcdef"[n7];
        return t6;
      }();
      e$1$1.Buffer;
      e$1$1.INSPECT_MAX_BYTES;
      e$1$1.kMaxLength;
      e2 = {};
      n2 = e$1$1;
      o2 = n2.Buffer;
      o2.from && o2.alloc && o2.allocUnsafe && o2.allocUnsafeSlow ? e2 = n2 : (t2(n2, e2), e2.Buffer = f2), f2.prototype = Object.create(o2.prototype), t2(o2, f2), f2.from = function(r7, e7, n7) {
        if ("number" == typeof r7)
          throw new TypeError("Argument must not be a number");
        return o2(r7, e7, n7);
      }, f2.alloc = function(r7, e7, n7) {
        if ("number" != typeof r7)
          throw new TypeError("Argument must be a number");
        var t6 = o2(r7);
        return void 0 !== e7 ? "string" == typeof n7 ? t6.fill(e7, n7) : t6.fill(e7) : t6.fill(0), t6;
      }, f2.allocUnsafe = function(r7) {
        if ("number" != typeof r7)
          throw new TypeError("Argument must be a number");
        return o2(r7);
      }, f2.allocUnsafeSlow = function(r7) {
        if ("number" != typeof r7)
          throw new TypeError("Argument must be a number");
        return n2.SlowBuffer(r7);
      };
      u2 = e2;
      e$1 = {};
      s2 = u2.Buffer;
      i2 = s2.isEncoding || function(t6) {
        switch ((t6 = "" + t6) && t6.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      e$1.StringDecoder = a2, a2.prototype.write = function(t6) {
        if (0 === t6.length)
          return "";
        var e7, s5;
        if (this.lastNeed) {
          if (void 0 === (e7 = this.fillLast(t6)))
            return "";
          s5 = this.lastNeed, this.lastNeed = 0;
        } else
          s5 = 0;
        return s5 < t6.length ? e7 ? e7 + this.text(t6, s5) : this.text(t6, s5) : e7 || "";
      }, a2.prototype.end = function(t6) {
        var e7 = t6 && t6.length ? this.write(t6) : "";
        return this.lastNeed ? e7 + "\uFFFD" : e7;
      }, a2.prototype.text = function(t6, e7) {
        var s5 = function(t7, e8, s6) {
          var i7 = e8.length - 1;
          if (i7 < s6)
            return 0;
          var a6 = r2(e8[i7]);
          if (a6 >= 0)
            return a6 > 0 && (t7.lastNeed = a6 - 1), a6;
          if (--i7 < s6 || -2 === a6)
            return 0;
          if ((a6 = r2(e8[i7])) >= 0)
            return a6 > 0 && (t7.lastNeed = a6 - 2), a6;
          if (--i7 < s6 || -2 === a6)
            return 0;
          if ((a6 = r2(e8[i7])) >= 0)
            return a6 > 0 && (2 === a6 ? a6 = 0 : t7.lastNeed = a6 - 3), a6;
          return 0;
        }(this, t6, e7);
        if (!this.lastNeed)
          return t6.toString("utf8", e7);
        this.lastTotal = s5;
        var i6 = t6.length - (s5 - this.lastNeed);
        return t6.copy(this.lastChar, 0, i6), t6.toString("utf8", e7, i6);
      }, a2.prototype.fillLast = function(t6) {
        if (this.lastNeed <= t6.length)
          return t6.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t6.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t6.length), this.lastNeed -= t6.length;
      };
      e$1.StringDecoder;
      e$1.StringDecoder;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/string_decoder.js
  var string_decoder_exports = {};
  __export(string_decoder_exports, {
    StringDecoder: () => StringDecoder,
    default: () => e$1
  });
  var StringDecoder;
  var init_string_decoder = __esm({
    "node_modules/@jspm/core/nodelibs/browser/string_decoder.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      init_chunk_4ccc3a29();
      init_chunk_4ccc3a29();
      StringDecoder = e$1.StringDecoder;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/from.js
  var require_from = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/from.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var process3 = require_browser2();
      var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;
      function from(Readable, iterable, opts) {
        let iterator;
        if (typeof iterable === "string" || iterable instanceof Buffer3) {
          return new Readable({
            objectMode: true,
            ...opts,
            read() {
              this.push(iterable);
              this.push(null);
            }
          });
        }
        let isAsync;
        if (iterable && iterable[SymbolAsyncIterator]) {
          isAsync = true;
          iterator = iterable[SymbolAsyncIterator]();
        } else if (iterable && iterable[SymbolIterator]) {
          isAsync = false;
          iterator = iterable[SymbolIterator]();
        } else {
          throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
        }
        const readable = new Readable({
          objectMode: true,
          highWaterMark: 1,
          // TODO(ronag): What options should be allowed?
          ...opts
        });
        let reading = false;
        readable._read = function() {
          if (!reading) {
            reading = true;
            next();
          }
        };
        readable._destroy = function(error, cb) {
          PromisePrototypeThen(
            close(error),
            () => process3.nextTick(cb, error),
            // nextTick is here in case cb throws
            (e7) => process3.nextTick(cb, e7 || error)
          );
        };
        async function close(error) {
          const hadError = error !== void 0 && error !== null;
          const hasThrow = typeof iterator.throw === "function";
          if (hadError && hasThrow) {
            const { value, done } = await iterator.throw(error);
            await value;
            if (done) {
              return;
            }
          }
          if (typeof iterator.return === "function") {
            const { value } = await iterator.return();
            await value;
          }
        }
        async function next() {
          for (; ; ) {
            try {
              const { value, done } = isAsync ? await iterator.next() : iterator.next();
              if (done) {
                readable.push(null);
              } else {
                const res = value && typeof value.then === "function" ? await value : value;
                if (res === null) {
                  reading = false;
                  throw new ERR_STREAM_NULL_VALUES();
                } else if (readable.push(res)) {
                  continue;
                } else {
                  reading = false;
                }
              }
            } catch (err) {
              readable.destroy(err);
            }
            break;
          }
        }
        return readable;
      }
      module.exports = from;
    }
  });

  // node_modules/readable-stream/lib/internal/streams/readable.js
  var require_readable = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/readable.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var process3 = require_browser2();
      var {
        ArrayPrototypeIndexOf,
        NumberIsInteger,
        NumberIsNaN,
        NumberParseInt,
        ObjectDefineProperties,
        ObjectKeys,
        ObjectSetPrototypeOf,
        Promise: Promise2,
        SafeSet,
        SymbolAsyncIterator,
        Symbol: Symbol2
      } = require_primordials();
      module.exports = Readable;
      Readable.ReadableState = ReadableState;
      var { EventEmitter: EE } = (init_events(), __toCommonJS(events_exports));
      var { Stream, prependListener: prependListener2 } = require_legacy();
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var { addAbortSignal } = require_add_abort_signal();
      var eos = require_end_of_stream();
      var debug = require_util().debuglog("stream", (fn) => {
        debug = fn;
      });
      var BufferList = require_buffer_list();
      var destroyImpl = require_destroy();
      var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
      var {
        aggregateTwoErrors,
        codes: {
          ERR_INVALID_ARG_TYPE,
          ERR_METHOD_NOT_IMPLEMENTED,
          ERR_OUT_OF_RANGE,
          ERR_STREAM_PUSH_AFTER_EOF,
          ERR_STREAM_UNSHIFT_AFTER_END_EVENT
        }
      } = require_errors();
      var { validateObject } = require_validators();
      var kPaused = Symbol2("kPaused");
      var { StringDecoder: StringDecoder2 } = (init_string_decoder(), __toCommonJS(string_decoder_exports));
      var from = require_from();
      ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
      ObjectSetPrototypeOf(Readable, Stream);
      var nop = () => {
      };
      var { errorOrDestroy } = destroyImpl;
      function ReadableState(options, stream, isDuplex) {
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof require_duplex();
        this.objectMode = !!(options && options.objectMode);
        if (isDuplex)
          this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
        this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = [];
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.constructed = true;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this[kPaused] = null;
        this.errorEmitted = false;
        this.emitClose = !options || options.emitClose !== false;
        this.autoDestroy = !options || options.autoDestroy !== false;
        this.destroyed = false;
        this.errored = null;
        this.closed = false;
        this.closeEmitted = false;
        this.defaultEncoding = options && options.defaultEncoding || "utf8";
        this.awaitDrainWriters = null;
        this.multiAwaitDrain = false;
        this.readingMore = false;
        this.dataEmitted = false;
        this.decoder = null;
        this.encoding = null;
        if (options && options.encoding) {
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        if (!(this instanceof Readable))
          return new Readable(options);
        const isDuplex = this instanceof require_duplex();
        this._readableState = new ReadableState(options, this, isDuplex);
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.construct === "function")
            this._construct = options.construct;
          if (options.signal && !isDuplex)
            addAbortSignal(options.signal, this);
        }
        Stream.call(this, options);
        destroyImpl.construct(this, () => {
          if (this._readableState.needReadable) {
            maybeReadMore(this, this._readableState);
          }
        });
      }
      Readable.prototype.destroy = destroyImpl.destroy;
      Readable.prototype._undestroy = destroyImpl.undestroy;
      Readable.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable.prototype[EE.captureRejectionSymbol] = function(err) {
        this.destroy(err);
      };
      Readable.prototype.push = function(chunk, encoding) {
        return readableAddChunk(this, chunk, encoding, false);
      };
      Readable.prototype.unshift = function(chunk, encoding) {
        return readableAddChunk(this, chunk, encoding, true);
      };
      function readableAddChunk(stream, chunk, encoding, addToFront) {
        debug("readableAddChunk", chunk);
        const state = stream._readableState;
        let err;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (state.encoding !== encoding) {
              if (addToFront && state.encoding) {
                chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
              } else {
                chunk = Buffer3.from(chunk, encoding);
                encoding = "";
              }
            }
          } else if (chunk instanceof Buffer3) {
            encoding = "";
          } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = "";
          } else if (chunk != null) {
            err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
          }
        }
        if (err) {
          errorOrDestroy(stream, err);
        } else if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else if (state.destroyed || state.errored)
              return false;
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed || state.errored) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
          if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
          } else {
            state.awaitDrainWriters = null;
          }
          state.dataEmitted = true;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      Readable.prototype.isPaused = function() {
        const state = this._readableState;
        return state[kPaused] === true || state.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        const decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        const buffer = this._readableState.buffer;
        let content = "";
        for (const data of buffer) {
          content += decoder.write(data);
        }
        buffer.clear();
        if (content !== "")
          buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n7) {
        if (n7 > MAX_HWM) {
          throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n7);
        } else {
          n7--;
          n7 |= n7 >>> 1;
          n7 |= n7 >>> 2;
          n7 |= n7 >>> 4;
          n7 |= n7 >>> 8;
          n7 |= n7 >>> 16;
          n7++;
        }
        return n7;
      }
      function howMuchToRead(n7, state) {
        if (n7 <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (NumberIsNaN(n7)) {
          if (state.flowing && state.length)
            return state.buffer.first().length;
          return state.length;
        }
        if (n7 <= state.length)
          return n7;
        return state.ended ? state.length : 0;
      }
      Readable.prototype.read = function(n7) {
        debug("read", n7);
        if (n7 === void 0) {
          n7 = NaN;
        } else if (!NumberIsInteger(n7)) {
          n7 = NumberParseInt(n7, 10);
        }
        const state = this._readableState;
        const nOrig = n7;
        if (n7 > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n7);
        if (n7 !== 0)
          state.emittedReadable = false;
        if (n7 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n7 = howMuchToRead(n7, state);
        if (n7 === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        let doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n7 < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
          doRead = false;
          debug("reading, ended or constructing", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          try {
            this._read(state.highWaterMark);
          } catch (err) {
            errorOrDestroy(this, err);
          }
          state.sync = false;
          if (!state.reading)
            n7 = howMuchToRead(nOrig, state);
        }
        let ret;
        if (n7 > 0)
          ret = fromList(n7, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n7 = 0;
        } else {
          state.length -= n7;
          if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
          } else {
            state.awaitDrainWriters = null;
          }
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n7 && state.ended)
            endReadable(this);
        }
        if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
          state.dataEmitted = true;
          this.emit("data", ret);
        }
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          const chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
      function emitReadable(stream) {
        const state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          process3.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        const state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && !state.errored && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore && state.constructed) {
          state.readingMore = true;
          process3.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          const len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n7) {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        const src = this;
        const state = this._readableState;
        if (state.pipes.length === 1) {
          if (!state.multiAwaitDrain) {
            state.multiAwaitDrain = true;
            state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
          }
        }
        state.pipes.push(dest);
        debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
        const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process3.stdout && dest !== process3.stderr;
        const endFn = doEnd ? onend : unpipe;
        if (state.endEmitted)
          process3.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        let ondrain;
        let cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          if (ondrain) {
            dest.removeListener("drain", ondrain);
          }
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        function pause() {
          if (!cleanedUp) {
            if (state.pipes.length === 1 && state.pipes[0] === dest) {
              debug("false write response, pause", 0);
              state.awaitDrainWriters = dest;
              state.multiAwaitDrain = false;
            } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
              debug("false write response, pause", state.awaitDrainWriters.size);
              state.awaitDrainWriters.add(dest);
            }
            src.pause();
          }
          if (!ondrain) {
            ondrain = pipeOnDrain(src, dest);
            dest.on("drain", ondrain);
          }
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          const ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (dest.listenerCount("error") === 0) {
            const s5 = dest._writableState || dest._readableState;
            if (s5 && !s5.errorEmitted) {
              errorOrDestroy(dest, er);
            } else {
              dest.emit("error", er);
            }
          }
        }
        prependListener2(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (dest.writableNeedDrain === true) {
          if (state.flowing) {
            pause();
          }
        } else if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src, dest) {
        return function pipeOnDrainFunctionResult() {
          const state = src._readableState;
          if (state.awaitDrainWriters === dest) {
            debug("pipeOnDrain", 1);
            state.awaitDrainWriters = null;
          } else if (state.multiAwaitDrain) {
            debug("pipeOnDrain", state.awaitDrainWriters.size);
            state.awaitDrainWriters.delete(dest);
          }
          if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
            src.resume();
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        const state = this._readableState;
        const unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipes.length === 0)
          return this;
        if (!dest) {
          const dests = state.pipes;
          state.pipes = [];
          this.pause();
          for (let i6 = 0; i6 < dests.length; i6++)
            dests[i6].emit("unpipe", this, {
              hasUnpiped: false
            });
          return this;
        }
        const index = ArrayPrototypeIndexOf(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        if (state.pipes.length === 0)
          this.pause();
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        const res = Stream.prototype.on.call(this, ev, fn);
        const state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              process3.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      Readable.prototype.removeListener = function(ev, fn) {
        const res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process3.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable.prototype.off = Readable.prototype.removeListener;
      Readable.prototype.removeAllListeners = function(ev) {
        const res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process3.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        const state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && state[kPaused] === false) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        } else if (!state.readableListening) {
          state.flowing = null;
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable.prototype.resume = function() {
        const state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state[kPaused] = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process3.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState[kPaused] = true;
        return this;
      };
      function flow(stream) {
        const state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null)
          ;
      }
      Readable.prototype.wrap = function(stream) {
        let paused = false;
        stream.on("data", (chunk) => {
          if (!this.push(chunk) && stream.pause) {
            paused = true;
            stream.pause();
          }
        });
        stream.on("end", () => {
          this.push(null);
        });
        stream.on("error", (err) => {
          errorOrDestroy(this, err);
        });
        stream.on("close", () => {
          this.destroy();
        });
        stream.on("destroy", () => {
          this.destroy();
        });
        this._read = () => {
          if (paused && stream.resume) {
            paused = false;
            stream.resume();
          }
        };
        const streamKeys = ObjectKeys(stream);
        for (let j2 = 1; j2 < streamKeys.length; j2++) {
          const i6 = streamKeys[j2];
          if (this[i6] === void 0 && typeof stream[i6] === "function") {
            this[i6] = stream[i6].bind(stream);
          }
        }
        return this;
      };
      Readable.prototype[SymbolAsyncIterator] = function() {
        return streamToAsyncIterator(this);
      };
      Readable.prototype.iterator = function(options) {
        if (options !== void 0) {
          validateObject(options, "options");
        }
        return streamToAsyncIterator(this, options);
      };
      function streamToAsyncIterator(stream, options) {
        if (typeof stream.read !== "function") {
          stream = Readable.wrap(stream, {
            objectMode: true
          });
        }
        const iter = createAsyncIterator(stream, options);
        iter.stream = stream;
        return iter;
      }
      async function* createAsyncIterator(stream, options) {
        let callback = nop;
        function next(resolve2) {
          if (this === stream) {
            callback();
            callback = nop;
          } else {
            callback = resolve2;
          }
        }
        stream.on("readable", next);
        let error;
        const cleanup = eos(
          stream,
          {
            writable: false
          },
          (err) => {
            error = err ? aggregateTwoErrors(error, err) : null;
            callback();
            callback = nop;
          }
        );
        try {
          while (true) {
            const chunk = stream.destroyed ? null : stream.read();
            if (chunk !== null) {
              yield chunk;
            } else if (error) {
              throw error;
            } else if (error === null) {
              return;
            } else {
              await new Promise2(next);
            }
          }
        } catch (err) {
          error = aggregateTwoErrors(error, err);
          throw error;
        } finally {
          if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
            destroyImpl.destroyer(stream, null);
          } else {
            stream.off("readable", next);
            cleanup();
          }
        }
      }
      ObjectDefineProperties(Readable.prototype, {
        readable: {
          __proto__: null,
          get() {
            const r7 = this._readableState;
            return !!r7 && r7.readable !== false && !r7.destroyed && !r7.errorEmitted && !r7.endEmitted;
          },
          set(val) {
            if (this._readableState) {
              this._readableState.readable = !!val;
            }
          }
        },
        readableDidRead: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return this._readableState.dataEmitted;
          }
        },
        readableAborted: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
          }
        },
        readableHighWaterMark: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return this._readableState.highWaterMark;
          }
        },
        readableBuffer: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return this._readableState && this._readableState.buffer;
          }
        },
        readableFlowing: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return this._readableState.flowing;
          },
          set: function(state) {
            if (this._readableState) {
              this._readableState.flowing = state;
            }
          }
        },
        readableLength: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState.length;
          }
        },
        readableObjectMode: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.objectMode : false;
          }
        },
        readableEncoding: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.encoding : null;
          }
        },
        errored: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.errored : null;
          }
        },
        closed: {
          __proto__: null,
          get() {
            return this._readableState ? this._readableState.closed : false;
          }
        },
        destroyed: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.destroyed : false;
          },
          set(value) {
            if (!this._readableState) {
              return;
            }
            this._readableState.destroyed = value;
          }
        },
        readableEnded: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._readableState ? this._readableState.endEmitted : false;
          }
        }
      });
      ObjectDefineProperties(ReadableState.prototype, {
        // Legacy getter for `pipesCount`.
        pipesCount: {
          __proto__: null,
          get() {
            return this.pipes.length;
          }
        },
        // Legacy property for `paused`.
        paused: {
          __proto__: null,
          get() {
            return this[kPaused] !== false;
          },
          set(value) {
            this[kPaused] = !!value;
          }
        }
      });
      Readable._fromList = fromList;
      function fromList(n7, state) {
        if (state.length === 0)
          return null;
        let ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n7 || n7 >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n7, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        const state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process3.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.emit("end");
          if (stream.writable && stream.allowHalfOpen === false) {
            process3.nextTick(endWritableNT, stream);
          } else if (state.autoDestroy) {
            const wState = stream._writableState;
            const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
            // if writable is explicitly set to false.
            (wState.finished || wState.writable === false);
            if (autoDestroy) {
              stream.destroy();
            }
          }
        }
      }
      function endWritableNT(stream) {
        const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
        if (writable) {
          stream.end();
        }
      }
      Readable.from = function(iterable, opts) {
        return from(Readable, iterable, opts);
      };
      var webStreamsAdapters;
      function lazyWebStreams() {
        if (webStreamsAdapters === void 0)
          webStreamsAdapters = {};
        return webStreamsAdapters;
      }
      Readable.fromWeb = function(readableStream, options) {
        return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
      };
      Readable.toWeb = function(streamReadable, options) {
        return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
      };
      Readable.wrap = function(src, options) {
        var _ref, _src$readableObjectMo;
        return new Readable({
          objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
          ...options,
          destroy(err, callback) {
            destroyImpl.destroyer(src, err);
            callback(err);
          }
        }).wrap(src);
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/writable.js
  var require_writable = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/writable.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var process3 = require_browser2();
      var {
        ArrayPrototypeSlice,
        Error: Error2,
        FunctionPrototypeSymbolHasInstance,
        ObjectDefineProperty,
        ObjectDefineProperties,
        ObjectSetPrototypeOf,
        StringPrototypeToLowerCase,
        Symbol: Symbol2,
        SymbolHasInstance
      } = require_primordials();
      module.exports = Writable;
      Writable.WritableState = WritableState;
      var { EventEmitter: EE } = (init_events(), __toCommonJS(events_exports));
      var Stream = require_legacy().Stream;
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var destroyImpl = require_destroy();
      var { addAbortSignal } = require_add_abort_signal();
      var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
      var {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_MULTIPLE_CALLBACK,
        ERR_STREAM_CANNOT_PIPE,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_ALREADY_FINISHED,
        ERR_STREAM_NULL_VALUES,
        ERR_STREAM_WRITE_AFTER_END,
        ERR_UNKNOWN_ENCODING
      } = require_errors().codes;
      var { errorOrDestroy } = destroyImpl;
      ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
      ObjectSetPrototypeOf(Writable, Stream);
      function nop() {
      }
      var kOnFinished = Symbol2("kOnFinished");
      function WritableState(options, stream, isDuplex) {
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof require_duplex();
        this.objectMode = !!(options && options.objectMode);
        if (isDuplex)
          this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
        this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        const noDecode = !!(options && options.decodeStrings === false);
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options && options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = onwrite.bind(void 0, stream);
        this.writecb = null;
        this.writelen = 0;
        this.afterWriteTickInfo = null;
        resetBuffer(this);
        this.pendingcb = 0;
        this.constructed = true;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = !options || options.emitClose !== false;
        this.autoDestroy = !options || options.autoDestroy !== false;
        this.errored = null;
        this.closed = false;
        this.closeEmitted = false;
        this[kOnFinished] = [];
      }
      function resetBuffer(state) {
        state.buffered = [];
        state.bufferedIndex = 0;
        state.allBuffers = true;
        state.allNoop = true;
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
      };
      ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
        __proto__: null,
        get() {
          return this.buffered.length - this.bufferedIndex;
        }
      });
      function Writable(options) {
        const isDuplex = this instanceof require_duplex();
        if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
          return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
          if (typeof options.construct === "function")
            this._construct = options.construct;
          if (options.signal)
            addAbortSignal(options.signal, this);
        }
        Stream.call(this, options);
        destroyImpl.construct(this, () => {
          const state = this._writableState;
          if (!state.writing) {
            clearBuffer(this, state);
          }
          finishMaybe(this, state);
        });
      }
      ObjectDefineProperty(Writable, SymbolHasInstance, {
        __proto__: null,
        value: function(object) {
          if (FunctionPrototypeSymbolHasInstance(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function _write(stream, chunk, encoding, cb) {
        const state = stream._writableState;
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = state.defaultEncoding;
        } else {
          if (!encoding)
            encoding = state.defaultEncoding;
          else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding))
            throw new ERR_UNKNOWN_ENCODING(encoding);
          if (typeof cb !== "function")
            cb = nop;
        }
        if (chunk === null) {
          throw new ERR_STREAM_NULL_VALUES();
        } else if (!state.objectMode) {
          if (typeof chunk === "string") {
            if (state.decodeStrings !== false) {
              chunk = Buffer3.from(chunk, encoding);
              encoding = "buffer";
            }
          } else if (chunk instanceof Buffer3) {
            encoding = "buffer";
          } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = "buffer";
          } else {
            throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
          }
        }
        let err;
        if (state.ending) {
          err = new ERR_STREAM_WRITE_AFTER_END();
        } else if (state.destroyed) {
          err = new ERR_STREAM_DESTROYED("write");
        }
        if (err) {
          process3.nextTick(cb, err);
          errorOrDestroy(stream, err, true);
          return err;
        }
        state.pendingcb++;
        return writeOrBuffer(stream, state, chunk, encoding, cb);
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        return _write(this, chunk, encoding, cb) === true;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        const state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string")
          encoding = StringPrototypeToLowerCase(encoding);
        if (!Buffer3.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      function writeOrBuffer(stream, state, chunk, encoding, callback) {
        const len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        const ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked || state.errored || !state.constructed) {
          state.buffered.push({
            chunk,
            encoding,
            callback
          });
          if (state.allBuffers && encoding !== "buffer") {
            state.allBuffers = false;
          }
          if (state.allNoop && callback !== nop) {
            state.allNoop = false;
          }
        } else {
          state.writelen = len;
          state.writecb = callback;
          state.writing = true;
          state.sync = true;
          stream._write(chunk, encoding, state.onwrite);
          state.sync = false;
        }
        return ret && !state.errored && !state.destroyed;
      }
      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, er, cb) {
        --state.pendingcb;
        cb(er);
        errorBuffer(state);
        errorOrDestroy(stream, er);
      }
      function onwrite(stream, er) {
        const state = stream._writableState;
        const sync = state.sync;
        const cb = state.writecb;
        if (typeof cb !== "function") {
          errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
          return;
        }
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
        if (er) {
          er.stack;
          if (!state.errored) {
            state.errored = er;
          }
          if (stream._readableState && !stream._readableState.errored) {
            stream._readableState.errored = er;
          }
          if (sync) {
            process3.nextTick(onwriteError, stream, state, er, cb);
          } else {
            onwriteError(stream, state, er, cb);
          }
        } else {
          if (state.buffered.length > state.bufferedIndex) {
            clearBuffer(stream, state);
          }
          if (sync) {
            if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
              state.afterWriteTickInfo.count++;
            } else {
              state.afterWriteTickInfo = {
                count: 1,
                cb,
                stream,
                state
              };
              process3.nextTick(afterWriteTick, state.afterWriteTickInfo);
            }
          } else {
            afterWrite(stream, state, 1, cb);
          }
        }
      }
      function afterWriteTick({ stream, state, count, cb }) {
        state.afterWriteTickInfo = null;
        return afterWrite(stream, state, count, cb);
      }
      function afterWrite(stream, state, count, cb) {
        const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
        if (needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
        while (count-- > 0) {
          state.pendingcb--;
          cb();
        }
        if (state.destroyed) {
          errorBuffer(state);
        }
        finishMaybe(stream, state);
      }
      function errorBuffer(state) {
        if (state.writing) {
          return;
        }
        for (let n7 = state.bufferedIndex; n7 < state.buffered.length; ++n7) {
          var _state$errored;
          const { chunk, callback } = state.buffered[n7];
          const len = state.objectMode ? 1 : chunk.length;
          state.length -= len;
          callback(
            (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
          );
        }
        const onfinishCallbacks = state[kOnFinished].splice(0);
        for (let i6 = 0; i6 < onfinishCallbacks.length; i6++) {
          var _state$errored2;
          onfinishCallbacks[i6](
            (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
          );
        }
        resetBuffer(state);
      }
      function clearBuffer(stream, state) {
        if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
          return;
        }
        const { buffered, bufferedIndex, objectMode } = state;
        const bufferedLength = buffered.length - bufferedIndex;
        if (!bufferedLength) {
          return;
        }
        let i6 = bufferedIndex;
        state.bufferProcessing = true;
        if (bufferedLength > 1 && stream._writev) {
          state.pendingcb -= bufferedLength - 1;
          const callback = state.allNoop ? nop : (err) => {
            for (let n7 = i6; n7 < buffered.length; ++n7) {
              buffered[n7].callback(err);
            }
          };
          const chunks = state.allNoop && i6 === 0 ? buffered : ArrayPrototypeSlice(buffered, i6);
          chunks.allBuffers = state.allBuffers;
          doWrite(stream, state, true, state.length, chunks, "", callback);
          resetBuffer(state);
        } else {
          do {
            const { chunk, encoding, callback } = buffered[i6];
            buffered[i6++] = null;
            const len = objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, callback);
          } while (i6 < buffered.length && !state.writing);
          if (i6 === buffered.length) {
            resetBuffer(state);
          } else if (i6 > 256) {
            buffered.splice(0, i6);
            state.bufferedIndex = 0;
          } else {
            state.bufferedIndex = i6;
          }
        }
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        if (this._writev) {
          this._writev(
            [
              {
                chunk,
                encoding
              }
            ],
            cb
          );
        } else {
          throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
        }
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        const state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        let err;
        if (chunk !== null && chunk !== void 0) {
          const ret = _write(this, chunk, encoding);
          if (ret instanceof Error2) {
            err = ret;
          }
        }
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (err) {
        } else if (!state.errored && !state.ending) {
          state.ending = true;
          finishMaybe(this, state, true);
          state.ended = true;
        } else if (state.finished) {
          err = new ERR_STREAM_ALREADY_FINISHED("end");
        } else if (state.destroyed) {
          err = new ERR_STREAM_DESTROYED("end");
        }
        if (typeof cb === "function") {
          if (err || state.finished) {
            process3.nextTick(cb, err);
          } else {
            state[kOnFinished].push(cb);
          }
        }
        return this;
      };
      function needFinish(state) {
        return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
      }
      function callFinal(stream, state) {
        let called = false;
        function onFinish(err) {
          if (called) {
            errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
            return;
          }
          called = true;
          state.pendingcb--;
          if (err) {
            const onfinishCallbacks = state[kOnFinished].splice(0);
            for (let i6 = 0; i6 < onfinishCallbacks.length; i6++) {
              onfinishCallbacks[i6](err);
            }
            errorOrDestroy(stream, err, state.sync);
          } else if (needFinish(state)) {
            state.prefinished = true;
            stream.emit("prefinish");
            state.pendingcb++;
            process3.nextTick(finish, stream, state);
          }
        }
        state.sync = true;
        state.pendingcb++;
        try {
          stream._final(onFinish);
        } catch (err) {
          onFinish(err);
        }
        state.sync = false;
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.finalCalled = true;
            callFinal(stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state, sync) {
        if (needFinish(state)) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            if (sync) {
              state.pendingcb++;
              process3.nextTick(
                (stream2, state2) => {
                  if (needFinish(state2)) {
                    finish(stream2, state2);
                  } else {
                    state2.pendingcb--;
                  }
                },
                stream,
                state
              );
            } else if (needFinish(state)) {
              state.pendingcb++;
              finish(stream, state);
            }
          }
        }
      }
      function finish(stream, state) {
        state.pendingcb--;
        state.finished = true;
        const onfinishCallbacks = state[kOnFinished].splice(0);
        for (let i6 = 0; i6 < onfinishCallbacks.length; i6++) {
          onfinishCallbacks[i6]();
        }
        stream.emit("finish");
        if (state.autoDestroy) {
          const rState = stream._readableState;
          const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
          // if readable is explicitly set to false.
          (rState.endEmitted || rState.readable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
      ObjectDefineProperties(Writable.prototype, {
        closed: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.closed : false;
          }
        },
        destroyed: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.destroyed : false;
          },
          set(value) {
            if (this._writableState) {
              this._writableState.destroyed = value;
            }
          }
        },
        writable: {
          __proto__: null,
          get() {
            const w2 = this._writableState;
            return !!w2 && w2.writable !== false && !w2.destroyed && !w2.errored && !w2.ending && !w2.ended;
          },
          set(val) {
            if (this._writableState) {
              this._writableState.writable = !!val;
            }
          }
        },
        writableFinished: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.finished : false;
          }
        },
        writableObjectMode: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.objectMode : false;
          }
        },
        writableBuffer: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.getBuffer();
          }
        },
        writableEnded: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.ending : false;
          }
        },
        writableNeedDrain: {
          __proto__: null,
          get() {
            const wState = this._writableState;
            if (!wState)
              return false;
            return !wState.destroyed && !wState.ending && wState.needDrain;
          }
        },
        writableHighWaterMark: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.highWaterMark;
          }
        },
        writableCorked: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.corked : 0;
          }
        },
        writableLength: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.length;
          }
        },
        errored: {
          __proto__: null,
          enumerable: false,
          get() {
            return this._writableState ? this._writableState.errored : null;
          }
        },
        writableAborted: {
          __proto__: null,
          enumerable: false,
          get: function() {
            return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
          }
        }
      });
      var destroy = destroyImpl.destroy;
      Writable.prototype.destroy = function(err, cb) {
        const state = this._writableState;
        if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
          process3.nextTick(errorBuffer, state);
        }
        destroy.call(this, err, cb);
        return this;
      };
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Writable.prototype[EE.captureRejectionSymbol] = function(err) {
        this.destroy(err);
      };
      var webStreamsAdapters;
      function lazyWebStreams() {
        if (webStreamsAdapters === void 0)
          webStreamsAdapters = {};
        return webStreamsAdapters;
      }
      Writable.fromWeb = function(writableStream, options) {
        return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
      };
      Writable.toWeb = function(streamWritable) {
        return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/duplexify.js
  var require_duplexify = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var process3 = require_browser2();
      var bufferModule = (init_buffer(), __toCommonJS(buffer_exports));
      var {
        isReadable,
        isWritable,
        isIterable,
        isNodeStream,
        isReadableNodeStream,
        isWritableNodeStream,
        isDuplexNodeStream
      } = require_utils();
      var eos = require_end_of_stream();
      var {
        AbortError,
        codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
      } = require_errors();
      var { destroyer } = require_destroy();
      var Duplex = require_duplex();
      var Readable = require_readable();
      var { createDeferredPromise } = require_util();
      var from = require_from();
      var Blob2 = globalThis.Blob || bufferModule.Blob;
      var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b3) {
        return b3 instanceof Blob2;
      } : function isBlob2(b3) {
        return false;
      };
      var AbortController = globalThis.AbortController || require_browser().AbortController;
      var { FunctionPrototypeCall } = require_primordials();
      var Duplexify = class extends Duplex {
        constructor(options) {
          super(options);
          if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
          }
          if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
          }
        }
      };
      module.exports = function duplexify(body, name2) {
        if (isDuplexNodeStream(body)) {
          return body;
        }
        if (isReadableNodeStream(body)) {
          return _duplexify({
            readable: body
          });
        }
        if (isWritableNodeStream(body)) {
          return _duplexify({
            writable: body
          });
        }
        if (isNodeStream(body)) {
          return _duplexify({
            writable: false,
            readable: false
          });
        }
        if (typeof body === "function") {
          const { value, write, final, destroy } = fromAsyncGen(body);
          if (isIterable(value)) {
            return from(Duplexify, value, {
              // TODO (ronag): highWaterMark?
              objectMode: true,
              write,
              final,
              destroy
            });
          }
          const then2 = value === null || value === void 0 ? void 0 : value.then;
          if (typeof then2 === "function") {
            let d4;
            const promise = FunctionPrototypeCall(
              then2,
              value,
              (val) => {
                if (val != null) {
                  throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
                }
              },
              (err) => {
                destroyer(d4, err);
              }
            );
            return d4 = new Duplexify({
              // TODO (ronag): highWaterMark?
              objectMode: true,
              readable: false,
              write,
              final(cb) {
                final(async () => {
                  try {
                    await promise;
                    process3.nextTick(cb, null);
                  } catch (err) {
                    process3.nextTick(cb, err);
                  }
                });
              },
              destroy
            });
          }
          throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name2, value);
        }
        if (isBlob(body)) {
          return duplexify(body.arrayBuffer());
        }
        if (isIterable(body)) {
          return from(Duplexify, body, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            writable: false
          });
        }
        if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
          const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
          const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
          return _duplexify({
            readable,
            writable
          });
        }
        const then = body === null || body === void 0 ? void 0 : body.then;
        if (typeof then === "function") {
          let d4;
          FunctionPrototypeCall(
            then,
            body,
            (val) => {
              if (val != null) {
                d4.push(val);
              }
              d4.push(null);
            },
            (err) => {
              destroyer(d4, err);
            }
          );
          return d4 = new Duplexify({
            objectMode: true,
            writable: false,
            read() {
            }
          });
        }
        throw new ERR_INVALID_ARG_TYPE(
          name2,
          [
            "Blob",
            "ReadableStream",
            "WritableStream",
            "Stream",
            "Iterable",
            "AsyncIterable",
            "Function",
            "{ readable, writable } pair",
            "Promise"
          ],
          body
        );
      };
      function fromAsyncGen(fn) {
        let { promise, resolve: resolve2 } = createDeferredPromise();
        const ac = new AbortController();
        const signal = ac.signal;
        const value = fn(
          async function* () {
            while (true) {
              const _promise = promise;
              promise = null;
              const { chunk, done, cb } = await _promise;
              process3.nextTick(cb);
              if (done)
                return;
              if (signal.aborted)
                throw new AbortError(void 0, {
                  cause: signal.reason
                });
              ({ promise, resolve: resolve2 } = createDeferredPromise());
              yield chunk;
            }
          }(),
          {
            signal
          }
        );
        return {
          value,
          write(chunk, encoding, cb) {
            const _resolve = resolve2;
            resolve2 = null;
            _resolve({
              chunk,
              done: false,
              cb
            });
          },
          final(cb) {
            const _resolve = resolve2;
            resolve2 = null;
            _resolve({
              done: true,
              cb
            });
          },
          destroy(err, cb) {
            ac.abort();
            cb(err);
          }
        };
      }
      function _duplexify(pair) {
        const r7 = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
        const w2 = pair.writable;
        let readable = !!isReadable(r7);
        let writable = !!isWritable(w2);
        let ondrain;
        let onfinish;
        let onreadable;
        let onclose;
        let d4;
        function onfinished(err) {
          const cb = onclose;
          onclose = null;
          if (cb) {
            cb(err);
          } else if (err) {
            d4.destroy(err);
          }
        }
        d4 = new Duplexify({
          // TODO (ronag): highWaterMark?
          readableObjectMode: !!(r7 !== null && r7 !== void 0 && r7.readableObjectMode),
          writableObjectMode: !!(w2 !== null && w2 !== void 0 && w2.writableObjectMode),
          readable,
          writable
        });
        if (writable) {
          eos(w2, (err) => {
            writable = false;
            if (err) {
              destroyer(r7, err);
            }
            onfinished(err);
          });
          d4._write = function(chunk, encoding, callback) {
            if (w2.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d4._final = function(callback) {
            w2.end();
            onfinish = callback;
          };
          w2.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
          w2.on("finish", function() {
            if (onfinish) {
              const cb = onfinish;
              onfinish = null;
              cb();
            }
          });
        }
        if (readable) {
          eos(r7, (err) => {
            readable = false;
            if (err) {
              destroyer(r7, err);
            }
            onfinished(err);
          });
          r7.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          r7.on("end", function() {
            d4.push(null);
          });
          d4._read = function() {
            while (true) {
              const buf = r7.read();
              if (buf === null) {
                onreadable = d4._read;
                return;
              }
              if (!d4.push(buf)) {
                return;
              }
            }
          };
        }
        d4._destroy = function(err, callback) {
          if (!err && onclose !== null) {
            err = new AbortError();
          }
          onreadable = null;
          ondrain = null;
          onfinish = null;
          if (onclose === null) {
            callback(err);
          } else {
            onclose = callback;
            destroyer(w2, err);
            destroyer(r7, err);
          }
        };
        return d4;
      }
    }
  });

  // node_modules/readable-stream/lib/internal/streams/duplex.js
  var require_duplex = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/duplex.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var {
        ObjectDefineProperties,
        ObjectGetOwnPropertyDescriptor,
        ObjectKeys,
        ObjectSetPrototypeOf
      } = require_primordials();
      module.exports = Duplex;
      var Readable = require_readable();
      var Writable = require_writable();
      ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
      ObjectSetPrototypeOf(Duplex, Readable);
      {
        const keys = ObjectKeys(Writable.prototype);
        for (let i6 = 0; i6 < keys.length; i6++) {
          const method = keys[i6];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options) {
          this.allowHalfOpen = options.allowHalfOpen !== false;
          if (options.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
          }
          if (options.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
          }
        } else {
          this.allowHalfOpen = true;
        }
      }
      ObjectDefineProperties(Duplex.prototype, {
        writable: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
        },
        writableHighWaterMark: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
        },
        writableObjectMode: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
        },
        writableBuffer: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
        },
        writableLength: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
        },
        writableFinished: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
        },
        writableCorked: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
        },
        writableEnded: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
        },
        writableNeedDrain: {
          __proto__: null,
          ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
        },
        destroyed: {
          __proto__: null,
          get() {
            if (this._readableState === void 0 || this._writableState === void 0) {
              return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
          },
          set(value) {
            if (this._readableState && this._writableState) {
              this._readableState.destroyed = value;
              this._writableState.destroyed = value;
            }
          }
        }
      });
      var webStreamsAdapters;
      function lazyWebStreams() {
        if (webStreamsAdapters === void 0)
          webStreamsAdapters = {};
        return webStreamsAdapters;
      }
      Duplex.fromWeb = function(pair, options) {
        return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
      };
      Duplex.toWeb = function(duplex) {
        return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
      };
      var duplexify;
      Duplex.from = function(body) {
        if (!duplexify) {
          duplexify = require_duplexify();
        }
        return duplexify(body, "body");
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/transform.js
  var require_transform = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/transform.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
      module.exports = Transform;
      var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
      var Duplex = require_duplex();
      var { getHighWaterMark } = require_state();
      ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
      ObjectSetPrototypeOf(Transform, Duplex);
      var kCallback = Symbol2("kCallback");
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
        if (readableHighWaterMark === 0) {
          options = {
            ...options,
            highWaterMark: null,
            readableHighWaterMark,
            // TODO (ronag): 0 is not optimal since we have
            // a "bug" where we check needDrain before calling _write and not after.
            // Refs: https://github.com/nodejs/node/pull/32887
            // Refs: https://github.com/nodejs/node/pull/35941
            writableHighWaterMark: options.writableHighWaterMark || 0
          };
        }
        Duplex.call(this, options);
        this._readableState.sync = false;
        this[kCallback] = null;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function final(cb) {
        if (typeof this._flush === "function" && !this.destroyed) {
          this._flush((er, data) => {
            if (er) {
              if (cb) {
                cb(er);
              } else {
                this.destroy(er);
              }
              return;
            }
            if (data != null) {
              this.push(data);
            }
            this.push(null);
            if (cb) {
              cb();
            }
          });
        } else {
          this.push(null);
          if (cb) {
            cb();
          }
        }
      }
      function prefinish() {
        if (this._final !== final) {
          final.call(this);
        }
      }
      Transform.prototype._final = final;
      Transform.prototype._transform = function(chunk, encoding, callback) {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
      };
      Transform.prototype._write = function(chunk, encoding, callback) {
        const rState = this._readableState;
        const wState = this._writableState;
        const length = rState.length;
        this._transform(chunk, encoding, (err, val) => {
          if (err) {
            callback(err);
            return;
          }
          if (val != null) {
            this.push(val);
          }
          if (wState.ended || // Backwards compat.
          length === rState.length || // Backwards compat.
          rState.length < rState.highWaterMark) {
            callback();
          } else {
            this[kCallback] = callback;
          }
        });
      };
      Transform.prototype._read = function() {
        if (this[kCallback]) {
          const callback = this[kCallback];
          this[kCallback] = null;
          callback();
        }
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/passthrough.js
  var require_passthrough = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { ObjectSetPrototypeOf } = require_primordials();
      module.exports = PassThrough;
      var Transform = require_transform();
      ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
      ObjectSetPrototypeOf(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var process3 = require_browser2();
      var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require_primordials();
      var eos = require_end_of_stream();
      var { once: once3 } = require_util();
      var destroyImpl = require_destroy();
      var Duplex = require_duplex();
      var {
        aggregateTwoErrors,
        codes: {
          ERR_INVALID_ARG_TYPE,
          ERR_INVALID_RETURN_VALUE,
          ERR_MISSING_ARGS,
          ERR_STREAM_DESTROYED,
          ERR_STREAM_PREMATURE_CLOSE
        },
        AbortError
      } = require_errors();
      var { validateFunction, validateAbortSignal } = require_validators();
      var {
        isIterable,
        isReadable,
        isReadableNodeStream,
        isNodeStream,
        isTransformStream,
        isWebStream,
        isReadableStream,
        isReadableEnded
      } = require_utils();
      var AbortController = globalThis.AbortController || require_browser().AbortController;
      var PassThrough;
      var Readable;
      function destroyer(stream, reading, writing) {
        let finished = false;
        stream.on("close", () => {
          finished = true;
        });
        const cleanup = eos(
          stream,
          {
            readable: reading,
            writable: writing
          },
          (err) => {
            finished = !err;
          }
        );
        return {
          destroy: (err) => {
            if (finished)
              return;
            finished = true;
            destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
          },
          cleanup
        };
      }
      function popCallback(streams) {
        validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
        return streams.pop();
      }
      function makeAsyncIterable(val) {
        if (isIterable(val)) {
          return val;
        } else if (isReadableNodeStream(val)) {
          return fromReadable(val);
        }
        throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
      }
      async function* fromReadable(val) {
        if (!Readable) {
          Readable = require_readable();
        }
        yield* Readable.prototype[SymbolAsyncIterator].call(val);
      }
      async function pumpToNode(iterable, writable, finish, { end }) {
        let error;
        let onresolve = null;
        const resume = (err) => {
          if (err) {
            error = err;
          }
          if (onresolve) {
            const callback = onresolve;
            onresolve = null;
            callback();
          }
        };
        const wait = () => new Promise2((resolve2, reject) => {
          if (error) {
            reject(error);
          } else {
            onresolve = () => {
              if (error) {
                reject(error);
              } else {
                resolve2();
              }
            };
          }
        });
        writable.on("drain", resume);
        const cleanup = eos(
          writable,
          {
            readable: false
          },
          resume
        );
        try {
          if (writable.writableNeedDrain) {
            await wait();
          }
          for await (const chunk of iterable) {
            if (!writable.write(chunk)) {
              await wait();
            }
          }
          if (end) {
            writable.end();
          }
          await wait();
          finish();
        } catch (err) {
          finish(error !== err ? aggregateTwoErrors(error, err) : err);
        } finally {
          cleanup();
          writable.off("drain", resume);
        }
      }
      async function pumpToWeb(readable, writable, finish, { end }) {
        if (isTransformStream(writable)) {
          writable = writable.writable;
        }
        const writer = writable.getWriter();
        try {
          for await (const chunk of readable) {
            await writer.ready;
            writer.write(chunk).catch(() => {
            });
          }
          await writer.ready;
          if (end) {
            await writer.close();
          }
          finish();
        } catch (err) {
          try {
            await writer.abort(err);
            finish(err);
          } catch (err2) {
            finish(err2);
          }
        }
      }
      function pipeline(...streams) {
        return pipelineImpl(streams, once3(popCallback(streams)));
      }
      function pipelineImpl(streams, callback, opts) {
        if (streams.length === 1 && ArrayIsArray(streams[0])) {
          streams = streams[0];
        }
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        const ac = new AbortController();
        const signal = ac.signal;
        const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
        const lastStreamCleanup = [];
        validateAbortSignal(outerSignal, "options.signal");
        function abort2() {
          finishImpl(new AbortError());
        }
        outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener("abort", abort2);
        let error;
        let value;
        const destroys = [];
        let finishCount = 0;
        function finish(err) {
          finishImpl(err, --finishCount === 0);
        }
        function finishImpl(err, final) {
          if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
            error = err;
          }
          if (!error && !final) {
            return;
          }
          while (destroys.length) {
            destroys.shift()(error);
          }
          outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener("abort", abort2);
          ac.abort();
          if (final) {
            if (!error) {
              lastStreamCleanup.forEach((fn) => fn());
            }
            process3.nextTick(callback, error, value);
          }
        }
        let ret;
        for (let i6 = 0; i6 < streams.length; i6++) {
          const stream = streams[i6];
          const reading = i6 < streams.length - 1;
          const writing = i6 > 0;
          const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
          const isLastStream = i6 === streams.length - 1;
          if (isNodeStream(stream)) {
            let onError2 = function(err) {
              if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                finish(err);
              }
            };
            var onError = onError2;
            if (end) {
              const { destroy, cleanup } = destroyer(stream, reading, writing);
              destroys.push(destroy);
              if (isReadable(stream) && isLastStream) {
                lastStreamCleanup.push(cleanup);
              }
            }
            stream.on("error", onError2);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(() => {
                stream.removeListener("error", onError2);
              });
            }
          }
          if (i6 === 0) {
            if (typeof stream === "function") {
              ret = stream({
                signal
              });
              if (!isIterable(ret)) {
                throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
              }
            } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
              ret = stream;
            } else {
              ret = Duplex.from(stream);
            }
          } else if (typeof stream === "function") {
            if (isTransformStream(ret)) {
              var _ret;
              ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
            } else {
              ret = makeAsyncIterable(ret);
            }
            ret = stream(ret, {
              signal
            });
            if (reading) {
              if (!isIterable(ret, true)) {
                throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i6 - 1}]`, ret);
              }
            } else {
              var _ret2;
              if (!PassThrough) {
                PassThrough = require_passthrough();
              }
              const pt = new PassThrough({
                objectMode: true
              });
              const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
              if (typeof then === "function") {
                finishCount++;
                then.call(
                  ret,
                  (val) => {
                    value = val;
                    if (val != null) {
                      pt.write(val);
                    }
                    if (end) {
                      pt.end();
                    }
                    process3.nextTick(finish);
                  },
                  (err) => {
                    pt.destroy(err);
                    process3.nextTick(finish, err);
                  }
                );
              } else if (isIterable(ret, true)) {
                finishCount++;
                pumpToNode(ret, pt, finish, {
                  end
                });
              } else if (isReadableStream(ret) || isTransformStream(ret)) {
                const toRead = ret.readable || ret;
                finishCount++;
                pumpToNode(toRead, pt, finish, {
                  end
                });
              } else {
                throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
              }
              ret = pt;
              const { destroy, cleanup } = destroyer(ret, false, true);
              destroys.push(destroy);
              if (isLastStream) {
                lastStreamCleanup.push(cleanup);
              }
            }
          } else if (isNodeStream(stream)) {
            if (isReadableNodeStream(ret)) {
              finishCount += 2;
              const cleanup = pipe(ret, stream, finish, {
                end
              });
              if (isReadable(stream) && isLastStream) {
                lastStreamCleanup.push(cleanup);
              }
            } else if (isTransformStream(ret) || isReadableStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, stream, finish, {
                end
              });
            } else if (isIterable(ret)) {
              finishCount++;
              pumpToNode(ret, stream, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_ARG_TYPE(
                "val",
                ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
                ret
              );
            }
            ret = stream;
          } else if (isWebStream(stream)) {
            if (isReadableNodeStream(ret)) {
              finishCount++;
              pumpToWeb(makeAsyncIterable(ret), stream, finish, {
                end
              });
            } else if (isReadableStream(ret) || isIterable(ret)) {
              finishCount++;
              pumpToWeb(ret, stream, finish, {
                end
              });
            } else if (isTransformStream(ret)) {
              finishCount++;
              pumpToWeb(ret.readable, stream, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_ARG_TYPE(
                "val",
                ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
                ret
              );
            }
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        }
        if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
          process3.nextTick(abort2);
        }
        return ret;
      }
      function pipe(src, dst, finish, { end }) {
        let ended = false;
        dst.on("close", () => {
          if (!ended) {
            finish(new ERR_STREAM_PREMATURE_CLOSE());
          }
        });
        src.pipe(dst, {
          end: false
        });
        if (end) {
          let endFn2 = function() {
            ended = true;
            dst.end();
          };
          var endFn = endFn2;
          if (isReadableEnded(src)) {
            process3.nextTick(endFn2);
          } else {
            src.once("end", endFn2);
          }
        } else {
          finish();
        }
        eos(
          src,
          {
            readable: true,
            writable: false
          },
          (err) => {
            const rState = src._readableState;
            if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
              src.once("end", finish).once("error", finish);
            } else {
              finish(err);
            }
          }
        );
        return eos(
          dst,
          {
            readable: false,
            writable: true
          },
          finish
        );
      }
      module.exports = {
        pipelineImpl,
        pipeline
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/compose.js
  var require_compose = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/compose.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { pipeline } = require_pipeline();
      var Duplex = require_duplex();
      var { destroyer } = require_destroy();
      var {
        isNodeStream,
        isReadable,
        isWritable,
        isWebStream,
        isTransformStream,
        isWritableStream,
        isReadableStream
      } = require_utils();
      var {
        AbortError,
        codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
      } = require_errors();
      var eos = require_end_of_stream();
      module.exports = function compose(...streams) {
        if (streams.length === 0) {
          throw new ERR_MISSING_ARGS("streams");
        }
        if (streams.length === 1) {
          return Duplex.from(streams[0]);
        }
        const orgStreams = [...streams];
        if (typeof streams[0] === "function") {
          streams[0] = Duplex.from(streams[0]);
        }
        if (typeof streams[streams.length - 1] === "function") {
          const idx = streams.length - 1;
          streams[idx] = Duplex.from(streams[idx]);
        }
        for (let n7 = 0; n7 < streams.length; ++n7) {
          if (!isNodeStream(streams[n7]) && !isWebStream(streams[n7])) {
            continue;
          }
          if (n7 < streams.length - 1 && !(isReadable(streams[n7]) || isReadableStream(streams[n7]) || isTransformStream(streams[n7]))) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n7}]`, orgStreams[n7], "must be readable");
          }
          if (n7 > 0 && !(isWritable(streams[n7]) || isWritableStream(streams[n7]) || isTransformStream(streams[n7]))) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n7}]`, orgStreams[n7], "must be writable");
          }
        }
        let ondrain;
        let onfinish;
        let onreadable;
        let onclose;
        let d4;
        function onfinished(err) {
          const cb = onclose;
          onclose = null;
          if (cb) {
            cb(err);
          } else if (err) {
            d4.destroy(err);
          } else if (!readable && !writable) {
            d4.destroy();
          }
        }
        const head = streams[0];
        const tail = pipeline(streams, onfinished);
        const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
        const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
        d4 = new Duplex({
          // TODO (ronag): highWaterMark?
          writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
          readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),
          writable,
          readable
        });
        if (writable) {
          if (isNodeStream(head)) {
            d4._write = function(chunk, encoding, callback) {
              if (head.write(chunk, encoding)) {
                callback();
              } else {
                ondrain = callback;
              }
            };
            d4._final = function(callback) {
              head.end();
              onfinish = callback;
            };
            head.on("drain", function() {
              if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
              }
            });
          } else if (isWebStream(head)) {
            const writable2 = isTransformStream(head) ? head.writable : head;
            const writer = writable2.getWriter();
            d4._write = async function(chunk, encoding, callback) {
              try {
                await writer.ready;
                writer.write(chunk).catch(() => {
                });
                callback();
              } catch (err) {
                callback(err);
              }
            };
            d4._final = async function(callback) {
              try {
                await writer.ready;
                writer.close().catch(() => {
                });
                onfinish = callback;
              } catch (err) {
                callback(err);
              }
            };
          }
          const toRead = isTransformStream(tail) ? tail.readable : tail;
          eos(toRead, () => {
            if (onfinish) {
              const cb = onfinish;
              onfinish = null;
              cb();
            }
          });
        }
        if (readable) {
          if (isNodeStream(tail)) {
            tail.on("readable", function() {
              if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
              }
            });
            tail.on("end", function() {
              d4.push(null);
            });
            d4._read = function() {
              while (true) {
                const buf = tail.read();
                if (buf === null) {
                  onreadable = d4._read;
                  return;
                }
                if (!d4.push(buf)) {
                  return;
                }
              }
            };
          } else if (isWebStream(tail)) {
            const readable2 = isTransformStream(tail) ? tail.readable : tail;
            const reader = readable2.getReader();
            d4._read = async function() {
              while (true) {
                try {
                  const { value, done } = await reader.read();
                  if (!d4.push(value)) {
                    return;
                  }
                  if (done) {
                    d4.push(null);
                    return;
                  }
                } catch {
                  return;
                }
              }
            };
          }
        }
        d4._destroy = function(err, callback) {
          if (!err && onclose !== null) {
            err = new AbortError();
          }
          onreadable = null;
          ondrain = null;
          onfinish = null;
          if (onclose === null) {
            callback(err);
          } else {
            onclose = callback;
            if (isNodeStream(tail)) {
              destroyer(tail, err);
            }
          }
        };
        return d4;
      };
    }
  });

  // node_modules/readable-stream/lib/internal/streams/operators.js
  var require_operators = __commonJS({
    "node_modules/readable-stream/lib/internal/streams/operators.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var AbortController = globalThis.AbortController || require_browser().AbortController;
      var {
        codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
        AbortError
      } = require_errors();
      var { validateAbortSignal, validateInteger, validateObject } = require_validators();
      var kWeakHandler = require_primordials().Symbol("kWeak");
      var { finished } = require_end_of_stream();
      var staticCompose = require_compose();
      var { addAbortSignalNoValidate } = require_add_abort_signal();
      var { isWritable, isNodeStream } = require_utils();
      var {
        ArrayPrototypePush,
        MathFloor,
        Number: Number2,
        NumberIsNaN,
        Promise: Promise2,
        PromiseReject,
        PromisePrototypeThen,
        Symbol: Symbol2
      } = require_primordials();
      var kEmpty = Symbol2("kEmpty");
      var kEof = Symbol2("kEof");
      function compose(stream, options) {
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        if (isNodeStream(stream) && !isWritable(stream)) {
          throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
        }
        const composedStream = staticCompose(this, stream);
        if (options !== null && options !== void 0 && options.signal) {
          addAbortSignalNoValidate(options.signal, composedStream);
        }
        return composedStream;
      }
      function map(fn, options) {
        if (typeof fn !== "function") {
          throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
        }
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        let concurrency = 1;
        if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
          concurrency = MathFloor(options.concurrency);
        }
        validateInteger(concurrency, "concurrency", 1);
        return async function* map2() {
          var _options$signal, _options$signal2;
          const ac = new AbortController();
          const stream = this;
          const queue2 = [];
          const signal = ac.signal;
          const signalOpt = {
            signal
          };
          const abort2 = () => ac.abort();
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            abort2();
          }
          options === null || options === void 0 ? void 0 : (_options$signal2 = options.signal) === null || _options$signal2 === void 0 ? void 0 : _options$signal2.addEventListener("abort", abort2);
          let next;
          let resume;
          let done = false;
          function onDone() {
            done = true;
          }
          async function pump() {
            try {
              for await (let val of stream) {
                var _val;
                if (done) {
                  return;
                }
                if (signal.aborted) {
                  throw new AbortError();
                }
                try {
                  val = fn(val, signalOpt);
                } catch (err) {
                  val = PromiseReject(err);
                }
                if (val === kEmpty) {
                  continue;
                }
                if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === "function") {
                  val.catch(onDone);
                }
                queue2.push(val);
                if (next) {
                  next();
                  next = null;
                }
                if (!done && queue2.length && queue2.length >= concurrency) {
                  await new Promise2((resolve2) => {
                    resume = resolve2;
                  });
                }
              }
              queue2.push(kEof);
            } catch (err) {
              const val = PromiseReject(err);
              PromisePrototypeThen(val, void 0, onDone);
              queue2.push(val);
            } finally {
              var _options$signal3;
              done = true;
              if (next) {
                next();
                next = null;
              }
              options === null || options === void 0 ? void 0 : (_options$signal3 = options.signal) === null || _options$signal3 === void 0 ? void 0 : _options$signal3.removeEventListener("abort", abort2);
            }
          }
          pump();
          try {
            while (true) {
              while (queue2.length > 0) {
                const val = await queue2[0];
                if (val === kEof) {
                  return;
                }
                if (signal.aborted) {
                  throw new AbortError();
                }
                if (val !== kEmpty) {
                  yield val;
                }
                queue2.shift();
                if (resume) {
                  resume();
                  resume = null;
                }
              }
              await new Promise2((resolve2) => {
                next = resolve2;
              });
            }
          } finally {
            ac.abort();
            done = true;
            if (resume) {
              resume();
              resume = null;
            }
          }
        }.call(this);
      }
      function asIndexedPairs(options = void 0) {
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        return async function* asIndexedPairs2() {
          let index = 0;
          for await (const val of this) {
            var _options$signal4;
            if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
              throw new AbortError({
                cause: options.signal.reason
              });
            }
            yield [index++, val];
          }
        }.call(this);
      }
      async function some(fn, options = void 0) {
        for await (const unused of filter.call(this, fn, options)) {
          return true;
        }
        return false;
      }
      async function every(fn, options = void 0) {
        if (typeof fn !== "function") {
          throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
        }
        return !await some.call(
          this,
          async (...args) => {
            return !await fn(...args);
          },
          options
        );
      }
      async function find(fn, options) {
        for await (const result of filter.call(this, fn, options)) {
          return result;
        }
        return void 0;
      }
      async function forEach(fn, options) {
        if (typeof fn !== "function") {
          throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
        }
        async function forEachFn(value, options2) {
          await fn(value, options2);
          return kEmpty;
        }
        for await (const unused of map.call(this, forEachFn, options))
          ;
      }
      function filter(fn, options) {
        if (typeof fn !== "function") {
          throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
        }
        async function filterFn(value, options2) {
          if (await fn(value, options2)) {
            return value;
          }
          return kEmpty;
        }
        return map.call(this, filterFn, options);
      }
      var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
        constructor() {
          super("reduce");
          this.message = "Reduce of an empty stream requires an initial value";
        }
      };
      async function reduce(reducer, initialValue, options) {
        var _options$signal5;
        if (typeof reducer !== "function") {
          throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
        }
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        let hasInitialValue = arguments.length > 1;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          const err = new AbortError(void 0, {
            cause: options.signal.reason
          });
          this.once("error", () => {
          });
          await finished(this.destroy(err));
          throw err;
        }
        const ac = new AbortController();
        const signal = ac.signal;
        if (options !== null && options !== void 0 && options.signal) {
          const opts = {
            once: true,
            [kWeakHandler]: this
          };
          options.signal.addEventListener("abort", () => ac.abort(), opts);
        }
        let gotAnyItemFromStream = false;
        try {
          for await (const value of this) {
            var _options$signal6;
            gotAnyItemFromStream = true;
            if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
              throw new AbortError();
            }
            if (!hasInitialValue) {
              initialValue = value;
              hasInitialValue = true;
            } else {
              initialValue = await reducer(initialValue, value, {
                signal
              });
            }
          }
          if (!gotAnyItemFromStream && !hasInitialValue) {
            throw new ReduceAwareErrMissingArgs();
          }
        } finally {
          ac.abort();
        }
        return initialValue;
      }
      async function toArray(options) {
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        const result = [];
        for await (const val of this) {
          var _options$signal7;
          if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
            throw new AbortError(void 0, {
              cause: options.signal.reason
            });
          }
          ArrayPrototypePush(result, val);
        }
        return result;
      }
      function flatMap(fn, options) {
        const values = map.call(this, fn, options);
        return async function* flatMap2() {
          for await (const val of values) {
            yield* val;
          }
        }.call(this);
      }
      function toIntegerOrInfinity(number) {
        number = Number2(number);
        if (NumberIsNaN(number)) {
          return 0;
        }
        if (number < 0) {
          throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
        }
        return number;
      }
      function drop(number, options = void 0) {
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        number = toIntegerOrInfinity(number);
        return async function* drop2() {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          for await (const val of this) {
            var _options$signal9;
            if (options !== null && options !== void 0 && (_options$signal9 = options.signal) !== null && _options$signal9 !== void 0 && _options$signal9.aborted) {
              throw new AbortError();
            }
            if (number-- <= 0) {
              yield val;
            }
          }
        }.call(this);
      }
      function take(number, options = void 0) {
        if (options != null) {
          validateObject(options, "options");
        }
        if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
          validateAbortSignal(options.signal, "options.signal");
        }
        number = toIntegerOrInfinity(number);
        return async function* take2() {
          var _options$signal10;
          if (options !== null && options !== void 0 && (_options$signal10 = options.signal) !== null && _options$signal10 !== void 0 && _options$signal10.aborted) {
            throw new AbortError();
          }
          for await (const val of this) {
            var _options$signal11;
            if (options !== null && options !== void 0 && (_options$signal11 = options.signal) !== null && _options$signal11 !== void 0 && _options$signal11.aborted) {
              throw new AbortError();
            }
            if (number-- > 0) {
              yield val;
            } else {
              return;
            }
          }
        }.call(this);
      }
      module.exports.streamReturningOperators = {
        asIndexedPairs,
        drop,
        filter,
        flatMap,
        map,
        take,
        compose
      };
      module.exports.promiseReturningOperators = {
        every,
        forEach,
        reduce,
        toArray,
        some,
        find
      };
    }
  });

  // node_modules/readable-stream/lib/stream/promises.js
  var require_promises = __commonJS({
    "node_modules/readable-stream/lib/stream/promises.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
      var { isIterable, isNodeStream, isWebStream } = require_utils();
      var { pipelineImpl: pl } = require_pipeline();
      var { finished } = require_end_of_stream();
      require_stream();
      function pipeline(...streams) {
        return new Promise2((resolve2, reject) => {
          let signal;
          let end;
          const lastArg = streams[streams.length - 1];
          if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
            const options = ArrayPrototypePop(streams);
            signal = options.signal;
            end = options.end;
          }
          pl(
            streams,
            (err, value) => {
              if (err) {
                reject(err);
              } else {
                resolve2(value);
              }
            },
            {
              signal,
              end
            }
          );
        });
      }
      module.exports = {
        finished,
        pipeline
      };
    }
  });

  // node_modules/readable-stream/lib/stream.js
  var require_stream = __commonJS({
    "node_modules/readable-stream/lib/stream.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
      var {
        promisify: { custom: customPromisify }
      } = require_util();
      var { streamReturningOperators, promiseReturningOperators } = require_operators();
      var {
        codes: { ERR_ILLEGAL_CONSTRUCTOR }
      } = require_errors();
      var compose = require_compose();
      var { pipeline } = require_pipeline();
      var { destroyer } = require_destroy();
      var eos = require_end_of_stream();
      var promises = require_promises();
      var utils = require_utils();
      var Stream = module.exports = require_legacy().Stream;
      Stream.isDisturbed = utils.isDisturbed;
      Stream.isErrored = utils.isErrored;
      Stream.isReadable = utils.isReadable;
      Stream.Readable = require_readable();
      for (const key of ObjectKeys(streamReturningOperators)) {
        let fn2 = function(...args) {
          if (new.target) {
            throw ERR_ILLEGAL_CONSTRUCTOR();
          }
          return Stream.Readable.from(ReflectApply(op, this, args));
        };
        fn = fn2;
        const op = streamReturningOperators[key];
        ObjectDefineProperty(fn2, "name", {
          __proto__: null,
          value: op.name
        });
        ObjectDefineProperty(fn2, "length", {
          __proto__: null,
          value: op.length
        });
        ObjectDefineProperty(Stream.Readable.prototype, key, {
          __proto__: null,
          value: fn2,
          enumerable: false,
          configurable: true,
          writable: true
        });
      }
      var fn;
      for (const key of ObjectKeys(promiseReturningOperators)) {
        let fn2 = function(...args) {
          if (new.target) {
            throw ERR_ILLEGAL_CONSTRUCTOR();
          }
          return ReflectApply(op, this, args);
        };
        fn = fn2;
        const op = promiseReturningOperators[key];
        ObjectDefineProperty(fn2, "name", {
          __proto__: null,
          value: op.name
        });
        ObjectDefineProperty(fn2, "length", {
          __proto__: null,
          value: op.length
        });
        ObjectDefineProperty(Stream.Readable.prototype, key, {
          __proto__: null,
          value: fn2,
          enumerable: false,
          configurable: true,
          writable: true
        });
      }
      var fn;
      Stream.Writable = require_writable();
      Stream.Duplex = require_duplex();
      Stream.Transform = require_transform();
      Stream.PassThrough = require_passthrough();
      Stream.pipeline = pipeline;
      var { addAbortSignal } = require_add_abort_signal();
      Stream.addAbortSignal = addAbortSignal;
      Stream.finished = eos;
      Stream.destroy = destroyer;
      Stream.compose = compose;
      ObjectDefineProperty(Stream, "promises", {
        __proto__: null,
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      ObjectDefineProperty(pipeline, customPromisify, {
        __proto__: null,
        enumerable: true,
        get() {
          return promises.pipeline;
        }
      });
      ObjectDefineProperty(eos, customPromisify, {
        __proto__: null,
        enumerable: true,
        get() {
          return promises.finished;
        }
      });
      Stream.Stream = Stream;
      Stream._isUint8Array = function isUint8Array(value) {
        return value instanceof Uint8Array;
      };
      Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
        return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      };
    }
  });

  // node_modules/readable-stream/lib/ours/browser.js
  var require_browser3 = __commonJS({
    "node_modules/readable-stream/lib/ours/browser.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var CustomStream = require_stream();
      var promises = require_promises();
      var originalDestroy = CustomStream.Readable.destroy;
      module.exports = CustomStream.Readable;
      module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
      module.exports._isUint8Array = CustomStream._isUint8Array;
      module.exports.isDisturbed = CustomStream.isDisturbed;
      module.exports.isErrored = CustomStream.isErrored;
      module.exports.isReadable = CustomStream.isReadable;
      module.exports.Readable = CustomStream.Readable;
      module.exports.Writable = CustomStream.Writable;
      module.exports.Duplex = CustomStream.Duplex;
      module.exports.Transform = CustomStream.Transform;
      module.exports.PassThrough = CustomStream.PassThrough;
      module.exports.addAbortSignal = CustomStream.addAbortSignal;
      module.exports.finished = CustomStream.finished;
      module.exports.destroy = CustomStream.destroy;
      module.exports.destroy = originalDestroy;
      module.exports.pipeline = CustomStream.pipeline;
      module.exports.compose = CustomStream.compose;
      Object.defineProperty(CustomStream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module.exports.Stream = CustomStream.Stream;
      module.exports.default = module.exports;
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/mqtt-packet/node_modules/bl/BufferList.js
  var require_BufferList = __commonJS({
    "node_modules/mqtt-packet/node_modules/bl/BufferList.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var symbol = Symbol.for("BufferList");
      function BufferList(buf) {
        if (!(this instanceof BufferList)) {
          return new BufferList(buf);
        }
        BufferList._init.call(this, buf);
      }
      BufferList._init = function _init(buf) {
        Object.defineProperty(this, symbol, { value: true });
        this._bufs = [];
        this.length = 0;
        if (buf) {
          this.append(buf);
        }
      };
      BufferList.prototype._new = function _new(buf) {
        return new BufferList(buf);
      };
      BufferList.prototype._offset = function _offset(offset) {
        if (offset === 0) {
          return [0, 0];
        }
        let tot = 0;
        for (let i6 = 0; i6 < this._bufs.length; i6++) {
          const _t = tot + this._bufs[i6].length;
          if (offset < _t || i6 === this._bufs.length - 1) {
            return [i6, offset - tot];
          }
          tot = _t;
        }
      };
      BufferList.prototype._reverseOffset = function(blOffset) {
        const bufferId = blOffset[0];
        let offset = blOffset[1];
        for (let i6 = 0; i6 < bufferId; i6++) {
          offset += this._bufs[i6].length;
        }
        return offset;
      };
      BufferList.prototype.get = function get(index) {
        if (index > this.length || index < 0) {
          return void 0;
        }
        const offset = this._offset(index);
        return this._bufs[offset[0]][offset[1]];
      };
      BufferList.prototype.slice = function slice(start, end) {
        if (typeof start === "number" && start < 0) {
          start += this.length;
        }
        if (typeof end === "number" && end < 0) {
          end += this.length;
        }
        return this.copy(null, 0, start, end);
      };
      BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
        if (typeof srcStart !== "number" || srcStart < 0) {
          srcStart = 0;
        }
        if (typeof srcEnd !== "number" || srcEnd > this.length) {
          srcEnd = this.length;
        }
        if (srcStart >= this.length) {
          return dst || Buffer3.alloc(0);
        }
        if (srcEnd <= 0) {
          return dst || Buffer3.alloc(0);
        }
        const copy2 = !!dst;
        const off2 = this._offset(srcStart);
        const len = srcEnd - srcStart;
        let bytes = len;
        let bufoff = copy2 && dstStart || 0;
        let start = off2[1];
        if (srcStart === 0 && srcEnd === this.length) {
          if (!copy2) {
            return this._bufs.length === 1 ? this._bufs[0] : Buffer3.concat(this._bufs, this.length);
          }
          for (let i6 = 0; i6 < this._bufs.length; i6++) {
            this._bufs[i6].copy(dst, bufoff);
            bufoff += this._bufs[i6].length;
          }
          return dst;
        }
        if (bytes <= this._bufs[off2[0]].length - start) {
          return copy2 ? this._bufs[off2[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off2[0]].slice(start, start + bytes);
        }
        if (!copy2) {
          dst = Buffer3.allocUnsafe(len);
        }
        for (let i6 = off2[0]; i6 < this._bufs.length; i6++) {
          const l6 = this._bufs[i6].length - start;
          if (bytes > l6) {
            this._bufs[i6].copy(dst, bufoff, start);
            bufoff += l6;
          } else {
            this._bufs[i6].copy(dst, bufoff, start, start + bytes);
            bufoff += l6;
            break;
          }
          bytes -= l6;
          if (start) {
            start = 0;
          }
        }
        if (dst.length > bufoff)
          return dst.slice(0, bufoff);
        return dst;
      };
      BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
        start = start || 0;
        end = typeof end !== "number" ? this.length : end;
        if (start < 0) {
          start += this.length;
        }
        if (end < 0) {
          end += this.length;
        }
        if (start === end) {
          return this._new();
        }
        const startOffset = this._offset(start);
        const endOffset = this._offset(end);
        const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
        if (endOffset[1] === 0) {
          buffers.pop();
        } else {
          buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
        }
        if (startOffset[1] !== 0) {
          buffers[0] = buffers[0].slice(startOffset[1]);
        }
        return this._new(buffers);
      };
      BufferList.prototype.toString = function toString(encoding, start, end) {
        return this.slice(start, end).toString(encoding);
      };
      BufferList.prototype.consume = function consume(bytes) {
        bytes = Math.trunc(bytes);
        if (Number.isNaN(bytes) || bytes <= 0)
          return this;
        while (this._bufs.length) {
          if (bytes >= this._bufs[0].length) {
            bytes -= this._bufs[0].length;
            this.length -= this._bufs[0].length;
            this._bufs.shift();
          } else {
            this._bufs[0] = this._bufs[0].slice(bytes);
            this.length -= bytes;
            break;
          }
        }
        return this;
      };
      BufferList.prototype.duplicate = function duplicate() {
        const copy = this._new();
        for (let i6 = 0; i6 < this._bufs.length; i6++) {
          copy.append(this._bufs[i6]);
        }
        return copy;
      };
      BufferList.prototype.append = function append(buf) {
        if (buf == null) {
          return this;
        }
        if (buf.buffer) {
          this._appendBuffer(Buffer3.from(buf.buffer, buf.byteOffset, buf.byteLength));
        } else if (Array.isArray(buf)) {
          for (let i6 = 0; i6 < buf.length; i6++) {
            this.append(buf[i6]);
          }
        } else if (this._isBufferList(buf)) {
          for (let i6 = 0; i6 < buf._bufs.length; i6++) {
            this.append(buf._bufs[i6]);
          }
        } else {
          if (typeof buf === "number") {
            buf = buf.toString();
          }
          this._appendBuffer(Buffer3.from(buf));
        }
        return this;
      };
      BufferList.prototype._appendBuffer = function appendBuffer(buf) {
        this._bufs.push(buf);
        this.length += buf.length;
      };
      BufferList.prototype.indexOf = function(search, offset, encoding) {
        if (encoding === void 0 && typeof offset === "string") {
          encoding = offset;
          offset = void 0;
        }
        if (typeof search === "function" || Array.isArray(search)) {
          throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
        } else if (typeof search === "number") {
          search = Buffer3.from([search]);
        } else if (typeof search === "string") {
          search = Buffer3.from(search, encoding);
        } else if (this._isBufferList(search)) {
          search = search.slice();
        } else if (Array.isArray(search.buffer)) {
          search = Buffer3.from(search.buffer, search.byteOffset, search.byteLength);
        } else if (!Buffer3.isBuffer(search)) {
          search = Buffer3.from(search);
        }
        offset = Number(offset || 0);
        if (isNaN(offset)) {
          offset = 0;
        }
        if (offset < 0) {
          offset = this.length + offset;
        }
        if (offset < 0) {
          offset = 0;
        }
        if (search.length === 0) {
          return offset > this.length ? this.length : offset;
        }
        const blOffset = this._offset(offset);
        let blIndex = blOffset[0];
        let buffOffset = blOffset[1];
        for (; blIndex < this._bufs.length; blIndex++) {
          const buff = this._bufs[blIndex];
          while (buffOffset < buff.length) {
            const availableWindow = buff.length - buffOffset;
            if (availableWindow >= search.length) {
              const nativeSearchResult = buff.indexOf(search, buffOffset);
              if (nativeSearchResult !== -1) {
                return this._reverseOffset([blIndex, nativeSearchResult]);
              }
              buffOffset = buff.length - search.length + 1;
            } else {
              const revOffset = this._reverseOffset([blIndex, buffOffset]);
              if (this._match(revOffset, search)) {
                return revOffset;
              }
              buffOffset++;
            }
          }
          buffOffset = 0;
        }
        return -1;
      };
      BufferList.prototype._match = function(offset, search) {
        if (this.length - offset < search.length) {
          return false;
        }
        for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
          if (this.get(offset + searchOffset) !== search[searchOffset]) {
            return false;
          }
        }
        return true;
      };
      (function() {
        const methods = {
          readDoubleBE: 8,
          readDoubleLE: 8,
          readFloatBE: 4,
          readFloatLE: 4,
          readBigInt64BE: 8,
          readBigInt64LE: 8,
          readBigUInt64BE: 8,
          readBigUInt64LE: 8,
          readInt32BE: 4,
          readInt32LE: 4,
          readUInt32BE: 4,
          readUInt32LE: 4,
          readInt16BE: 2,
          readInt16LE: 2,
          readUInt16BE: 2,
          readUInt16LE: 2,
          readInt8: 1,
          readUInt8: 1,
          readIntBE: null,
          readIntLE: null,
          readUIntBE: null,
          readUIntLE: null
        };
        for (const m4 in methods) {
          (function(m5) {
            if (methods[m5] === null) {
              BufferList.prototype[m5] = function(offset, byteLength) {
                return this.slice(offset, offset + byteLength)[m5](0, byteLength);
              };
            } else {
              BufferList.prototype[m5] = function(offset = 0) {
                return this.slice(offset, offset + methods[m5])[m5](0);
              };
            }
          })(m4);
        }
      })();
      BufferList.prototype._isBufferList = function _isBufferList(b3) {
        return b3 instanceof BufferList || BufferList.isBufferList(b3);
      };
      BufferList.isBufferList = function isBufferList(b3) {
        return b3 != null && b3[symbol];
      };
      module.exports = BufferList;
    }
  });

  // node_modules/mqtt-packet/node_modules/bl/bl.js
  var require_bl = __commonJS({
    "node_modules/mqtt-packet/node_modules/bl/bl.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var DuplexStream = require_browser3().Duplex;
      var inherits = require_inherits_browser();
      var BufferList = require_BufferList();
      function BufferListStream(callback) {
        if (!(this instanceof BufferListStream)) {
          return new BufferListStream(callback);
        }
        if (typeof callback === "function") {
          this._callback = callback;
          const piper = function piper2(err) {
            if (this._callback) {
              this._callback(err);
              this._callback = null;
            }
          }.bind(this);
          this.on("pipe", function onPipe(src) {
            src.on("error", piper);
          });
          this.on("unpipe", function onUnpipe(src) {
            src.removeListener("error", piper);
          });
          callback = null;
        }
        BufferList._init.call(this, callback);
        DuplexStream.call(this);
      }
      inherits(BufferListStream, DuplexStream);
      Object.assign(BufferListStream.prototype, BufferList.prototype);
      BufferListStream.prototype._new = function _new(callback) {
        return new BufferListStream(callback);
      };
      BufferListStream.prototype._write = function _write(buf, encoding, callback) {
        this._appendBuffer(buf);
        if (typeof callback === "function") {
          callback();
        }
      };
      BufferListStream.prototype._read = function _read(size) {
        if (!this.length) {
          return this.push(null);
        }
        size = Math.min(size, this.length);
        this.push(this.slice(0, size));
        this.consume(size);
      };
      BufferListStream.prototype.end = function end(chunk) {
        DuplexStream.prototype.end.call(this, chunk);
        if (this._callback) {
          this._callback(null, this.slice());
          this._callback = null;
        }
      };
      BufferListStream.prototype._destroy = function _destroy(err, cb) {
        this._bufs.length = 0;
        this.length = 0;
        cb(err);
      };
      BufferListStream.prototype._isBufferList = function _isBufferList(b3) {
        return b3 instanceof BufferListStream || b3 instanceof BufferList || BufferListStream.isBufferList(b3);
      };
      BufferListStream.isBufferList = BufferList.isBufferList;
      module.exports = BufferListStream;
      module.exports.BufferListStream = BufferListStream;
      module.exports.BufferList = BufferList;
    }
  });

  // node_modules/mqtt-packet/packet.js
  var require_packet = __commonJS({
    "node_modules/mqtt-packet/packet.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var Packet = class {
        constructor() {
          this.cmd = null;
          this.retain = false;
          this.qos = 0;
          this.dup = false;
          this.length = -1;
          this.topic = null;
          this.payload = null;
        }
      };
      module.exports = Packet;
    }
  });

  // node_modules/mqtt-packet/constants.js
  var require_constants = __commonJS({
    "node_modules/mqtt-packet/constants.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var protocol = module.exports;
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      protocol.types = {
        0: "reserved",
        1: "connect",
        2: "connack",
        3: "publish",
        4: "puback",
        5: "pubrec",
        6: "pubrel",
        7: "pubcomp",
        8: "subscribe",
        9: "suback",
        10: "unsubscribe",
        11: "unsuback",
        12: "pingreq",
        13: "pingresp",
        14: "disconnect",
        15: "auth"
      };
      protocol.requiredHeaderFlags = {
        1: 0,
        // 'connect'
        2: 0,
        // 'connack'
        4: 0,
        // 'puback'
        5: 0,
        // 'pubrec'
        6: 2,
        // 'pubrel'
        7: 0,
        // 'pubcomp'
        8: 2,
        // 'subscribe'
        9: 0,
        // 'suback'
        10: 2,
        // 'unsubscribe'
        11: 0,
        // 'unsuback'
        12: 0,
        // 'pingreq'
        13: 0,
        // 'pingresp'
        14: 0,
        // 'disconnect'
        15: 0
        // 'auth'
      };
      protocol.requiredHeaderFlagsErrors = {};
      for (const k2 in protocol.requiredHeaderFlags) {
        const v4 = protocol.requiredHeaderFlags[k2];
        protocol.requiredHeaderFlagsErrors[k2] = "Invalid header flag bits, must be 0x" + v4.toString(16) + " for " + protocol.types[k2] + " packet";
      }
      protocol.codes = {};
      for (const k2 in protocol.types) {
        const v4 = protocol.types[k2];
        protocol.codes[v4] = k2;
      }
      protocol.CMD_SHIFT = 4;
      protocol.CMD_MASK = 240;
      protocol.DUP_MASK = 8;
      protocol.QOS_MASK = 3;
      protocol.QOS_SHIFT = 1;
      protocol.RETAIN_MASK = 1;
      protocol.VARBYTEINT_MASK = 127;
      protocol.VARBYTEINT_FIN_MASK = 128;
      protocol.VARBYTEINT_MAX = 268435455;
      protocol.SESSIONPRESENT_MASK = 1;
      protocol.SESSIONPRESENT_HEADER = Buffer3.from([protocol.SESSIONPRESENT_MASK]);
      protocol.CONNACK_HEADER = Buffer3.from([protocol.codes.connack << protocol.CMD_SHIFT]);
      protocol.USERNAME_MASK = 128;
      protocol.PASSWORD_MASK = 64;
      protocol.WILL_RETAIN_MASK = 32;
      protocol.WILL_QOS_MASK = 24;
      protocol.WILL_QOS_SHIFT = 3;
      protocol.WILL_FLAG_MASK = 4;
      protocol.CLEAN_SESSION_MASK = 2;
      protocol.CONNECT_HEADER = Buffer3.from([protocol.codes.connect << protocol.CMD_SHIFT]);
      protocol.properties = {
        sessionExpiryInterval: 17,
        willDelayInterval: 24,
        receiveMaximum: 33,
        maximumPacketSize: 39,
        topicAliasMaximum: 34,
        requestResponseInformation: 25,
        requestProblemInformation: 23,
        userProperties: 38,
        authenticationMethod: 21,
        authenticationData: 22,
        payloadFormatIndicator: 1,
        messageExpiryInterval: 2,
        contentType: 3,
        responseTopic: 8,
        correlationData: 9,
        maximumQoS: 36,
        retainAvailable: 37,
        assignedClientIdentifier: 18,
        reasonString: 31,
        wildcardSubscriptionAvailable: 40,
        subscriptionIdentifiersAvailable: 41,
        sharedSubscriptionAvailable: 42,
        serverKeepAlive: 19,
        responseInformation: 26,
        serverReference: 28,
        topicAlias: 35,
        subscriptionIdentifier: 11
      };
      protocol.propertiesCodes = {};
      for (const prop in protocol.properties) {
        const id = protocol.properties[prop];
        protocol.propertiesCodes[id] = prop;
      }
      protocol.propertiesTypes = {
        sessionExpiryInterval: "int32",
        willDelayInterval: "int32",
        receiveMaximum: "int16",
        maximumPacketSize: "int32",
        topicAliasMaximum: "int16",
        requestResponseInformation: "byte",
        requestProblemInformation: "byte",
        userProperties: "pair",
        authenticationMethod: "string",
        authenticationData: "binary",
        payloadFormatIndicator: "byte",
        messageExpiryInterval: "int32",
        contentType: "string",
        responseTopic: "string",
        correlationData: "binary",
        maximumQoS: "int8",
        retainAvailable: "byte",
        assignedClientIdentifier: "string",
        reasonString: "string",
        wildcardSubscriptionAvailable: "byte",
        subscriptionIdentifiersAvailable: "byte",
        sharedSubscriptionAvailable: "byte",
        serverKeepAlive: "int16",
        responseInformation: "string",
        serverReference: "string",
        topicAlias: "int16",
        subscriptionIdentifier: "var"
      };
      function genHeader(type) {
        return [0, 1, 2].map((qos) => {
          return [0, 1].map((dup) => {
            return [0, 1].map((retain) => {
              const buf = Buffer3.alloc(1);
              buf.writeUInt8(
                protocol.codes[type] << protocol.CMD_SHIFT | (dup ? protocol.DUP_MASK : 0) | qos << protocol.QOS_SHIFT | retain,
                0,
                true
              );
              return buf;
            });
          });
        });
      }
      protocol.PUBLISH_HEADER = genHeader("publish");
      protocol.SUBSCRIBE_HEADER = genHeader("subscribe");
      protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 3;
      protocol.SUBSCRIBE_OPTIONS_NL_MASK = 1;
      protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2;
      protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 1;
      protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3;
      protocol.SUBSCRIBE_OPTIONS_RH_MASK = 3;
      protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4;
      protocol.SUBSCRIBE_OPTIONS_RH = [0, 16, 32];
      protocol.SUBSCRIBE_OPTIONS_NL = 4;
      protocol.SUBSCRIBE_OPTIONS_RAP = 8;
      protocol.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2];
      protocol.UNSUBSCRIBE_HEADER = genHeader("unsubscribe");
      protocol.ACKS = {
        unsuback: genHeader("unsuback"),
        puback: genHeader("puback"),
        pubcomp: genHeader("pubcomp"),
        pubrel: genHeader("pubrel"),
        pubrec: genHeader("pubrec")
      };
      protocol.SUBACK_HEADER = Buffer3.from([protocol.codes.suback << protocol.CMD_SHIFT]);
      protocol.VERSION3 = Buffer3.from([3]);
      protocol.VERSION4 = Buffer3.from([4]);
      protocol.VERSION5 = Buffer3.from([5]);
      protocol.VERSION131 = Buffer3.from([131]);
      protocol.VERSION132 = Buffer3.from([132]);
      protocol.QOS = [0, 1, 2].map((qos) => {
        return Buffer3.from([qos]);
      });
      protocol.EMPTY = {
        pingreq: Buffer3.from([protocol.codes.pingreq << 4, 0]),
        pingresp: Buffer3.from([protocol.codes.pingresp << 4, 0]),
        disconnect: Buffer3.from([protocol.codes.disconnect << 4, 0])
      };
      protocol.MQTT5_PUBACK_PUBREC_CODES = {
        0: "Success",
        16: "No matching subscribers",
        128: "Unspecified error",
        131: "Implementation specific error",
        135: "Not authorized",
        144: "Topic Name invalid",
        145: "Packet identifier in use",
        151: "Quota exceeded",
        153: "Payload format invalid"
      };
      protocol.MQTT5_PUBREL_PUBCOMP_CODES = {
        0: "Success",
        146: "Packet Identifier not found"
      };
      protocol.MQTT5_SUBACK_CODES = {
        0: "Granted QoS 0",
        1: "Granted QoS 1",
        2: "Granted QoS 2",
        128: "Unspecified error",
        131: "Implementation specific error",
        135: "Not authorized",
        143: "Topic Filter invalid",
        145: "Packet Identifier in use",
        151: "Quota exceeded",
        158: "Shared Subscriptions not supported",
        161: "Subscription Identifiers not supported",
        162: "Wildcard Subscriptions not supported"
      };
      protocol.MQTT5_UNSUBACK_CODES = {
        0: "Success",
        17: "No subscription existed",
        128: "Unspecified error",
        131: "Implementation specific error",
        135: "Not authorized",
        143: "Topic Filter invalid",
        145: "Packet Identifier in use"
      };
      protocol.MQTT5_DISCONNECT_CODES = {
        0: "Normal disconnection",
        4: "Disconnect with Will Message",
        128: "Unspecified error",
        129: "Malformed Packet",
        130: "Protocol Error",
        131: "Implementation specific error",
        135: "Not authorized",
        137: "Server busy",
        139: "Server shutting down",
        141: "Keep Alive timeout",
        142: "Session taken over",
        143: "Topic Filter invalid",
        144: "Topic Name invalid",
        147: "Receive Maximum exceeded",
        148: "Topic Alias invalid",
        149: "Packet too large",
        150: "Message rate too high",
        151: "Quota exceeded",
        152: "Administrative action",
        153: "Payload format invalid",
        154: "Retain not supported",
        155: "QoS not supported",
        156: "Use another server",
        157: "Server moved",
        158: "Shared Subscriptions not supported",
        159: "Connection rate exceeded",
        160: "Maximum connect time",
        161: "Subscription Identifiers not supported",
        162: "Wildcard Subscriptions not supported"
      };
      protocol.MQTT5_AUTH_CODES = {
        0: "Success",
        24: "Continue authentication",
        25: "Re-authenticate"
      };
    }
  });

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var s5 = 1e3;
      var m4 = s5 * 60;
      var h6 = m4 * 60;
      var d4 = h6 * 24;
      var w2 = d4 * 7;
      var y4 = d4 * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse2(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse2(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n7 = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n7 * y4;
          case "weeks":
          case "week":
          case "w":
            return n7 * w2;
          case "days":
          case "day":
          case "d":
            return n7 * d4;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n7 * h6;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n7 * m4;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n7 * s5;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n7;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d4) {
          return Math.round(ms / d4) + "d";
        }
        if (msAbs >= h6) {
          return Math.round(ms / h6) + "h";
        }
        if (msAbs >= m4) {
          return Math.round(ms / m4) + "m";
        }
        if (msAbs >= s5) {
          return Math.round(ms / s5) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d4) {
          return plural(ms, msAbs, d4, "day");
        }
        if (msAbs >= h6) {
          return plural(ms, msAbs, h6, "hour");
        }
        if (msAbs >= m4) {
          return plural(ms, msAbs, m4, "minute");
        }
        if (msAbs >= s5) {
          return plural(ms, msAbs, s5, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n7, name2) {
        var isPlural = msAbs >= n7 * 1.5;
        return Math.round(ms / n7) + " " + name2 + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/debug/src/common.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      function setup(env2) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env2).forEach((key) => {
          createDebug[key] = env2[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i6 = 0; i6 < namespace.length; i6++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i6);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self2 = debug;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format2];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v4) => {
              enableOverride = v4;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i6;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i6 = 0; i6 < len; i6++) {
            if (!split[i6]) {
              continue;
            }
            namespaces = split[i6].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name2) {
          if (name2[name2.length - 1] === "*") {
            return true;
          }
          let i6;
          let len;
          for (i6 = 0, len = createDebug.skips.length; i6 < len; i6++) {
            if (createDebug.skips[i6].test(name2)) {
              return false;
            }
          }
          for (i6 = 0, len = createDebug.names.length; i6 < len; i6++) {
            if (createDebug.names[i6].test(name2)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // node_modules/debug/src/browser.js
  var require_browser4 = __commonJS({
    "node_modules/debug/src/browser.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      exports5.formatArgs = formatArgs;
      exports5.save = save;
      exports5.load = load;
      exports5.useColors = useColors;
      exports5.storage = localstorage();
      exports5.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports5.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c6 = "color: " + this.color;
        args.splice(1, 0, c6, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c6);
      }
      exports5.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports5.storage.setItem("debug", namespaces);
          } else {
            exports5.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r7;
        try {
          r7 = exports5.storage.getItem("debug");
        } catch (error) {
        }
        if (!r7 && typeof process_exports !== "undefined" && "env" in process_exports) {
          r7 = process_exports.env.DEBUG;
        }
        return r7;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports5);
      var { formatters } = module.exports;
      formatters.j = function(v4) {
        try {
          return JSON.stringify(v4);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // node_modules/mqtt-packet/parser.js
  var require_parser = __commonJS({
    "node_modules/mqtt-packet/parser.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var bl = require_bl();
      var { EventEmitter: EventEmitter2 } = (init_events(), __toCommonJS(events_exports));
      var Packet = require_packet();
      var constants = require_constants();
      var debug = require_browser4()("mqtt-packet:parser");
      var Parser = class _Parser extends EventEmitter2 {
        constructor() {
          super();
          this.parser = this.constructor.parser;
        }
        static parser(opt) {
          if (!(this instanceof _Parser))
            return new _Parser().parser(opt);
          this.settings = opt || {};
          this._states = [
            "_parseHeader",
            "_parseLength",
            "_parsePayload",
            "_newPacket"
          ];
          this._resetState();
          return this;
        }
        _resetState() {
          debug("_resetState: resetting packet, error, _list, and _stateCounter");
          this.packet = new Packet();
          this.error = null;
          this._list = bl();
          this._stateCounter = 0;
        }
        parse(buf) {
          if (this.error)
            this._resetState();
          this._list.append(buf);
          debug("parse: current state: %s", this._states[this._stateCounter]);
          while ((this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error) {
            this._stateCounter++;
            debug("parse: state complete. _stateCounter is now: %d", this._stateCounter);
            debug("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length);
            if (this._stateCounter >= this._states.length)
              this._stateCounter = 0;
          }
          debug("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length);
          return this._list.length;
        }
        _parseHeader() {
          const zero = this._list.readUInt8(0);
          const cmdIndex = zero >> constants.CMD_SHIFT;
          this.packet.cmd = constants.types[cmdIndex];
          const headerFlags = zero & 15;
          const requiredHeaderFlags = constants.requiredHeaderFlags[cmdIndex];
          if (requiredHeaderFlags != null && headerFlags !== requiredHeaderFlags) {
            return this._emitError(new Error(constants.requiredHeaderFlagsErrors[cmdIndex]));
          }
          this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;
          this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;
          if (this.packet.qos > 2) {
            return this._emitError(new Error("Packet must not have both QoS bits set to 1"));
          }
          this.packet.dup = (zero & constants.DUP_MASK) !== 0;
          debug("_parseHeader: packet: %o", this.packet);
          this._list.consume(1);
          return true;
        }
        _parseLength() {
          const result = this._parseVarByteNum(true);
          if (result) {
            this.packet.length = result.value;
            this._list.consume(result.bytes);
          }
          debug("_parseLength %d", result.value);
          return !!result;
        }
        _parsePayload() {
          debug("_parsePayload: payload %O", this._list);
          let result = false;
          if (this.packet.length === 0 || this._list.length >= this.packet.length) {
            this._pos = 0;
            switch (this.packet.cmd) {
              case "connect":
                this._parseConnect();
                break;
              case "connack":
                this._parseConnack();
                break;
              case "publish":
                this._parsePublish();
                break;
              case "puback":
              case "pubrec":
              case "pubrel":
              case "pubcomp":
                this._parseConfirmation();
                break;
              case "subscribe":
                this._parseSubscribe();
                break;
              case "suback":
                this._parseSuback();
                break;
              case "unsubscribe":
                this._parseUnsubscribe();
                break;
              case "unsuback":
                this._parseUnsuback();
                break;
              case "pingreq":
              case "pingresp":
                break;
              case "disconnect":
                this._parseDisconnect();
                break;
              case "auth":
                this._parseAuth();
                break;
              default:
                this._emitError(new Error("Not supported"));
            }
            result = true;
          }
          debug("_parsePayload complete result: %s", result);
          return result;
        }
        _parseConnect() {
          debug("_parseConnect");
          let topic;
          let payload;
          let password;
          let username;
          const flags = {};
          const packet = this.packet;
          const protocolId = this._parseString();
          if (protocolId === null)
            return this._emitError(new Error("Cannot parse protocolId"));
          if (protocolId !== "MQTT" && protocolId !== "MQIsdp") {
            return this._emitError(new Error("Invalid protocolId"));
          }
          packet.protocolId = protocolId;
          if (this._pos >= this._list.length)
            return this._emitError(new Error("Packet too short"));
          packet.protocolVersion = this._list.readUInt8(this._pos);
          if (packet.protocolVersion >= 128) {
            packet.bridgeMode = true;
            packet.protocolVersion = packet.protocolVersion - 128;
          }
          if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {
            return this._emitError(new Error("Invalid protocol version"));
          }
          this._pos++;
          if (this._pos >= this._list.length) {
            return this._emitError(new Error("Packet too short"));
          }
          if (this._list.readUInt8(this._pos) & 1) {
            return this._emitError(new Error("Connect flag bit 0 must be 0, but got 1"));
          }
          flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;
          flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;
          flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;
          const willRetain = !!(this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK);
          const willQos = (this._list.readUInt8(this._pos) & constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;
          if (flags.will) {
            packet.will = {};
            packet.will.retain = willRetain;
            packet.will.qos = willQos;
          } else {
            if (willRetain) {
              return this._emitError(new Error("Will Retain Flag must be set to zero when Will Flag is set to 0"));
            }
            if (willQos) {
              return this._emitError(new Error("Will QoS must be set to zero when Will Flag is set to 0"));
            }
          }
          packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;
          this._pos++;
          packet.keepalive = this._parseNum();
          if (packet.keepalive === -1)
            return this._emitError(new Error("Packet too short"));
          if (packet.protocolVersion === 5) {
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
          }
          const clientId = this._parseString();
          if (clientId === null)
            return this._emitError(new Error("Packet too short"));
          packet.clientId = clientId;
          debug("_parseConnect: packet.clientId: %s", packet.clientId);
          if (flags.will) {
            if (packet.protocolVersion === 5) {
              const willProperties = this._parseProperties();
              if (Object.getOwnPropertyNames(willProperties).length) {
                packet.will.properties = willProperties;
              }
            }
            topic = this._parseString();
            if (topic === null)
              return this._emitError(new Error("Cannot parse will topic"));
            packet.will.topic = topic;
            debug("_parseConnect: packet.will.topic: %s", packet.will.topic);
            payload = this._parseBuffer();
            if (payload === null)
              return this._emitError(new Error("Cannot parse will payload"));
            packet.will.payload = payload;
            debug("_parseConnect: packet.will.paylaod: %s", packet.will.payload);
          }
          if (flags.username) {
            username = this._parseString();
            if (username === null)
              return this._emitError(new Error("Cannot parse username"));
            packet.username = username;
            debug("_parseConnect: packet.username: %s", packet.username);
          }
          if (flags.password) {
            password = this._parseBuffer();
            if (password === null)
              return this._emitError(new Error("Cannot parse password"));
            packet.password = password;
          }
          this.settings = packet;
          debug("_parseConnect: complete");
          return packet;
        }
        _parseConnack() {
          debug("_parseConnack");
          const packet = this.packet;
          if (this._list.length < 1)
            return null;
          const flags = this._list.readUInt8(this._pos++);
          if (flags > 1) {
            return this._emitError(new Error("Invalid connack flags, bits 7-1 must be set to 0"));
          }
          packet.sessionPresent = !!(flags & constants.SESSIONPRESENT_MASK);
          if (this.settings.protocolVersion === 5) {
            if (this._list.length >= 2) {
              packet.reasonCode = this._list.readUInt8(this._pos++);
            } else {
              packet.reasonCode = 0;
            }
          } else {
            if (this._list.length < 2)
              return null;
            packet.returnCode = this._list.readUInt8(this._pos++);
          }
          if (packet.returnCode === -1 || packet.reasonCode === -1)
            return this._emitError(new Error("Cannot parse return code"));
          if (this.settings.protocolVersion === 5) {
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
          }
          debug("_parseConnack: complete");
        }
        _parsePublish() {
          debug("_parsePublish");
          const packet = this.packet;
          packet.topic = this._parseString();
          if (packet.topic === null)
            return this._emitError(new Error("Cannot parse topic"));
          if (packet.qos > 0) {
            if (!this._parseMessageId()) {
              return;
            }
          }
          if (this.settings.protocolVersion === 5) {
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
          }
          packet.payload = this._list.slice(this._pos, packet.length);
          debug("_parsePublish: payload from buffer list: %o", packet.payload);
        }
        _parseSubscribe() {
          debug("_parseSubscribe");
          const packet = this.packet;
          let topic;
          let options;
          let qos;
          let rh;
          let rap;
          let nl;
          let subscription;
          packet.subscriptions = [];
          if (!this._parseMessageId()) {
            return;
          }
          if (this.settings.protocolVersion === 5) {
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
          }
          if (packet.length <= 0) {
            return this._emitError(new Error("Malformed subscribe, no payload specified"));
          }
          while (this._pos < packet.length) {
            topic = this._parseString();
            if (topic === null)
              return this._emitError(new Error("Cannot parse topic"));
            if (this._pos >= packet.length)
              return this._emitError(new Error("Malformed Subscribe Payload"));
            options = this._parseByte();
            if (this.settings.protocolVersion === 5) {
              if (options & 192) {
                return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-6 must be 0"));
              }
            } else {
              if (options & 252) {
                return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-2 must be 0"));
              }
            }
            qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;
            if (qos > 2) {
              return this._emitError(new Error("Invalid subscribe QoS, must be <= 2"));
            }
            nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;
            rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;
            rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;
            if (rh > 2) {
              return this._emitError(new Error("Invalid retain handling, must be <= 2"));
            }
            subscription = { topic, qos };
            if (this.settings.protocolVersion === 5) {
              subscription.nl = nl;
              subscription.rap = rap;
              subscription.rh = rh;
            } else if (this.settings.bridgeMode) {
              subscription.rh = 0;
              subscription.rap = true;
              subscription.nl = true;
            }
            debug("_parseSubscribe: push subscription `%s` to subscription", subscription);
            packet.subscriptions.push(subscription);
          }
        }
        _parseSuback() {
          debug("_parseSuback");
          const packet = this.packet;
          this.packet.granted = [];
          if (!this._parseMessageId()) {
            return;
          }
          if (this.settings.protocolVersion === 5) {
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
          }
          if (packet.length <= 0) {
            return this._emitError(new Error("Malformed suback, no payload specified"));
          }
          while (this._pos < this.packet.length) {
            const code = this._list.readUInt8(this._pos++);
            if (this.settings.protocolVersion === 5) {
              if (!constants.MQTT5_SUBACK_CODES[code]) {
                return this._emitError(new Error("Invalid suback code"));
              }
            } else {
              if (code > 2 && code !== 128) {
                return this._emitError(new Error("Invalid suback QoS, must be 0, 1, 2 or 128"));
              }
            }
            this.packet.granted.push(code);
          }
        }
        _parseUnsubscribe() {
          debug("_parseUnsubscribe");
          const packet = this.packet;
          packet.unsubscriptions = [];
          if (!this._parseMessageId()) {
            return;
          }
          if (this.settings.protocolVersion === 5) {
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
          }
          if (packet.length <= 0) {
            return this._emitError(new Error("Malformed unsubscribe, no payload specified"));
          }
          while (this._pos < packet.length) {
            const topic = this._parseString();
            if (topic === null)
              return this._emitError(new Error("Cannot parse topic"));
            debug("_parseUnsubscribe: push topic `%s` to unsubscriptions", topic);
            packet.unsubscriptions.push(topic);
          }
        }
        _parseUnsuback() {
          debug("_parseUnsuback");
          const packet = this.packet;
          if (!this._parseMessageId())
            return this._emitError(new Error("Cannot parse messageId"));
          if ((this.settings.protocolVersion === 3 || this.settings.protocolVersion === 4) && packet.length !== 2) {
            return this._emitError(new Error("Malformed unsuback, payload length must be 2"));
          }
          if (packet.length <= 0) {
            return this._emitError(new Error("Malformed unsuback, no payload specified"));
          }
          if (this.settings.protocolVersion === 5) {
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
            packet.granted = [];
            while (this._pos < this.packet.length) {
              const code = this._list.readUInt8(this._pos++);
              if (!constants.MQTT5_UNSUBACK_CODES[code]) {
                return this._emitError(new Error("Invalid unsuback code"));
              }
              this.packet.granted.push(code);
            }
          }
        }
        // parse packets like puback, pubrec, pubrel, pubcomp
        _parseConfirmation() {
          debug("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
          const packet = this.packet;
          this._parseMessageId();
          if (this.settings.protocolVersion === 5) {
            if (packet.length > 2) {
              packet.reasonCode = this._parseByte();
              switch (this.packet.cmd) {
                case "puback":
                case "pubrec":
                  if (!constants.MQTT5_PUBACK_PUBREC_CODES[packet.reasonCode]) {
                    return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                  }
                  break;
                case "pubrel":
                case "pubcomp":
                  if (!constants.MQTT5_PUBREL_PUBCOMP_CODES[packet.reasonCode]) {
                    return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                  }
                  break;
              }
              debug("_parseConfirmation: packet.reasonCode `%d`", packet.reasonCode);
            } else {
              packet.reasonCode = 0;
            }
            if (packet.length > 3) {
              const properties = this._parseProperties();
              if (Object.getOwnPropertyNames(properties).length) {
                packet.properties = properties;
              }
            }
          }
          return true;
        }
        // parse disconnect packet
        _parseDisconnect() {
          const packet = this.packet;
          debug("_parseDisconnect");
          if (this.settings.protocolVersion === 5) {
            if (this._list.length > 0) {
              packet.reasonCode = this._parseByte();
              if (!constants.MQTT5_DISCONNECT_CODES[packet.reasonCode]) {
                this._emitError(new Error("Invalid disconnect reason code"));
              }
            } else {
              packet.reasonCode = 0;
            }
            const properties = this._parseProperties();
            if (Object.getOwnPropertyNames(properties).length) {
              packet.properties = properties;
            }
          }
          debug("_parseDisconnect result: true");
          return true;
        }
        // parse auth packet
        _parseAuth() {
          debug("_parseAuth");
          const packet = this.packet;
          if (this.settings.protocolVersion !== 5) {
            return this._emitError(new Error("Not supported auth packet for this version MQTT"));
          }
          packet.reasonCode = this._parseByte();
          if (!constants.MQTT5_AUTH_CODES[packet.reasonCode]) {
            return this._emitError(new Error("Invalid auth reason code"));
          }
          const properties = this._parseProperties();
          if (Object.getOwnPropertyNames(properties).length) {
            packet.properties = properties;
          }
          debug("_parseAuth: result: true");
          return true;
        }
        _parseMessageId() {
          const packet = this.packet;
          packet.messageId = this._parseNum();
          if (packet.messageId === null) {
            this._emitError(new Error("Cannot parse messageId"));
            return false;
          }
          debug("_parseMessageId: packet.messageId %d", packet.messageId);
          return true;
        }
        _parseString(maybeBuffer) {
          const length = this._parseNum();
          const end = length + this._pos;
          if (length === -1 || end > this._list.length || end > this.packet.length)
            return null;
          const result = this._list.toString("utf8", this._pos, end);
          this._pos += length;
          debug("_parseString: result: %s", result);
          return result;
        }
        _parseStringPair() {
          debug("_parseStringPair");
          return {
            name: this._parseString(),
            value: this._parseString()
          };
        }
        _parseBuffer() {
          const length = this._parseNum();
          const end = length + this._pos;
          if (length === -1 || end > this._list.length || end > this.packet.length)
            return null;
          const result = this._list.slice(this._pos, end);
          this._pos += length;
          debug("_parseBuffer: result: %o", result);
          return result;
        }
        _parseNum() {
          if (this._list.length - this._pos < 2)
            return -1;
          const result = this._list.readUInt16BE(this._pos);
          this._pos += 2;
          debug("_parseNum: result: %s", result);
          return result;
        }
        _parse4ByteNum() {
          if (this._list.length - this._pos < 4)
            return -1;
          const result = this._list.readUInt32BE(this._pos);
          this._pos += 4;
          debug("_parse4ByteNum: result: %s", result);
          return result;
        }
        _parseVarByteNum(fullInfoFlag) {
          debug("_parseVarByteNum");
          const maxBytes = 4;
          let bytes = 0;
          let mul = 1;
          let value = 0;
          let result = false;
          let current;
          const padding = this._pos ? this._pos : 0;
          while (bytes < maxBytes && padding + bytes < this._list.length) {
            current = this._list.readUInt8(padding + bytes++);
            value += mul * (current & constants.VARBYTEINT_MASK);
            mul *= 128;
            if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {
              result = true;
              break;
            }
            if (this._list.length <= bytes) {
              break;
            }
          }
          if (!result && bytes === maxBytes && this._list.length >= bytes) {
            this._emitError(new Error("Invalid variable byte integer"));
          }
          if (padding) {
            this._pos += bytes;
          }
          if (result) {
            if (fullInfoFlag) {
              result = { bytes, value };
            } else {
              result = value;
            }
          } else {
            result = false;
          }
          debug("_parseVarByteNum: result: %o", result);
          return result;
        }
        _parseByte() {
          let result;
          if (this._pos < this._list.length) {
            result = this._list.readUInt8(this._pos);
            this._pos++;
          }
          debug("_parseByte: result: %o", result);
          return result;
        }
        _parseByType(type) {
          debug("_parseByType: type: %s", type);
          switch (type) {
            case "byte": {
              return this._parseByte() !== 0;
            }
            case "int8": {
              return this._parseByte();
            }
            case "int16": {
              return this._parseNum();
            }
            case "int32": {
              return this._parse4ByteNum();
            }
            case "var": {
              return this._parseVarByteNum();
            }
            case "string": {
              return this._parseString();
            }
            case "pair": {
              return this._parseStringPair();
            }
            case "binary": {
              return this._parseBuffer();
            }
          }
        }
        _parseProperties() {
          debug("_parseProperties");
          const length = this._parseVarByteNum();
          const start = this._pos;
          const end = start + length;
          const result = {};
          while (this._pos < end) {
            const type = this._parseByte();
            if (!type) {
              this._emitError(new Error("Cannot parse property code type"));
              return false;
            }
            const name2 = constants.propertiesCodes[type];
            if (!name2) {
              this._emitError(new Error("Unknown property"));
              return false;
            }
            if (name2 === "userProperties") {
              if (!result[name2]) {
                result[name2] = /* @__PURE__ */ Object.create(null);
              }
              const currentUserProperty = this._parseByType(constants.propertiesTypes[name2]);
              if (result[name2][currentUserProperty.name]) {
                if (Array.isArray(result[name2][currentUserProperty.name])) {
                  result[name2][currentUserProperty.name].push(currentUserProperty.value);
                } else {
                  const currentValue = result[name2][currentUserProperty.name];
                  result[name2][currentUserProperty.name] = [currentValue];
                  result[name2][currentUserProperty.name].push(currentUserProperty.value);
                }
              } else {
                result[name2][currentUserProperty.name] = currentUserProperty.value;
              }
              continue;
            }
            if (result[name2]) {
              if (Array.isArray(result[name2])) {
                result[name2].push(this._parseByType(constants.propertiesTypes[name2]));
              } else {
                result[name2] = [result[name2]];
                result[name2].push(this._parseByType(constants.propertiesTypes[name2]));
              }
            } else {
              result[name2] = this._parseByType(constants.propertiesTypes[name2]);
            }
          }
          return result;
        }
        _newPacket() {
          debug("_newPacket");
          if (this.packet) {
            this._list.consume(this.packet.length);
            debug("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length);
            this.emit("packet", this.packet);
          }
          debug("_newPacket: new packet");
          this.packet = new Packet();
          this._pos = 0;
          return true;
        }
        _emitError(err) {
          debug("_emitError", err);
          this.error = err;
          this.emit("error", err);
        }
      };
      module.exports = Parser;
    }
  });

  // node_modules/mqtt-packet/numbers.js
  var require_numbers = __commonJS({
    "node_modules/mqtt-packet/numbers.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var max = 65536;
      var cache = {};
      var SubOk = Buffer3.isBuffer(Buffer3.from([1, 2]).subarray(0, 1));
      function generateBuffer(i6) {
        const buffer = Buffer3.allocUnsafe(2);
        buffer.writeUInt8(i6 >> 8, 0);
        buffer.writeUInt8(i6 & 255, 0 + 1);
        return buffer;
      }
      function generateCache() {
        for (let i6 = 0; i6 < max; i6++) {
          cache[i6] = generateBuffer(i6);
        }
      }
      function genBufVariableByteInt(num) {
        const maxLength = 4;
        let digit = 0;
        let pos = 0;
        const buffer = Buffer3.allocUnsafe(maxLength);
        do {
          digit = num % 128 | 0;
          num = num / 128 | 0;
          if (num > 0)
            digit = digit | 128;
          buffer.writeUInt8(digit, pos++);
        } while (num > 0 && pos < maxLength);
        if (num > 0) {
          pos = 0;
        }
        return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos);
      }
      function generate4ByteBuffer(num) {
        const buffer = Buffer3.allocUnsafe(4);
        buffer.writeUInt32BE(num, 0);
        return buffer;
      }
      module.exports = {
        cache,
        generateCache,
        generateNumber: generateBuffer,
        genBufVariableByteInt,
        generate4ByteBuffer
      };
    }
  });

  // node_modules/process-nextick-args/index.js
  var require_process_nextick_args = __commonJS({
    "node_modules/process-nextick-args/index.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      if (typeof process_exports === "undefined" || !process_exports.version || process_exports.version.indexOf("v0.") === 0 || process_exports.version.indexOf("v1.") === 0 && process_exports.version.indexOf("v1.8.") !== 0) {
        module.exports = { nextTick: nextTick2 };
      } else {
        module.exports = process_exports;
      }
      function nextTick2(fn, arg1, arg2, arg3) {
        if (typeof fn !== "function") {
          throw new TypeError('"callback" argument must be a function');
        }
        var len = arguments.length;
        var args, i6;
        switch (len) {
          case 0:
          case 1:
            return process_exports.nextTick(fn);
          case 2:
            return process_exports.nextTick(function afterTickOne() {
              fn.call(null, arg1);
            });
          case 3:
            return process_exports.nextTick(function afterTickTwo() {
              fn.call(null, arg1, arg2);
            });
          case 4:
            return process_exports.nextTick(function afterTickThree() {
              fn.call(null, arg1, arg2, arg3);
            });
          default:
            args = new Array(len - 1);
            i6 = 0;
            while (i6 < args.length) {
              args[i6++] = arguments[i6];
            }
            return process_exports.nextTick(function afterTick() {
              fn.apply(null, args);
            });
        }
      }
    }
  });

  // node_modules/mqtt-packet/writeToStream.js
  var require_writeToStream = __commonJS({
    "node_modules/mqtt-packet/writeToStream.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var protocol = require_constants();
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      var empty = Buffer3.allocUnsafe(0);
      var zeroBuf = Buffer3.from([0]);
      var numbers = require_numbers();
      var nextTick2 = require_process_nextick_args().nextTick;
      var debug = require_browser4()("mqtt-packet:writeToStream");
      var numCache = numbers.cache;
      var generateNumber = numbers.generateNumber;
      var generateCache = numbers.generateCache;
      var genBufVariableByteInt = numbers.genBufVariableByteInt;
      var generate4ByteBuffer = numbers.generate4ByteBuffer;
      var writeNumber = writeNumberCached;
      var toGenerate = true;
      function generate(packet, stream, opts) {
        debug("generate called");
        if (stream.cork) {
          stream.cork();
          nextTick2(uncork, stream);
        }
        if (toGenerate) {
          toGenerate = false;
          generateCache();
        }
        debug("generate: packet.cmd: %s", packet.cmd);
        switch (packet.cmd) {
          case "connect":
            return connect(packet, stream, opts);
          case "connack":
            return connack(packet, stream, opts);
          case "publish":
            return publish(packet, stream, opts);
          case "puback":
          case "pubrec":
          case "pubrel":
          case "pubcomp":
            return confirmation(packet, stream, opts);
          case "subscribe":
            return subscribe(packet, stream, opts);
          case "suback":
            return suback(packet, stream, opts);
          case "unsubscribe":
            return unsubscribe(packet, stream, opts);
          case "unsuback":
            return unsuback(packet, stream, opts);
          case "pingreq":
          case "pingresp":
            return emptyPacket(packet, stream, opts);
          case "disconnect":
            return disconnect(packet, stream, opts);
          case "auth":
            return auth(packet, stream, opts);
          default:
            stream.destroy(new Error("Unknown command"));
            return false;
        }
      }
      Object.defineProperty(generate, "cacheNumbers", {
        get() {
          return writeNumber === writeNumberCached;
        },
        set(value) {
          if (value) {
            if (!numCache || Object.keys(numCache).length === 0)
              toGenerate = true;
            writeNumber = writeNumberCached;
          } else {
            toGenerate = false;
            writeNumber = writeNumberGenerated;
          }
        }
      });
      function uncork(stream) {
        stream.uncork();
      }
      function connect(packet, stream, opts) {
        const settings = packet || {};
        const protocolId = settings.protocolId || "MQTT";
        let protocolVersion = settings.protocolVersion || 4;
        const will = settings.will;
        let clean = settings.clean;
        const keepalive = settings.keepalive || 0;
        const clientId = settings.clientId || "";
        const username = settings.username;
        const password = settings.password;
        const properties = settings.properties;
        if (clean === void 0)
          clean = true;
        let length = 0;
        if (!protocolId || typeof protocolId !== "string" && !Buffer3.isBuffer(protocolId)) {
          stream.destroy(new Error("Invalid protocolId"));
          return false;
        } else
          length += protocolId.length + 2;
        if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {
          stream.destroy(new Error("Invalid protocol version"));
          return false;
        } else
          length += 1;
        if ((typeof clientId === "string" || Buffer3.isBuffer(clientId)) && (clientId || protocolVersion >= 4) && (clientId || clean)) {
          length += Buffer3.byteLength(clientId) + 2;
        } else {
          if (protocolVersion < 4) {
            stream.destroy(new Error("clientId must be supplied before 3.1.1"));
            return false;
          }
          if (clean * 1 === 0) {
            stream.destroy(new Error("clientId must be given if cleanSession set to 0"));
            return false;
          }
        }
        if (typeof keepalive !== "number" || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {
          stream.destroy(new Error("Invalid keepalive"));
          return false;
        } else
          length += 2;
        length += 1;
        let propertiesData;
        let willProperties;
        if (protocolVersion === 5) {
          propertiesData = getProperties(stream, properties);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
        }
        if (will) {
          if (typeof will !== "object") {
            stream.destroy(new Error("Invalid will"));
            return false;
          }
          if (!will.topic || typeof will.topic !== "string") {
            stream.destroy(new Error("Invalid will topic"));
            return false;
          } else {
            length += Buffer3.byteLength(will.topic) + 2;
          }
          length += 2;
          if (will.payload) {
            if (will.payload.length >= 0) {
              if (typeof will.payload === "string") {
                length += Buffer3.byteLength(will.payload);
              } else {
                length += will.payload.length;
              }
            } else {
              stream.destroy(new Error("Invalid will payload"));
              return false;
            }
          }
          willProperties = {};
          if (protocolVersion === 5) {
            willProperties = getProperties(stream, will.properties);
            if (!willProperties) {
              return false;
            }
            length += willProperties.length;
          }
        }
        let providedUsername = false;
        if (username != null) {
          if (isStringOrBuffer(username)) {
            providedUsername = true;
            length += Buffer3.byteLength(username) + 2;
          } else {
            stream.destroy(new Error("Invalid username"));
            return false;
          }
        }
        if (password != null) {
          if (!providedUsername) {
            stream.destroy(new Error("Username is required to use password"));
            return false;
          }
          if (isStringOrBuffer(password)) {
            length += byteLength(password) + 2;
          } else {
            stream.destroy(new Error("Invalid password"));
            return false;
          }
        }
        stream.write(protocol.CONNECT_HEADER);
        writeVarByteInt(stream, length);
        writeStringOrBuffer(stream, protocolId);
        if (settings.bridgeMode) {
          protocolVersion += 128;
        }
        stream.write(
          protocolVersion === 131 ? protocol.VERSION131 : protocolVersion === 132 ? protocol.VERSION132 : protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3
        );
        let flags = 0;
        flags |= username != null ? protocol.USERNAME_MASK : 0;
        flags |= password != null ? protocol.PASSWORD_MASK : 0;
        flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;
        flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;
        flags |= will ? protocol.WILL_FLAG_MASK : 0;
        flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;
        stream.write(Buffer3.from([flags]));
        writeNumber(stream, keepalive);
        if (protocolVersion === 5) {
          propertiesData.write();
        }
        writeStringOrBuffer(stream, clientId);
        if (will) {
          if (protocolVersion === 5) {
            willProperties.write();
          }
          writeString(stream, will.topic);
          writeStringOrBuffer(stream, will.payload);
        }
        if (username != null) {
          writeStringOrBuffer(stream, username);
        }
        if (password != null) {
          writeStringOrBuffer(stream, password);
        }
        return true;
      }
      function connack(packet, stream, opts) {
        const version2 = opts ? opts.protocolVersion : 4;
        const settings = packet || {};
        const rc = version2 === 5 ? settings.reasonCode : settings.returnCode;
        const properties = settings.properties;
        let length = 2;
        if (typeof rc !== "number") {
          stream.destroy(new Error("Invalid return code"));
          return false;
        }
        let propertiesData = null;
        if (version2 === 5) {
          propertiesData = getProperties(stream, properties);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
        }
        stream.write(protocol.CONNACK_HEADER);
        writeVarByteInt(stream, length);
        stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);
        stream.write(Buffer3.from([rc]));
        if (propertiesData != null) {
          propertiesData.write();
        }
        return true;
      }
      function publish(packet, stream, opts) {
        debug("publish: packet: %o", packet);
        const version2 = opts ? opts.protocolVersion : 4;
        const settings = packet || {};
        const qos = settings.qos || 0;
        const retain = settings.retain ? protocol.RETAIN_MASK : 0;
        const topic = settings.topic;
        const payload = settings.payload || empty;
        const id = settings.messageId;
        const properties = settings.properties;
        let length = 0;
        if (typeof topic === "string")
          length += Buffer3.byteLength(topic) + 2;
        else if (Buffer3.isBuffer(topic))
          length += topic.length + 2;
        else {
          stream.destroy(new Error("Invalid topic"));
          return false;
        }
        if (!Buffer3.isBuffer(payload))
          length += Buffer3.byteLength(payload);
        else
          length += payload.length;
        if (qos && typeof id !== "number") {
          stream.destroy(new Error("Invalid messageId"));
          return false;
        } else if (qos)
          length += 2;
        let propertiesData = null;
        if (version2 === 5) {
          propertiesData = getProperties(stream, properties);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
        }
        stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]);
        writeVarByteInt(stream, length);
        writeNumber(stream, byteLength(topic));
        stream.write(topic);
        if (qos > 0)
          writeNumber(stream, id);
        if (propertiesData != null) {
          propertiesData.write();
        }
        debug("publish: payload: %o", payload);
        return stream.write(payload);
      }
      function confirmation(packet, stream, opts) {
        const version2 = opts ? opts.protocolVersion : 4;
        const settings = packet || {};
        const type = settings.cmd || "puback";
        const id = settings.messageId;
        const dup = settings.dup && type === "pubrel" ? protocol.DUP_MASK : 0;
        let qos = 0;
        const reasonCode = settings.reasonCode;
        const properties = settings.properties;
        let length = version2 === 5 ? 3 : 2;
        if (type === "pubrel")
          qos = 1;
        if (typeof id !== "number") {
          stream.destroy(new Error("Invalid messageId"));
          return false;
        }
        let propertiesData = null;
        if (version2 === 5) {
          if (typeof properties === "object") {
            propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
            if (!propertiesData) {
              return false;
            }
            length += propertiesData.length;
          }
        }
        stream.write(protocol.ACKS[type][qos][dup][0]);
        if (length === 3)
          length += reasonCode !== 0 ? 1 : -1;
        writeVarByteInt(stream, length);
        writeNumber(stream, id);
        if (version2 === 5 && length !== 2) {
          stream.write(Buffer3.from([reasonCode]));
        }
        if (propertiesData !== null) {
          propertiesData.write();
        } else {
          if (length === 4) {
            stream.write(Buffer3.from([0]));
          }
        }
        return true;
      }
      function subscribe(packet, stream, opts) {
        debug("subscribe: packet: ");
        const version2 = opts ? opts.protocolVersion : 4;
        const settings = packet || {};
        const dup = settings.dup ? protocol.DUP_MASK : 0;
        const id = settings.messageId;
        const subs = settings.subscriptions;
        const properties = settings.properties;
        let length = 0;
        if (typeof id !== "number") {
          stream.destroy(new Error("Invalid messageId"));
          return false;
        } else
          length += 2;
        let propertiesData = null;
        if (version2 === 5) {
          propertiesData = getProperties(stream, properties);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
        }
        if (typeof subs === "object" && subs.length) {
          for (let i6 = 0; i6 < subs.length; i6 += 1) {
            const itopic = subs[i6].topic;
            const iqos = subs[i6].qos;
            if (typeof itopic !== "string") {
              stream.destroy(new Error("Invalid subscriptions - invalid topic"));
              return false;
            }
            if (typeof iqos !== "number") {
              stream.destroy(new Error("Invalid subscriptions - invalid qos"));
              return false;
            }
            if (version2 === 5) {
              const nl = subs[i6].nl || false;
              if (typeof nl !== "boolean") {
                stream.destroy(new Error("Invalid subscriptions - invalid No Local"));
                return false;
              }
              const rap = subs[i6].rap || false;
              if (typeof rap !== "boolean") {
                stream.destroy(new Error("Invalid subscriptions - invalid Retain as Published"));
                return false;
              }
              const rh = subs[i6].rh || 0;
              if (typeof rh !== "number" || rh > 2) {
                stream.destroy(new Error("Invalid subscriptions - invalid Retain Handling"));
                return false;
              }
            }
            length += Buffer3.byteLength(itopic) + 2 + 1;
          }
        } else {
          stream.destroy(new Error("Invalid subscriptions"));
          return false;
        }
        debug("subscribe: writing to stream: %o", protocol.SUBSCRIBE_HEADER);
        stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);
        writeVarByteInt(stream, length);
        writeNumber(stream, id);
        if (propertiesData !== null) {
          propertiesData.write();
        }
        let result = true;
        for (const sub of subs) {
          const jtopic = sub.topic;
          const jqos = sub.qos;
          const jnl = +sub.nl;
          const jrap = +sub.rap;
          const jrh = sub.rh;
          let joptions;
          writeString(stream, jtopic);
          joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];
          if (version2 === 5) {
            joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;
            joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;
            joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;
          }
          result = stream.write(Buffer3.from([joptions]));
        }
        return result;
      }
      function suback(packet, stream, opts) {
        const version2 = opts ? opts.protocolVersion : 4;
        const settings = packet || {};
        const id = settings.messageId;
        const granted = settings.granted;
        const properties = settings.properties;
        let length = 0;
        if (typeof id !== "number") {
          stream.destroy(new Error("Invalid messageId"));
          return false;
        } else
          length += 2;
        if (typeof granted === "object" && granted.length) {
          for (let i6 = 0; i6 < granted.length; i6 += 1) {
            if (typeof granted[i6] !== "number") {
              stream.destroy(new Error("Invalid qos vector"));
              return false;
            }
            length += 1;
          }
        } else {
          stream.destroy(new Error("Invalid qos vector"));
          return false;
        }
        let propertiesData = null;
        if (version2 === 5) {
          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
        }
        stream.write(protocol.SUBACK_HEADER);
        writeVarByteInt(stream, length);
        writeNumber(stream, id);
        if (propertiesData !== null) {
          propertiesData.write();
        }
        return stream.write(Buffer3.from(granted));
      }
      function unsubscribe(packet, stream, opts) {
        const version2 = opts ? opts.protocolVersion : 4;
        const settings = packet || {};
        const id = settings.messageId;
        const dup = settings.dup ? protocol.DUP_MASK : 0;
        const unsubs = settings.unsubscriptions;
        const properties = settings.properties;
        let length = 0;
        if (typeof id !== "number") {
          stream.destroy(new Error("Invalid messageId"));
          return false;
        } else {
          length += 2;
        }
        if (typeof unsubs === "object" && unsubs.length) {
          for (let i6 = 0; i6 < unsubs.length; i6 += 1) {
            if (typeof unsubs[i6] !== "string") {
              stream.destroy(new Error("Invalid unsubscriptions"));
              return false;
            }
            length += Buffer3.byteLength(unsubs[i6]) + 2;
          }
        } else {
          stream.destroy(new Error("Invalid unsubscriptions"));
          return false;
        }
        let propertiesData = null;
        if (version2 === 5) {
          propertiesData = getProperties(stream, properties);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
        }
        stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);
        writeVarByteInt(stream, length);
        writeNumber(stream, id);
        if (propertiesData !== null) {
          propertiesData.write();
        }
        let result = true;
        for (let j2 = 0; j2 < unsubs.length; j2++) {
          result = writeString(stream, unsubs[j2]);
        }
        return result;
      }
      function unsuback(packet, stream, opts) {
        const version2 = opts ? opts.protocolVersion : 4;
        const settings = packet || {};
        const id = settings.messageId;
        const dup = settings.dup ? protocol.DUP_MASK : 0;
        const granted = settings.granted;
        const properties = settings.properties;
        const type = settings.cmd;
        const qos = 0;
        let length = 2;
        if (typeof id !== "number") {
          stream.destroy(new Error("Invalid messageId"));
          return false;
        }
        if (version2 === 5) {
          if (typeof granted === "object" && granted.length) {
            for (let i6 = 0; i6 < granted.length; i6 += 1) {
              if (typeof granted[i6] !== "number") {
                stream.destroy(new Error("Invalid qos vector"));
                return false;
              }
              length += 1;
            }
          } else {
            stream.destroy(new Error("Invalid qos vector"));
            return false;
          }
        }
        let propertiesData = null;
        if (version2 === 5) {
          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
        }
        stream.write(protocol.ACKS[type][qos][dup][0]);
        writeVarByteInt(stream, length);
        writeNumber(stream, id);
        if (propertiesData !== null) {
          propertiesData.write();
        }
        if (version2 === 5) {
          stream.write(Buffer3.from(granted));
        }
        return true;
      }
      function emptyPacket(packet, stream, opts) {
        return stream.write(protocol.EMPTY[packet.cmd]);
      }
      function disconnect(packet, stream, opts) {
        const version2 = opts ? opts.protocolVersion : 4;
        const settings = packet || {};
        const reasonCode = settings.reasonCode;
        const properties = settings.properties;
        let length = version2 === 5 ? 1 : 0;
        let propertiesData = null;
        if (version2 === 5) {
          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
          if (!propertiesData) {
            return false;
          }
          length += propertiesData.length;
        }
        stream.write(Buffer3.from([protocol.codes.disconnect << 4]));
        writeVarByteInt(stream, length);
        if (version2 === 5) {
          stream.write(Buffer3.from([reasonCode]));
        }
        if (propertiesData !== null) {
          propertiesData.write();
        }
        return true;
      }
      function auth(packet, stream, opts) {
        const version2 = opts ? opts.protocolVersion : 4;
        const settings = packet || {};
        const reasonCode = settings.reasonCode;
        const properties = settings.properties;
        let length = version2 === 5 ? 1 : 0;
        if (version2 !== 5)
          stream.destroy(new Error("Invalid mqtt version for auth packet"));
        const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);
        if (!propertiesData) {
          return false;
        }
        length += propertiesData.length;
        stream.write(Buffer3.from([protocol.codes.auth << 4]));
        writeVarByteInt(stream, length);
        stream.write(Buffer3.from([reasonCode]));
        if (propertiesData !== null) {
          propertiesData.write();
        }
        return true;
      }
      var varByteIntCache = {};
      function writeVarByteInt(stream, num) {
        if (num > protocol.VARBYTEINT_MAX) {
          stream.destroy(new Error(`Invalid variable byte integer: ${num}`));
          return false;
        }
        let buffer = varByteIntCache[num];
        if (!buffer) {
          buffer = genBufVariableByteInt(num);
          if (num < 16384)
            varByteIntCache[num] = buffer;
        }
        debug("writeVarByteInt: writing to stream: %o", buffer);
        return stream.write(buffer);
      }
      function writeString(stream, string) {
        const strlen = Buffer3.byteLength(string);
        writeNumber(stream, strlen);
        debug("writeString: %s", string);
        return stream.write(string, "utf8");
      }
      function writeStringPair(stream, name2, value) {
        writeString(stream, name2);
        writeString(stream, value);
      }
      function writeNumberCached(stream, number) {
        debug("writeNumberCached: number: %d", number);
        debug("writeNumberCached: %o", numCache[number]);
        return stream.write(numCache[number]);
      }
      function writeNumberGenerated(stream, number) {
        const generatedNumber = generateNumber(number);
        debug("writeNumberGenerated: %o", generatedNumber);
        return stream.write(generatedNumber);
      }
      function write4ByteNumber(stream, number) {
        const generated4ByteBuffer = generate4ByteBuffer(number);
        debug("write4ByteNumber: %o", generated4ByteBuffer);
        return stream.write(generated4ByteBuffer);
      }
      function writeStringOrBuffer(stream, toWrite) {
        if (typeof toWrite === "string") {
          writeString(stream, toWrite);
        } else if (toWrite) {
          writeNumber(stream, toWrite.length);
          stream.write(toWrite);
        } else
          writeNumber(stream, 0);
      }
      function getProperties(stream, properties) {
        if (typeof properties !== "object" || properties.length != null) {
          return {
            length: 1,
            write() {
              writeProperties(stream, {}, 0);
            }
          };
        }
        let propertiesLength = 0;
        function getLengthProperty(name2, value) {
          const type = protocol.propertiesTypes[name2];
          let length = 0;
          switch (type) {
            case "byte": {
              if (typeof value !== "boolean") {
                stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                return false;
              }
              length += 1 + 1;
              break;
            }
            case "int8": {
              if (typeof value !== "number" || value < 0 || value > 255) {
                stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                return false;
              }
              length += 1 + 1;
              break;
            }
            case "binary": {
              if (value && value === null) {
                stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                return false;
              }
              length += 1 + Buffer3.byteLength(value) + 2;
              break;
            }
            case "int16": {
              if (typeof value !== "number" || value < 0 || value > 65535) {
                stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                return false;
              }
              length += 1 + 2;
              break;
            }
            case "int32": {
              if (typeof value !== "number" || value < 0 || value > 4294967295) {
                stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                return false;
              }
              length += 1 + 4;
              break;
            }
            case "var": {
              if (typeof value !== "number" || value < 0 || value > 268435455) {
                stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                return false;
              }
              length += 1 + Buffer3.byteLength(genBufVariableByteInt(value));
              break;
            }
            case "string": {
              if (typeof value !== "string") {
                stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                return false;
              }
              length += 1 + 2 + Buffer3.byteLength(value.toString());
              break;
            }
            case "pair": {
              if (typeof value !== "object") {
                stream.destroy(new Error(`Invalid ${name2}: ${value}`));
                return false;
              }
              length += Object.getOwnPropertyNames(value).reduce((result, name3) => {
                const currentValue = value[name3];
                if (Array.isArray(currentValue)) {
                  result += currentValue.reduce((currentLength, value2) => {
                    currentLength += 1 + 2 + Buffer3.byteLength(name3.toString()) + 2 + Buffer3.byteLength(value2.toString());
                    return currentLength;
                  }, 0);
                } else {
                  result += 1 + 2 + Buffer3.byteLength(name3.toString()) + 2 + Buffer3.byteLength(value[name3].toString());
                }
                return result;
              }, 0);
              break;
            }
            default: {
              stream.destroy(new Error(`Invalid property ${name2}: ${value}`));
              return false;
            }
          }
          return length;
        }
        if (properties) {
          for (const propName in properties) {
            let propLength = 0;
            let propValueLength = 0;
            const propValue = properties[propName];
            if (Array.isArray(propValue)) {
              for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {
                propValueLength = getLengthProperty(propName, propValue[valueIndex]);
                if (!propValueLength) {
                  return false;
                }
                propLength += propValueLength;
              }
            } else {
              propValueLength = getLengthProperty(propName, propValue);
              if (!propValueLength) {
                return false;
              }
              propLength = propValueLength;
            }
            if (!propLength)
              return false;
            propertiesLength += propLength;
          }
        }
        const propertiesLengthLength = Buffer3.byteLength(genBufVariableByteInt(propertiesLength));
        return {
          length: propertiesLengthLength + propertiesLength,
          write() {
            writeProperties(stream, properties, propertiesLength);
          }
        };
      }
      function getPropertiesByMaximumPacketSize(stream, properties, opts, length) {
        const mayEmptyProps = ["reasonString", "userProperties"];
        const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;
        let propertiesData = getProperties(stream, properties);
        if (maximumPacketSize) {
          while (length + propertiesData.length > maximumPacketSize) {
            const currentMayEmptyProp = mayEmptyProps.shift();
            if (currentMayEmptyProp && properties[currentMayEmptyProp]) {
              delete properties[currentMayEmptyProp];
              propertiesData = getProperties(stream, properties);
            } else {
              return false;
            }
          }
        }
        return propertiesData;
      }
      function writeProperty(stream, propName, value) {
        const type = protocol.propertiesTypes[propName];
        switch (type) {
          case "byte": {
            stream.write(Buffer3.from([protocol.properties[propName]]));
            stream.write(Buffer3.from([+value]));
            break;
          }
          case "int8": {
            stream.write(Buffer3.from([protocol.properties[propName]]));
            stream.write(Buffer3.from([value]));
            break;
          }
          case "binary": {
            stream.write(Buffer3.from([protocol.properties[propName]]));
            writeStringOrBuffer(stream, value);
            break;
          }
          case "int16": {
            stream.write(Buffer3.from([protocol.properties[propName]]));
            writeNumber(stream, value);
            break;
          }
          case "int32": {
            stream.write(Buffer3.from([protocol.properties[propName]]));
            write4ByteNumber(stream, value);
            break;
          }
          case "var": {
            stream.write(Buffer3.from([protocol.properties[propName]]));
            writeVarByteInt(stream, value);
            break;
          }
          case "string": {
            stream.write(Buffer3.from([protocol.properties[propName]]));
            writeString(stream, value);
            break;
          }
          case "pair": {
            Object.getOwnPropertyNames(value).forEach((name2) => {
              const currentValue = value[name2];
              if (Array.isArray(currentValue)) {
                currentValue.forEach((value2) => {
                  stream.write(Buffer3.from([protocol.properties[propName]]));
                  writeStringPair(stream, name2.toString(), value2.toString());
                });
              } else {
                stream.write(Buffer3.from([protocol.properties[propName]]));
                writeStringPair(stream, name2.toString(), currentValue.toString());
              }
            });
            break;
          }
          default: {
            stream.destroy(new Error(`Invalid property ${propName} value: ${value}`));
            return false;
          }
        }
      }
      function writeProperties(stream, properties, propertiesLength) {
        writeVarByteInt(stream, propertiesLength);
        for (const propName in properties) {
          if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {
            const value = properties[propName];
            if (Array.isArray(value)) {
              for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {
                writeProperty(stream, propName, value[valueIndex]);
              }
            } else {
              writeProperty(stream, propName, value);
            }
          }
        }
      }
      function byteLength(bufOrString) {
        if (!bufOrString)
          return 0;
        else if (bufOrString instanceof Buffer3)
          return bufOrString.length;
        else
          return Buffer3.byteLength(bufOrString);
      }
      function isStringOrBuffer(field) {
        return typeof field === "string" || field instanceof Buffer3;
      }
      module.exports = generate;
    }
  });

  // node_modules/mqtt-packet/generate.js
  var require_generate = __commonJS({
    "node_modules/mqtt-packet/generate.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var writeToStream = require_writeToStream();
      var { EventEmitter: EventEmitter2 } = (init_events(), __toCommonJS(events_exports));
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(buffer_exports));
      function generate(packet, opts) {
        const stream = new Accumulator();
        writeToStream(packet, stream, opts);
        return stream.concat();
      }
      var Accumulator = class extends EventEmitter2 {
        constructor() {
          super();
          this._array = new Array(20);
          this._i = 0;
        }
        write(chunk) {
          this._array[this._i++] = chunk;
          return true;
        }
        concat() {
          let length = 0;
          const lengths = new Array(this._array.length);
          const list = this._array;
          let pos = 0;
          let i6;
          for (i6 = 0; i6 < list.length && list[i6] !== void 0; i6++) {
            if (typeof list[i6] !== "string")
              lengths[i6] = list[i6].length;
            else
              lengths[i6] = Buffer3.byteLength(list[i6]);
            length += lengths[i6];
          }
          const result = Buffer3.allocUnsafe(length);
          for (i6 = 0; i6 < list.length && list[i6] !== void 0; i6++) {
            if (typeof list[i6] !== "string") {
              list[i6].copy(result, pos);
              pos += lengths[i6];
            } else {
              result.write(list[i6], pos);
              pos += lengths[i6];
            }
          }
          return result;
        }
        destroy(err) {
          if (err)
            this.emit("error", err);
        }
      };
      module.exports = generate;
    }
  });

  // node_modules/mqtt-packet/mqtt.js
  var require_mqtt = __commonJS({
    "node_modules/mqtt-packet/mqtt.js"(exports5) {
      init_buffer2();
      init_process2();
      init_navigator();
      exports5.parser = require_parser().parser;
      exports5.generate = require_generate();
      exports5.writeToStream = require_writeToStream();
    }
  });

  // build/lib/default-message-id-provider.js
  var require_default_message_id_provider = __commonJS({
    "build/lib/default-message-id-provider.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      var DefaultMessageIdProvider = class {
        constructor() {
          this.nextId = Math.max(1, Math.floor(Math.random() * 65535));
        }
        allocate() {
          const id = this.nextId++;
          if (this.nextId === 65536) {
            this.nextId = 1;
          }
          return id;
        }
        getLastAllocated() {
          return this.nextId === 1 ? 65535 : this.nextId - 1;
        }
        register(messageId) {
          return true;
        }
        deallocate(messageId) {
        }
        clear() {
        }
      };
      exports5.default = DefaultMessageIdProvider;
    }
  });

  // node_modules/rfdc/index.js
  var require_rfdc = __commonJS({
    "node_modules/rfdc/index.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      module.exports = rfdc;
      function copyBuffer(cur) {
        if (cur instanceof Buffer2) {
          return Buffer2.from(cur);
        }
        return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
      }
      function rfdc(opts) {
        opts = opts || {};
        if (opts.circles)
          return rfdcCircles(opts);
        return opts.proto ? cloneProto : clone;
        function cloneArray(a6, fn) {
          var keys = Object.keys(a6);
          var a22 = new Array(keys.length);
          for (var i6 = 0; i6 < keys.length; i6++) {
            var k2 = keys[i6];
            var cur = a6[k2];
            if (typeof cur !== "object" || cur === null) {
              a22[k2] = cur;
            } else if (cur instanceof Date) {
              a22[k2] = new Date(cur);
            } else if (ArrayBuffer.isView(cur)) {
              a22[k2] = copyBuffer(cur);
            } else {
              a22[k2] = fn(cur);
            }
          }
          return a22;
        }
        function clone(o7) {
          if (typeof o7 !== "object" || o7 === null)
            return o7;
          if (o7 instanceof Date)
            return new Date(o7);
          if (Array.isArray(o7))
            return cloneArray(o7, clone);
          if (o7 instanceof Map)
            return new Map(cloneArray(Array.from(o7), clone));
          if (o7 instanceof Set)
            return new Set(cloneArray(Array.from(o7), clone));
          var o22 = {};
          for (var k2 in o7) {
            if (Object.hasOwnProperty.call(o7, k2) === false)
              continue;
            var cur = o7[k2];
            if (typeof cur !== "object" || cur === null) {
              o22[k2] = cur;
            } else if (cur instanceof Date) {
              o22[k2] = new Date(cur);
            } else if (cur instanceof Map) {
              o22[k2] = new Map(cloneArray(Array.from(cur), clone));
            } else if (cur instanceof Set) {
              o22[k2] = new Set(cloneArray(Array.from(cur), clone));
            } else if (ArrayBuffer.isView(cur)) {
              o22[k2] = copyBuffer(cur);
            } else {
              o22[k2] = clone(cur);
            }
          }
          return o22;
        }
        function cloneProto(o7) {
          if (typeof o7 !== "object" || o7 === null)
            return o7;
          if (o7 instanceof Date)
            return new Date(o7);
          if (Array.isArray(o7))
            return cloneArray(o7, cloneProto);
          if (o7 instanceof Map)
            return new Map(cloneArray(Array.from(o7), cloneProto));
          if (o7 instanceof Set)
            return new Set(cloneArray(Array.from(o7), cloneProto));
          var o22 = {};
          for (var k2 in o7) {
            var cur = o7[k2];
            if (typeof cur !== "object" || cur === null) {
              o22[k2] = cur;
            } else if (cur instanceof Date) {
              o22[k2] = new Date(cur);
            } else if (cur instanceof Map) {
              o22[k2] = new Map(cloneArray(Array.from(cur), cloneProto));
            } else if (cur instanceof Set) {
              o22[k2] = new Set(cloneArray(Array.from(cur), cloneProto));
            } else if (ArrayBuffer.isView(cur)) {
              o22[k2] = copyBuffer(cur);
            } else {
              o22[k2] = cloneProto(cur);
            }
          }
          return o22;
        }
      }
      function rfdcCircles(opts) {
        var refs = [];
        var refsNew = [];
        return opts.proto ? cloneProto : clone;
        function cloneArray(a6, fn) {
          var keys = Object.keys(a6);
          var a22 = new Array(keys.length);
          for (var i6 = 0; i6 < keys.length; i6++) {
            var k2 = keys[i6];
            var cur = a6[k2];
            if (typeof cur !== "object" || cur === null) {
              a22[k2] = cur;
            } else if (cur instanceof Date) {
              a22[k2] = new Date(cur);
            } else if (ArrayBuffer.isView(cur)) {
              a22[k2] = copyBuffer(cur);
            } else {
              var index = refs.indexOf(cur);
              if (index !== -1) {
                a22[k2] = refsNew[index];
              } else {
                a22[k2] = fn(cur);
              }
            }
          }
          return a22;
        }
        function clone(o7) {
          if (typeof o7 !== "object" || o7 === null)
            return o7;
          if (o7 instanceof Date)
            return new Date(o7);
          if (Array.isArray(o7))
            return cloneArray(o7, clone);
          if (o7 instanceof Map)
            return new Map(cloneArray(Array.from(o7), clone));
          if (o7 instanceof Set)
            return new Set(cloneArray(Array.from(o7), clone));
          var o22 = {};
          refs.push(o7);
          refsNew.push(o22);
          for (var k2 in o7) {
            if (Object.hasOwnProperty.call(o7, k2) === false)
              continue;
            var cur = o7[k2];
            if (typeof cur !== "object" || cur === null) {
              o22[k2] = cur;
            } else if (cur instanceof Date) {
              o22[k2] = new Date(cur);
            } else if (cur instanceof Map) {
              o22[k2] = new Map(cloneArray(Array.from(cur), clone));
            } else if (cur instanceof Set) {
              o22[k2] = new Set(cloneArray(Array.from(cur), clone));
            } else if (ArrayBuffer.isView(cur)) {
              o22[k2] = copyBuffer(cur);
            } else {
              var i6 = refs.indexOf(cur);
              if (i6 !== -1) {
                o22[k2] = refsNew[i6];
              } else {
                o22[k2] = clone(cur);
              }
            }
          }
          refs.pop();
          refsNew.pop();
          return o22;
        }
        function cloneProto(o7) {
          if (typeof o7 !== "object" || o7 === null)
            return o7;
          if (o7 instanceof Date)
            return new Date(o7);
          if (Array.isArray(o7))
            return cloneArray(o7, cloneProto);
          if (o7 instanceof Map)
            return new Map(cloneArray(Array.from(o7), cloneProto));
          if (o7 instanceof Set)
            return new Set(cloneArray(Array.from(o7), cloneProto));
          var o22 = {};
          refs.push(o7);
          refsNew.push(o22);
          for (var k2 in o7) {
            var cur = o7[k2];
            if (typeof cur !== "object" || cur === null) {
              o22[k2] = cur;
            } else if (cur instanceof Date) {
              o22[k2] = new Date(cur);
            } else if (cur instanceof Map) {
              o22[k2] = new Map(cloneArray(Array.from(cur), cloneProto));
            } else if (cur instanceof Set) {
              o22[k2] = new Set(cloneArray(Array.from(cur), cloneProto));
            } else if (ArrayBuffer.isView(cur)) {
              o22[k2] = copyBuffer(cur);
            } else {
              var i6 = refs.indexOf(cur);
              if (i6 !== -1) {
                o22[k2] = refsNew[i6];
              } else {
                o22[k2] = cloneProto(cur);
              }
            }
          }
          refs.pop();
          refsNew.pop();
          return o22;
        }
      }
    }
  });

  // node_modules/rfdc/default.js
  var require_default = __commonJS({
    "node_modules/rfdc/default.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      module.exports = require_rfdc()();
    }
  });

  // build/lib/validations.js
  var require_validations = __commonJS({
    "build/lib/validations.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      exports5.validateTopics = exports5.validateTopic = void 0;
      function validateTopic(topic) {
        const parts = topic.split("/");
        for (let i6 = 0; i6 < parts.length; i6++) {
          if (parts[i6] === "+") {
            continue;
          }
          if (parts[i6] === "#") {
            return i6 === parts.length - 1;
          }
          if (parts[i6].indexOf("+") !== -1 || parts[i6].indexOf("#") !== -1) {
            return false;
          }
        }
        return true;
      }
      exports5.validateTopic = validateTopic;
      function validateTopics(topics) {
        if (topics.length === 0) {
          return "empty_topic_list";
        }
        for (let i6 = 0; i6 < topics.length; i6++) {
          if (!validateTopic(topics[i6])) {
            return topics[i6];
          }
        }
        return null;
      }
      exports5.validateTopics = validateTopics;
    }
  });

  // build/lib/store.js
  var require_store = __commonJS({
    "build/lib/store.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      var readable_stream_1 = require_browser3();
      var streamsOpts = { objectMode: true };
      var defaultStoreOptions = {
        clean: true
      };
      var Store = class {
        constructor(options) {
          this.options = options || {};
          this.options = Object.assign(Object.assign({}, defaultStoreOptions), options);
          this._inflights = /* @__PURE__ */ new Map();
        }
        put(packet, cb) {
          this._inflights.set(packet.messageId, packet);
          if (cb) {
            cb();
          }
          return this;
        }
        createStream() {
          const stream = new readable_stream_1.Readable(streamsOpts);
          const values = [];
          let destroyed = false;
          let i6 = 0;
          this._inflights.forEach((value, key) => {
            values.push(value);
          });
          stream._read = () => {
            if (!destroyed && i6 < values.length) {
              stream.push(values[i6++]);
            } else {
              stream.push(null);
            }
          };
          stream.destroy = (err) => {
            if (destroyed) {
              return;
            }
            destroyed = true;
            setTimeout(() => {
              stream.emit("close");
            }, 0);
            return stream;
          };
          return stream;
        }
        del(packet, cb) {
          const toDelete = this._inflights.get(packet.messageId);
          if (toDelete) {
            this._inflights.delete(packet.messageId);
            cb(null, toDelete);
          } else if (cb) {
            cb(new Error("missing packet"));
          }
          return this;
        }
        get(packet, cb) {
          const storedPacket = this._inflights.get(packet.messageId);
          if (storedPacket) {
            cb(null, storedPacket);
          } else if (cb) {
            cb(new Error("missing packet"));
          }
          return this;
        }
        close(cb) {
          if (this.options.clean) {
            this._inflights = null;
          }
          if (cb) {
            cb();
          }
        }
      };
      exports5.default = Store;
    }
  });

  // build/lib/handlers/publish.js
  var require_publish = __commonJS({
    "build/lib/handlers/publish.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];
      var handlePublish = (client, packet, done) => {
        client.log("handlePublish: packet %o", packet);
        done = typeof done !== "undefined" ? done : client.noop;
        let topic = packet.topic.toString();
        const message = packet.payload;
        const { qos } = packet;
        const { messageId } = packet;
        const { options } = client;
        if (client.options.protocolVersion === 5) {
          let alias;
          if (packet.properties) {
            alias = packet.properties.topicAlias;
          }
          if (typeof alias !== "undefined") {
            if (topic.length === 0) {
              if (alias > 0 && alias <= 65535) {
                const gotTopic = client["topicAliasRecv"].getTopicByAlias(alias);
                if (gotTopic) {
                  topic = gotTopic;
                  client.log("handlePublish :: topic complemented by alias. topic: %s - alias: %d", topic, alias);
                } else {
                  client.log("handlePublish :: unregistered topic alias. alias: %d", alias);
                  client.emit("error", new Error("Received unregistered Topic Alias"));
                  return;
                }
              } else {
                client.log("handlePublish :: topic alias out of range. alias: %d", alias);
                client.emit("error", new Error("Received Topic Alias is out of range"));
                return;
              }
            } else if (client["topicAliasRecv"].put(topic, alias)) {
              client.log("handlePublish :: registered topic: %s - alias: %d", topic, alias);
            } else {
              client.log("handlePublish :: topic alias out of range. alias: %d", alias);
              client.emit("error", new Error("Received Topic Alias is out of range"));
              return;
            }
          }
        }
        client.log("handlePublish: qos %d", qos);
        switch (qos) {
          case 2: {
            options.customHandleAcks(topic, message, packet, (error, code) => {
              if (typeof error === "number") {
                code = error;
                error = null;
              }
              if (error) {
                return client.emit("error", error);
              }
              if (validReasonCodes.indexOf(code) === -1) {
                return client.emit("error", new Error("Wrong reason code for pubrec"));
              }
              if (code) {
                client["_sendPacket"]({ cmd: "pubrec", messageId, reasonCode: code }, done);
              } else {
                client.incomingStore.put(packet, () => {
                  client["_sendPacket"]({ cmd: "pubrec", messageId }, done);
                });
              }
            });
            break;
          }
          case 1: {
            options.customHandleAcks(topic, message, packet, (error, code) => {
              if (typeof error === "number") {
                code = error;
                error = null;
              }
              if (error) {
                return client.emit("error", error);
              }
              if (validReasonCodes.indexOf(code) === -1) {
                return client.emit("error", new Error("Wrong reason code for puback"));
              }
              if (!code) {
                client.emit("message", topic, message, packet);
              }
              client.handleMessage(packet, (err) => {
                if (err) {
                  return done && done(err);
                }
                client["_sendPacket"]({ cmd: "puback", messageId, reasonCode: code }, done);
              });
            });
            break;
          }
          case 0:
            client.emit("message", topic, message, packet);
            client.handleMessage(packet, done);
            break;
          default:
            client.log("handlePublish: unknown QoS. Doing nothing.");
            break;
        }
      };
      exports5.default = handlePublish;
    }
  });

  // package-json:../../package.json
  var require_package = __commonJS({
    "package-json:../../package.json"(exports5, module) {
      module.exports = { version: "5.5.4" };
    }
  });

  // build/lib/shared.js
  var require_shared = __commonJS({
    "build/lib/shared.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      exports5.MQTTJS_VERSION = exports5.nextTick = exports5.applyMixin = exports5.ErrorWithReasonCode = void 0;
      var ErrorWithReasonCode = class _ErrorWithReasonCode extends Error {
        constructor(message, code) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, _ErrorWithReasonCode.prototype);
          Object.getPrototypeOf(this).name = "ErrorWithReasonCode";
        }
      };
      exports5.ErrorWithReasonCode = ErrorWithReasonCode;
      function applyMixin(target, mixin, includeConstructor = false) {
        var _a;
        const inheritanceChain = [mixin];
        while (true) {
          const current = inheritanceChain[0];
          const base = Object.getPrototypeOf(current);
          if (base === null || base === void 0 ? void 0 : base.prototype) {
            inheritanceChain.unshift(base);
          } else {
            break;
          }
        }
        for (const ctor of inheritanceChain) {
          for (const prop of Object.getOwnPropertyNames(ctor.prototype)) {
            if (includeConstructor || prop !== "constructor") {
              Object.defineProperty(target.prototype, prop, (_a = Object.getOwnPropertyDescriptor(ctor.prototype, prop)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ Object.create(null));
            }
          }
        }
      }
      exports5.applyMixin = applyMixin;
      exports5.nextTick = typeof (process_exports === null || process_exports === void 0 ? void 0 : process_exports.nextTick) === "function" ? process_exports.nextTick : (callback) => {
        setTimeout(callback, 0);
      };
      exports5.MQTTJS_VERSION = require_package().version;
    }
  });

  // build/lib/handlers/ack.js
  var require_ack = __commonJS({
    "build/lib/handlers/ack.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      exports5.ReasonCodes = void 0;
      exports5.ReasonCodes = {
        0: "",
        1: "Unacceptable protocol version",
        2: "Identifier rejected",
        3: "Server unavailable",
        4: "Bad username or password",
        5: "Not authorized",
        16: "No matching subscribers",
        17: "No subscription existed",
        128: "Unspecified error",
        129: "Malformed Packet",
        130: "Protocol Error",
        131: "Implementation specific error",
        132: "Unsupported Protocol Version",
        133: "Client Identifier not valid",
        134: "Bad User Name or Password",
        135: "Not authorized",
        136: "Server unavailable",
        137: "Server busy",
        138: "Banned",
        139: "Server shutting down",
        140: "Bad authentication method",
        141: "Keep Alive timeout",
        142: "Session taken over",
        143: "Topic Filter invalid",
        144: "Topic Name invalid",
        145: "Packet identifier in use",
        146: "Packet Identifier not found",
        147: "Receive Maximum exceeded",
        148: "Topic Alias invalid",
        149: "Packet too large",
        150: "Message rate too high",
        151: "Quota exceeded",
        152: "Administrative action",
        153: "Payload format invalid",
        154: "Retain not supported",
        155: "QoS not supported",
        156: "Use another server",
        157: "Server moved",
        158: "Shared Subscriptions not supported",
        159: "Connection rate exceeded",
        160: "Maximum connect time",
        161: "Subscription Identifiers not supported",
        162: "Wildcard Subscriptions not supported"
      };
      var handleAck = (client, packet) => {
        const { messageId } = packet;
        const type = packet.cmd;
        let response = null;
        const cb = client.outgoing[messageId] ? client.outgoing[messageId].cb : null;
        let err;
        if (!cb) {
          client.log("_handleAck :: Server sent an ack in error. Ignoring.");
          return;
        }
        client.log("_handleAck :: packet type", type);
        switch (type) {
          case "pubcomp":
          case "puback": {
            const pubackRC = packet.reasonCode;
            if (pubackRC && pubackRC > 0 && pubackRC !== 16) {
              err = new Error(`Publish error: ${exports5.ReasonCodes[pubackRC]}`);
              err.code = pubackRC;
              client["_removeOutgoingAndStoreMessage"](messageId, () => {
                cb(err, packet);
              });
            } else {
              client["_removeOutgoingAndStoreMessage"](messageId, cb);
            }
            break;
          }
          case "pubrec": {
            response = {
              cmd: "pubrel",
              qos: 2,
              messageId
            };
            const pubrecRC = packet.reasonCode;
            if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {
              err = new Error(`Publish error: ${exports5.ReasonCodes[pubrecRC]}`);
              err.code = pubrecRC;
              client["_removeOutgoingAndStoreMessage"](messageId, () => {
                cb(err, packet);
              });
            } else {
              client["_sendPacket"](response);
            }
            break;
          }
          case "suback": {
            delete client.outgoing[messageId];
            client.messageIdProvider.deallocate(messageId);
            const granted = packet.granted;
            for (let grantedI = 0; grantedI < granted.length; grantedI++) {
              if ((granted[grantedI] & 128) !== 0) {
                const topics = client.messageIdToTopic[messageId];
                if (topics) {
                  topics.forEach((topic) => {
                    delete client["_resubscribeTopics"][topic];
                  });
                }
              }
            }
            delete client.messageIdToTopic[messageId];
            client["_invokeStoreProcessingQueue"]();
            cb(null, packet);
            break;
          }
          case "unsuback": {
            delete client.outgoing[messageId];
            client.messageIdProvider.deallocate(messageId);
            client["_invokeStoreProcessingQueue"]();
            cb(null);
            break;
          }
          default:
            client.emit("error", new Error("unrecognized packet type"));
        }
        if (client.disconnecting && Object.keys(client.outgoing).length === 0) {
          client.emit("outgoingEmpty");
        }
      };
      exports5.default = handleAck;
    }
  });

  // build/lib/handlers/auth.js
  var require_auth = __commonJS({
    "build/lib/handlers/auth.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      var shared_1 = require_shared();
      var ack_1 = require_ack();
      var handleAuth = (client, packet) => {
        const { options } = client;
        const version2 = options.protocolVersion;
        const rc = version2 === 5 ? packet.reasonCode : packet.returnCode;
        if (version2 !== 5) {
          const err = new shared_1.ErrorWithReasonCode(`Protocol error: Auth packets are only supported in MQTT 5. Your version:${version2}`, rc);
          client.emit("error", err);
          return;
        }
        client.handleAuth(packet, (err, packet2) => {
          if (err) {
            client.emit("error", err);
            return;
          }
          if (rc === 24) {
            client.reconnecting = false;
            client["_sendPacket"](packet2);
          } else {
            const error = new shared_1.ErrorWithReasonCode(`Connection refused: ${ack_1.ReasonCodes[rc]}`, rc);
            client.emit("error", error);
          }
        });
      };
      exports5.default = handleAuth;
    }
  });

  // node_modules/lru-cache/dist/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/lru-cache/dist/cjs/index.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      exports5.LRUCache = void 0;
      var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
      var warned = /* @__PURE__ */ new Set();
      var PROCESS = typeof process_exports === "object" && !!process_exports ? process_exports : {};
      var emitWarning2 = (msg, type, code, fn) => {
        typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
      };
      var AC = globalThis.AbortController;
      var AS = globalThis.AbortSignal;
      if (typeof AC === "undefined") {
        AS = class AbortSignal {
          onabort;
          _onabort = [];
          reason;
          aborted = false;
          addEventListener(_2, fn) {
            this._onabort.push(fn);
          }
        };
        AC = class AbortController {
          constructor() {
            warnACPolyfill();
          }
          signal = new AS();
          abort(reason) {
            if (this.signal.aborted)
              return;
            this.signal.reason = reason;
            this.signal.aborted = true;
            for (const fn of this.signal._onabort) {
              fn(reason);
            }
            this.signal.onabort?.(reason);
          }
        };
        let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
        const warnACPolyfill = () => {
          if (!printACPolyfillWarning)
            return;
          printACPolyfillWarning = false;
          emitWarning2("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
        };
      }
      var shouldWarn = (code) => !warned.has(code);
      var TYPE = Symbol("type");
      var isPosInt = (n7) => n7 && n7 === Math.floor(n7) && n7 > 0 && isFinite(n7);
      var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
      var ZeroArray = class extends Array {
        constructor(size) {
          super(size);
          this.fill(0);
        }
      };
      var Stack = class _Stack {
        heap;
        length;
        // private constructor
        static #constructing = false;
        static create(max) {
          const HeapCls = getUintArray(max);
          if (!HeapCls)
            return [];
          _Stack.#constructing = true;
          const s5 = new _Stack(max, HeapCls);
          _Stack.#constructing = false;
          return s5;
        }
        constructor(max, HeapCls) {
          if (!_Stack.#constructing) {
            throw new TypeError("instantiate Stack using Stack.create(n)");
          }
          this.heap = new HeapCls(max);
          this.length = 0;
        }
        push(n7) {
          this.heap[this.length++] = n7;
        }
        pop() {
          return this.heap[--this.length];
        }
      };
      var LRUCache = class _LRUCache {
        // properties coming in from the options of these, only max and maxSize
        // really *need* to be protected. The rest can be modified, as they just
        // set defaults for various methods.
        #max;
        #maxSize;
        #dispose;
        #disposeAfter;
        #fetchMethod;
        /**
         * {@link LRUCache.OptionsBase.ttl}
         */
        ttl;
        /**
         * {@link LRUCache.OptionsBase.ttlResolution}
         */
        ttlResolution;
        /**
         * {@link LRUCache.OptionsBase.ttlAutopurge}
         */
        ttlAutopurge;
        /**
         * {@link LRUCache.OptionsBase.updateAgeOnGet}
         */
        updateAgeOnGet;
        /**
         * {@link LRUCache.OptionsBase.updateAgeOnHas}
         */
        updateAgeOnHas;
        /**
         * {@link LRUCache.OptionsBase.allowStale}
         */
        allowStale;
        /**
         * {@link LRUCache.OptionsBase.noDisposeOnSet}
         */
        noDisposeOnSet;
        /**
         * {@link LRUCache.OptionsBase.noUpdateTTL}
         */
        noUpdateTTL;
        /**
         * {@link LRUCache.OptionsBase.maxEntrySize}
         */
        maxEntrySize;
        /**
         * {@link LRUCache.OptionsBase.sizeCalculation}
         */
        sizeCalculation;
        /**
         * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
         */
        noDeleteOnFetchRejection;
        /**
         * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
         */
        noDeleteOnStaleGet;
        /**
         * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
         */
        allowStaleOnFetchAbort;
        /**
         * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
         */
        allowStaleOnFetchRejection;
        /**
         * {@link LRUCache.OptionsBase.ignoreFetchAbort}
         */
        ignoreFetchAbort;
        // computed properties
        #size;
        #calculatedSize;
        #keyMap;
        #keyList;
        #valList;
        #next;
        #prev;
        #head;
        #tail;
        #free;
        #disposed;
        #sizes;
        #starts;
        #ttls;
        #hasDispose;
        #hasFetchMethod;
        #hasDisposeAfter;
        /**
         * Do not call this method unless you need to inspect the
         * inner workings of the cache.  If anything returned by this
         * object is modified in any way, strange breakage may occur.
         *
         * These fields are private for a reason!
         *
         * @internal
         */
        static unsafeExposeInternals(c6) {
          return {
            // properties
            starts: c6.#starts,
            ttls: c6.#ttls,
            sizes: c6.#sizes,
            keyMap: c6.#keyMap,
            keyList: c6.#keyList,
            valList: c6.#valList,
            next: c6.#next,
            prev: c6.#prev,
            get head() {
              return c6.#head;
            },
            get tail() {
              return c6.#tail;
            },
            free: c6.#free,
            // methods
            isBackgroundFetch: (p6) => c6.#isBackgroundFetch(p6),
            backgroundFetch: (k2, index, options, context) => c6.#backgroundFetch(k2, index, options, context),
            moveToTail: (index) => c6.#moveToTail(index),
            indexes: (options) => c6.#indexes(options),
            rindexes: (options) => c6.#rindexes(options),
            isStale: (index) => c6.#isStale(index)
          };
        }
        // Protected read-only members
        /**
         * {@link LRUCache.OptionsBase.max} (read-only)
         */
        get max() {
          return this.#max;
        }
        /**
         * {@link LRUCache.OptionsBase.maxSize} (read-only)
         */
        get maxSize() {
          return this.#maxSize;
        }
        /**
         * The total computed size of items in the cache (read-only)
         */
        get calculatedSize() {
          return this.#calculatedSize;
        }
        /**
         * The number of items stored in the cache (read-only)
         */
        get size() {
          return this.#size;
        }
        /**
         * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
         */
        get fetchMethod() {
          return this.#fetchMethod;
        }
        /**
         * {@link LRUCache.OptionsBase.dispose} (read-only)
         */
        get dispose() {
          return this.#dispose;
        }
        /**
         * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
         */
        get disposeAfter() {
          return this.#disposeAfter;
        }
        constructor(options) {
          const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
          if (max !== 0 && !isPosInt(max)) {
            throw new TypeError("max option must be a nonnegative integer");
          }
          const UintArray = max ? getUintArray(max) : Array;
          if (!UintArray) {
            throw new Error("invalid max value: " + max);
          }
          this.#max = max;
          this.#maxSize = maxSize;
          this.maxEntrySize = maxEntrySize || this.#maxSize;
          this.sizeCalculation = sizeCalculation;
          if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
              throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
            }
            if (typeof this.sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation set to non-function");
            }
          }
          if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
            throw new TypeError("fetchMethod must be a function if specified");
          }
          this.#fetchMethod = fetchMethod;
          this.#hasFetchMethod = !!fetchMethod;
          this.#keyMap = /* @__PURE__ */ new Map();
          this.#keyList = new Array(max).fill(void 0);
          this.#valList = new Array(max).fill(void 0);
          this.#next = new UintArray(max);
          this.#prev = new UintArray(max);
          this.#head = 0;
          this.#tail = 0;
          this.#free = Stack.create(max);
          this.#size = 0;
          this.#calculatedSize = 0;
          if (typeof dispose === "function") {
            this.#dispose = dispose;
          }
          if (typeof disposeAfter === "function") {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
          } else {
            this.#disposeAfter = void 0;
            this.#disposed = void 0;
          }
          this.#hasDispose = !!this.#dispose;
          this.#hasDisposeAfter = !!this.#disposeAfter;
          this.noDisposeOnSet = !!noDisposeOnSet;
          this.noUpdateTTL = !!noUpdateTTL;
          this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
          this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
          this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
          this.ignoreFetchAbort = !!ignoreFetchAbort;
          if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
              if (!isPosInt(this.#maxSize)) {
                throw new TypeError("maxSize must be a positive integer if specified");
              }
            }
            if (!isPosInt(this.maxEntrySize)) {
              throw new TypeError("maxEntrySize must be a positive integer if specified");
            }
            this.#initializeSizeTracking();
          }
          this.allowStale = !!allowStale;
          this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
          this.updateAgeOnGet = !!updateAgeOnGet;
          this.updateAgeOnHas = !!updateAgeOnHas;
          this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
          this.ttlAutopurge = !!ttlAutopurge;
          this.ttl = ttl || 0;
          if (this.ttl) {
            if (!isPosInt(this.ttl)) {
              throw new TypeError("ttl must be a positive integer if specified");
            }
            this.#initializeTTLTracking();
          }
          if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError("At least one of max, maxSize, or ttl is required");
          }
          if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = "LRU_CACHE_UNBOUNDED";
            if (shouldWarn(code)) {
              warned.add(code);
              const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
              emitWarning2(msg, "UnboundedCacheWarning", code, _LRUCache);
            }
          }
        }
        /**
         * Return the remaining TTL time for a given entry key
         */
        getRemainingTTL(key) {
          return this.#keyMap.has(key) ? Infinity : 0;
        }
        #initializeTTLTracking() {
          const ttls = new ZeroArray(this.#max);
          const starts = new ZeroArray(this.#max);
          this.#ttls = ttls;
          this.#starts = starts;
          this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
              const t6 = setTimeout(() => {
                if (this.#isStale(index)) {
                  this.delete(this.#keyList[index]);
                }
              }, ttl + 1);
              if (t6.unref) {
                t6.unref();
              }
            }
          };
          this.#updateItemAge = (index) => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
          };
          this.#statusTTL = (status, index) => {
            if (ttls[index]) {
              const ttl = ttls[index];
              const start = starts[index];
              status.ttl = ttl;
              status.start = start;
              status.now = cachedNow || getNow();
              const age = status.now - start;
              status.remainingTTL = ttl - age;
            }
          };
          let cachedNow = 0;
          const getNow = () => {
            const n7 = perf.now();
            if (this.ttlResolution > 0) {
              cachedNow = n7;
              const t6 = setTimeout(() => cachedNow = 0, this.ttlResolution);
              if (t6.unref) {
                t6.unref();
              }
            }
            return n7;
          };
          this.getRemainingTTL = (key) => {
            const index = this.#keyMap.get(key);
            if (index === void 0) {
              return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (ttl === 0 || start === 0) {
              return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
          };
          this.#isStale = (index) => {
            return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
          };
        }
        // conditionally set private methods related to TTL
        #updateItemAge = () => {
        };
        #statusTTL = () => {
        };
        #setItemTTL = () => {
        };
        /* c8 ignore stop */
        #isStale = () => false;
        #initializeSizeTracking() {
          const sizes = new ZeroArray(this.#max);
          this.#calculatedSize = 0;
          this.#sizes = sizes;
          this.#removeItemSize = (index) => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
          };
          this.#requireSize = (k2, v4, size, sizeCalculation) => {
            if (this.#isBackgroundFetch(v4)) {
              return 0;
            }
            if (!isPosInt(size)) {
              if (sizeCalculation) {
                if (typeof sizeCalculation !== "function") {
                  throw new TypeError("sizeCalculation must be a function");
                }
                size = sizeCalculation(v4, k2);
                if (!isPosInt(size)) {
                  throw new TypeError("sizeCalculation return invalid (expect positive integer)");
                }
              } else {
                throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
              }
            }
            return size;
          };
          this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
              const maxSize = this.#maxSize - sizes[index];
              while (this.#calculatedSize > maxSize) {
                this.#evict(true);
              }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
              status.entrySize = size;
              status.totalCalculatedSize = this.#calculatedSize;
            }
          };
        }
        #removeItemSize = (_i) => {
        };
        #addItemSize = (_i, _s, _st) => {
        };
        #requireSize = (_k, _v, size, sizeCalculation) => {
          if (size || sizeCalculation) {
            throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
          }
          return 0;
        };
        *#indexes({ allowStale = this.allowStale } = {}) {
          if (this.#size) {
            for (let i6 = this.#tail; true; ) {
              if (!this.#isValidIndex(i6)) {
                break;
              }
              if (allowStale || !this.#isStale(i6)) {
                yield i6;
              }
              if (i6 === this.#head) {
                break;
              } else {
                i6 = this.#prev[i6];
              }
            }
          }
        }
        *#rindexes({ allowStale = this.allowStale } = {}) {
          if (this.#size) {
            for (let i6 = this.#head; true; ) {
              if (!this.#isValidIndex(i6)) {
                break;
              }
              if (allowStale || !this.#isStale(i6)) {
                yield i6;
              }
              if (i6 === this.#tail) {
                break;
              } else {
                i6 = this.#next[i6];
              }
            }
          }
        }
        #isValidIndex(index) {
          return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
        }
        /**
         * Return a generator yielding `[key, value]` pairs,
         * in order from most recently used to least recently used.
         */
        *entries() {
          for (const i6 of this.#indexes()) {
            if (this.#valList[i6] !== void 0 && this.#keyList[i6] !== void 0 && !this.#isBackgroundFetch(this.#valList[i6])) {
              yield [this.#keyList[i6], this.#valList[i6]];
            }
          }
        }
        /**
         * Inverse order version of {@link LRUCache.entries}
         *
         * Return a generator yielding `[key, value]` pairs,
         * in order from least recently used to most recently used.
         */
        *rentries() {
          for (const i6 of this.#rindexes()) {
            if (this.#valList[i6] !== void 0 && this.#keyList[i6] !== void 0 && !this.#isBackgroundFetch(this.#valList[i6])) {
              yield [this.#keyList[i6], this.#valList[i6]];
            }
          }
        }
        /**
         * Return a generator yielding the keys in the cache,
         * in order from most recently used to least recently used.
         */
        *keys() {
          for (const i6 of this.#indexes()) {
            const k2 = this.#keyList[i6];
            if (k2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i6])) {
              yield k2;
            }
          }
        }
        /**
         * Inverse order version of {@link LRUCache.keys}
         *
         * Return a generator yielding the keys in the cache,
         * in order from least recently used to most recently used.
         */
        *rkeys() {
          for (const i6 of this.#rindexes()) {
            const k2 = this.#keyList[i6];
            if (k2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i6])) {
              yield k2;
            }
          }
        }
        /**
         * Return a generator yielding the values in the cache,
         * in order from most recently used to least recently used.
         */
        *values() {
          for (const i6 of this.#indexes()) {
            const v4 = this.#valList[i6];
            if (v4 !== void 0 && !this.#isBackgroundFetch(this.#valList[i6])) {
              yield this.#valList[i6];
            }
          }
        }
        /**
         * Inverse order version of {@link LRUCache.values}
         *
         * Return a generator yielding the values in the cache,
         * in order from least recently used to most recently used.
         */
        *rvalues() {
          for (const i6 of this.#rindexes()) {
            const v4 = this.#valList[i6];
            if (v4 !== void 0 && !this.#isBackgroundFetch(this.#valList[i6])) {
              yield this.#valList[i6];
            }
          }
        }
        /**
         * Iterating over the cache itself yields the same results as
         * {@link LRUCache.entries}
         */
        [Symbol.iterator]() {
          return this.entries();
        }
        /**
         * Find a value for which the supplied fn method returns a truthy value,
         * similar to Array.find().  fn is called as fn(value, key, cache).
         */
        find(fn, getOptions = {}) {
          for (const i6 of this.#indexes()) {
            const v4 = this.#valList[i6];
            const value = this.#isBackgroundFetch(v4) ? v4.__staleWhileFetching : v4;
            if (value === void 0)
              continue;
            if (fn(value, this.#keyList[i6], this)) {
              return this.get(this.#keyList[i6], getOptions);
            }
          }
        }
        /**
         * Call the supplied function on each item in the cache, in order from
         * most recently used to least recently used.  fn is called as
         * fn(value, key, cache).  Does not update age or recenty of use.
         * Does not iterate over stale values.
         */
        forEach(fn, thisp = this) {
          for (const i6 of this.#indexes()) {
            const v4 = this.#valList[i6];
            const value = this.#isBackgroundFetch(v4) ? v4.__staleWhileFetching : v4;
            if (value === void 0)
              continue;
            fn.call(thisp, value, this.#keyList[i6], this);
          }
        }
        /**
         * The same as {@link LRUCache.forEach} but items are iterated over in
         * reverse order.  (ie, less recently used items are iterated over first.)
         */
        rforEach(fn, thisp = this) {
          for (const i6 of this.#rindexes()) {
            const v4 = this.#valList[i6];
            const value = this.#isBackgroundFetch(v4) ? v4.__staleWhileFetching : v4;
            if (value === void 0)
              continue;
            fn.call(thisp, value, this.#keyList[i6], this);
          }
        }
        /**
         * Delete any stale entries. Returns true if anything was removed,
         * false otherwise.
         */
        purgeStale() {
          let deleted = false;
          for (const i6 of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i6)) {
              this.delete(this.#keyList[i6]);
              deleted = true;
            }
          }
          return deleted;
        }
        /**
         * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
         * passed to cache.load()
         */
        dump() {
          const arr = [];
          for (const i6 of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i6];
            const v4 = this.#valList[i6];
            const value = this.#isBackgroundFetch(v4) ? v4.__staleWhileFetching : v4;
            if (value === void 0 || key === void 0)
              continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
              entry.ttl = this.#ttls[i6];
              const age = perf.now() - this.#starts[i6];
              entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
              entry.size = this.#sizes[i6];
            }
            arr.unshift([key, entry]);
          }
          return arr;
        }
        /**
         * Reset the cache and load in the items in entries in the order listed.
         * Note that the shape of the resulting cache may be different if the
         * same options are not used in both caches.
         */
        load(arr) {
          this.clear();
          for (const [key, entry] of arr) {
            if (entry.start) {
              const age = Date.now() - entry.start;
              entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
          }
        }
        /**
         * Add a value to the cache.
         *
         * Note: if `undefined` is specified as a value, this is an alias for
         * {@link LRUCache#delete}
         */
        set(k2, v4, setOptions = {}) {
          if (v4 === void 0) {
            this.delete(k2);
            return this;
          }
          const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
          let { noUpdateTTL = this.noUpdateTTL } = setOptions;
          const size = this.#requireSize(k2, v4, setOptions.size || 0, sizeCalculation);
          if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
              status.set = "miss";
              status.maxEntrySizeExceeded = true;
            }
            this.delete(k2);
            return this;
          }
          let index = this.#size === 0 ? void 0 : this.#keyMap.get(k2);
          if (index === void 0) {
            index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
            this.#keyList[index] = k2;
            this.#valList[index] = v4;
            this.#keyMap.set(k2, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
              status.set = "add";
            noUpdateTTL = false;
          } else {
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v4 !== oldVal) {
              if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                oldVal.__abortController.abort(new Error("replaced"));
                const { __staleWhileFetching: s5 } = oldVal;
                if (s5 !== void 0 && !noDisposeOnSet) {
                  if (this.#hasDispose) {
                    this.#dispose?.(s5, k2, "set");
                  }
                  if (this.#hasDisposeAfter) {
                    this.#disposed?.push([s5, k2, "set"]);
                  }
                }
              } else if (!noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(oldVal, k2, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([oldVal, k2, "set"]);
                }
              }
              this.#removeItemSize(index);
              this.#addItemSize(index, size, status);
              this.#valList[index] = v4;
              if (status) {
                status.set = "replace";
                const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
                if (oldValue !== void 0)
                  status.oldValue = oldValue;
              }
            } else if (status) {
              status.set = "update";
            }
          }
          if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
          }
          if (this.#ttls) {
            if (!noUpdateTTL) {
              this.#setItemTTL(index, ttl, start);
            }
            if (status)
              this.#statusTTL(status, index);
          }
          if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
          return this;
        }
        /**
         * Evict the least recently used item, returning its value or
         * `undefined` if cache is empty.
         */
        pop() {
          try {
            while (this.#size) {
              const val = this.#valList[this.#head];
              this.#evict(true);
              if (this.#isBackgroundFetch(val)) {
                if (val.__staleWhileFetching) {
                  return val.__staleWhileFetching;
                }
              } else if (val !== void 0) {
                return val;
              }
            }
          } finally {
            if (this.#hasDisposeAfter && this.#disposed) {
              const dt = this.#disposed;
              let task;
              while (task = dt?.shift()) {
                this.#disposeAfter?.(...task);
              }
            }
          }
        }
        #evict(free) {
          const head = this.#head;
          const k2 = this.#keyList[head];
          const v4 = this.#valList[head];
          if (this.#hasFetchMethod && this.#isBackgroundFetch(v4)) {
            v4.__abortController.abort(new Error("evicted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v4, k2, "evict");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v4, k2, "evict"]);
            }
          }
          this.#removeItemSize(head);
          if (free) {
            this.#keyList[head] = void 0;
            this.#valList[head] = void 0;
            this.#free.push(head);
          }
          if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
          } else {
            this.#head = this.#next[head];
          }
          this.#keyMap.delete(k2);
          this.#size--;
          return head;
        }
        /**
         * Check if a key is in the cache, without updating the recency of use.
         * Will return false if the item is stale, even though it is technically
         * in the cache.
         *
         * Will not update item age unless
         * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
         */
        has(k2, hasOptions = {}) {
          const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
          const index = this.#keyMap.get(k2);
          if (index !== void 0) {
            const v4 = this.#valList[index];
            if (this.#isBackgroundFetch(v4) && v4.__staleWhileFetching === void 0) {
              return false;
            }
            if (!this.#isStale(index)) {
              if (updateAgeOnHas) {
                this.#updateItemAge(index);
              }
              if (status) {
                status.has = "hit";
                this.#statusTTL(status, index);
              }
              return true;
            } else if (status) {
              status.has = "stale";
              this.#statusTTL(status, index);
            }
          } else if (status) {
            status.has = "miss";
          }
          return false;
        }
        /**
         * Like {@link LRUCache#get} but doesn't update recency or delete stale
         * items.
         *
         * Returns `undefined` if the item is stale, unless
         * {@link LRUCache.OptionsBase.allowStale} is set.
         */
        peek(k2, peekOptions = {}) {
          const { allowStale = this.allowStale } = peekOptions;
          const index = this.#keyMap.get(k2);
          if (index !== void 0 && (allowStale || !this.#isStale(index))) {
            const v4 = this.#valList[index];
            return this.#isBackgroundFetch(v4) ? v4.__staleWhileFetching : v4;
          }
        }
        #backgroundFetch(k2, index, options, context) {
          const v4 = index === void 0 ? void 0 : this.#valList[index];
          if (this.#isBackgroundFetch(v4)) {
            return v4;
          }
          const ac = new AC();
          const { signal } = options;
          signal?.addEventListener("abort", () => ac.abort(signal.reason), {
            signal: ac.signal
          });
          const fetchOpts = {
            signal: ac.signal,
            options,
            context
          };
          const cb = (v5, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v5 !== void 0;
            if (options.status) {
              if (aborted && !updateCache) {
                options.status.fetchAborted = true;
                options.status.fetchError = ac.signal.reason;
                if (ignoreAbort)
                  options.status.fetchAbortIgnored = true;
              } else {
                options.status.fetchResolved = true;
              }
            }
            if (aborted && !ignoreAbort && !updateCache) {
              return fetchFail(ac.signal.reason);
            }
            const bf2 = p6;
            if (this.#valList[index] === p6) {
              if (v5 === void 0) {
                if (bf2.__staleWhileFetching) {
                  this.#valList[index] = bf2.__staleWhileFetching;
                } else {
                  this.delete(k2);
                }
              } else {
                if (options.status)
                  options.status.fetchUpdated = true;
                this.set(k2, v5, fetchOpts.options);
              }
            }
            return v5;
          };
          const eb = (er) => {
            if (options.status) {
              options.status.fetchRejected = true;
              options.status.fetchError = er;
            }
            return fetchFail(er);
          };
          const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf2 = p6;
            if (this.#valList[index] === p6) {
              const del = !noDelete || bf2.__staleWhileFetching === void 0;
              if (del) {
                this.delete(k2);
              } else if (!allowStaleAborted) {
                this.#valList[index] = bf2.__staleWhileFetching;
              }
            }
            if (allowStale) {
              if (options.status && bf2.__staleWhileFetching !== void 0) {
                options.status.returnedStale = true;
              }
              return bf2.__staleWhileFetching;
            } else if (bf2.__returned === bf2) {
              throw er;
            }
          };
          const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k2, v4, fetchOpts);
            if (fmp && fmp instanceof Promise) {
              fmp.then((v5) => res(v5 === void 0 ? void 0 : v5), rej);
            }
            ac.signal.addEventListener("abort", () => {
              if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
                res(void 0);
                if (options.allowStaleOnFetchAbort) {
                  res = (v5) => cb(v5, true);
                }
              }
            });
          };
          if (options.status)
            options.status.fetchDispatched = true;
          const p6 = new Promise(pcall).then(cb, eb);
          const bf = Object.assign(p6, {
            __abortController: ac,
            __staleWhileFetching: v4,
            __returned: void 0
          });
          if (index === void 0) {
            this.set(k2, bf, { ...fetchOpts.options, status: void 0 });
            index = this.#keyMap.get(k2);
          } else {
            this.#valList[index] = bf;
          }
          return bf;
        }
        #isBackgroundFetch(p6) {
          if (!this.#hasFetchMethod)
            return false;
          const b3 = p6;
          return !!b3 && b3 instanceof Promise && b3.hasOwnProperty("__staleWhileFetching") && b3.__abortController instanceof AC;
        }
        async fetch(k2, fetchOptions = {}) {
          const {
            // get options
            allowStale = this.allowStale,
            updateAgeOnGet = this.updateAgeOnGet,
            noDeleteOnStaleGet = this.noDeleteOnStaleGet,
            // set options
            ttl = this.ttl,
            noDisposeOnSet = this.noDisposeOnSet,
            size = 0,
            sizeCalculation = this.sizeCalculation,
            noUpdateTTL = this.noUpdateTTL,
            // fetch exclusive options
            noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
            allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
            ignoreFetchAbort = this.ignoreFetchAbort,
            allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
            context,
            forceRefresh = false,
            status,
            signal
          } = fetchOptions;
          if (!this.#hasFetchMethod) {
            if (status)
              status.fetch = "get";
            return this.get(k2, {
              allowStale,
              updateAgeOnGet,
              noDeleteOnStaleGet,
              status
            });
          }
          const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal
          };
          let index = this.#keyMap.get(k2);
          if (index === void 0) {
            if (status)
              status.fetch = "miss";
            const p6 = this.#backgroundFetch(k2, index, options, context);
            return p6.__returned = p6;
          } else {
            const v4 = this.#valList[index];
            if (this.#isBackgroundFetch(v4)) {
              const stale = allowStale && v4.__staleWhileFetching !== void 0;
              if (status) {
                status.fetch = "inflight";
                if (stale)
                  status.returnedStale = true;
              }
              return stale ? v4.__staleWhileFetching : v4.__returned = v4;
            }
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
              if (status)
                status.fetch = "hit";
              this.#moveToTail(index);
              if (updateAgeOnGet) {
                this.#updateItemAge(index);
              }
              if (status)
                this.#statusTTL(status, index);
              return v4;
            }
            const p6 = this.#backgroundFetch(k2, index, options, context);
            const hasStale = p6.__staleWhileFetching !== void 0;
            const staleVal = hasStale && allowStale;
            if (status) {
              status.fetch = isStale ? "stale" : "refresh";
              if (staleVal && isStale)
                status.returnedStale = true;
            }
            return staleVal ? p6.__staleWhileFetching : p6.__returned = p6;
          }
        }
        /**
         * Return a value from the cache. Will update the recency of the cache
         * entry found.
         *
         * If the key is not found, get() will return `undefined`.
         */
        get(k2, getOptions = {}) {
          const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
          const index = this.#keyMap.get(k2);
          if (index !== void 0) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
              this.#statusTTL(status, index);
            if (this.#isStale(index)) {
              if (status)
                status.get = "stale";
              if (!fetching) {
                if (!noDeleteOnStaleGet) {
                  this.delete(k2);
                }
                if (status && allowStale)
                  status.returnedStale = true;
                return allowStale ? value : void 0;
              } else {
                if (status && allowStale && value.__staleWhileFetching !== void 0) {
                  status.returnedStale = true;
                }
                return allowStale ? value.__staleWhileFetching : void 0;
              }
            } else {
              if (status)
                status.get = "hit";
              if (fetching) {
                return value.__staleWhileFetching;
              }
              this.#moveToTail(index);
              if (updateAgeOnGet) {
                this.#updateItemAge(index);
              }
              return value;
            }
          } else if (status) {
            status.get = "miss";
          }
        }
        #connect(p6, n7) {
          this.#prev[n7] = p6;
          this.#next[p6] = n7;
        }
        #moveToTail(index) {
          if (index !== this.#tail) {
            if (index === this.#head) {
              this.#head = this.#next[index];
            } else {
              this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
          }
        }
        /**
         * Deletes a key out of the cache.
         * Returns true if the key was deleted, false otherwise.
         */
        delete(k2) {
          let deleted = false;
          if (this.#size !== 0) {
            const index = this.#keyMap.get(k2);
            if (index !== void 0) {
              deleted = true;
              if (this.#size === 1) {
                this.clear();
              } else {
                this.#removeItemSize(index);
                const v4 = this.#valList[index];
                if (this.#isBackgroundFetch(v4)) {
                  v4.__abortController.abort(new Error("deleted"));
                } else if (this.#hasDispose || this.#hasDisposeAfter) {
                  if (this.#hasDispose) {
                    this.#dispose?.(v4, k2, "delete");
                  }
                  if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v4, k2, "delete"]);
                  }
                }
                this.#keyMap.delete(k2);
                this.#keyList[index] = void 0;
                this.#valList[index] = void 0;
                if (index === this.#tail) {
                  this.#tail = this.#prev[index];
                } else if (index === this.#head) {
                  this.#head = this.#next[index];
                } else {
                  this.#next[this.#prev[index]] = this.#next[index];
                  this.#prev[this.#next[index]] = this.#prev[index];
                }
                this.#size--;
                this.#free.push(index);
              }
            }
          }
          if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
          return deleted;
        }
        /**
         * Clear the cache entirely, throwing away all values.
         */
        clear() {
          for (const index of this.#rindexes({ allowStale: true })) {
            const v4 = this.#valList[index];
            if (this.#isBackgroundFetch(v4)) {
              v4.__abortController.abort(new Error("deleted"));
            } else {
              const k2 = this.#keyList[index];
              if (this.#hasDispose) {
                this.#dispose?.(v4, k2, "delete");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v4, k2, "delete"]);
              }
            }
          }
          this.#keyMap.clear();
          this.#valList.fill(void 0);
          this.#keyList.fill(void 0);
          if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
          }
          if (this.#sizes) {
            this.#sizes.fill(0);
          }
          this.#head = 0;
          this.#tail = 0;
          this.#free.length = 0;
          this.#calculatedSize = 0;
          this.#size = 0;
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      };
      exports5.LRUCache = LRUCache;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/ContainerBase/index.js
  var require_ContainerBase = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/ContainerBase/index.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.ContainerIterator = exports5.Container = exports5.Base = void 0;
      var ContainerIterator = class {
        constructor(t6 = 0) {
          this.iteratorType = t6;
        }
        equals(t6) {
          return this.o === t6.o;
        }
      };
      exports5.ContainerIterator = ContainerIterator;
      var Base = class {
        constructor() {
          this.i = 0;
        }
        get length() {
          return this.i;
        }
        size() {
          return this.i;
        }
        empty() {
          return this.i === 0;
        }
      };
      exports5.Base = Base;
      var Container = class extends Base {
      };
      exports5.Container = Container;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/OtherContainer/Stack.js
  var require_Stack = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/OtherContainer/Stack.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _ContainerBase = require_ContainerBase();
      var Stack = class extends _ContainerBase.Base {
        constructor(t6 = []) {
          super();
          this.S = [];
          const s5 = this;
          t6.forEach(function(t7) {
            s5.push(t7);
          });
        }
        clear() {
          this.i = 0;
          this.S = [];
        }
        push(t6) {
          this.S.push(t6);
          this.i += 1;
          return this.i;
        }
        pop() {
          if (this.i === 0)
            return;
          this.i -= 1;
          return this.S.pop();
        }
        top() {
          return this.S[this.i - 1];
        }
      };
      var _default = Stack;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/OtherContainer/Queue.js
  var require_Queue = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/OtherContainer/Queue.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _ContainerBase = require_ContainerBase();
      var Queue = class extends _ContainerBase.Base {
        constructor(t6 = []) {
          super();
          this.j = 0;
          this.q = [];
          const s5 = this;
          t6.forEach(function(t7) {
            s5.push(t7);
          });
        }
        clear() {
          this.q = [];
          this.i = this.j = 0;
        }
        push(t6) {
          const s5 = this.q.length;
          if (this.j / s5 > 0.5 && this.j + this.i >= s5 && s5 > 4096) {
            const s6 = this.i;
            for (let t7 = 0; t7 < s6; ++t7) {
              this.q[t7] = this.q[this.j + t7];
            }
            this.j = 0;
            this.q[this.i] = t6;
          } else
            this.q[this.j + this.i] = t6;
          return ++this.i;
        }
        pop() {
          if (this.i === 0)
            return;
          const t6 = this.q[this.j++];
          this.i -= 1;
          return t6;
        }
        front() {
          if (this.i === 0)
            return;
          return this.q[this.j];
        }
      };
      var _default = Queue;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/OtherContainer/PriorityQueue.js
  var require_PriorityQueue = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/OtherContainer/PriorityQueue.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _ContainerBase = require_ContainerBase();
      var PriorityQueue = class extends _ContainerBase.Base {
        constructor(t6 = [], s5 = function(t7, s6) {
          if (t7 > s6)
            return -1;
          if (t7 < s6)
            return 1;
          return 0;
        }, i6 = true) {
          super();
          this.v = s5;
          if (Array.isArray(t6)) {
            this.C = i6 ? [...t6] : t6;
          } else {
            this.C = [];
            const s6 = this;
            t6.forEach(function(t7) {
              s6.C.push(t7);
            });
          }
          this.i = this.C.length;
          const e7 = this.i >> 1;
          for (let t7 = this.i - 1 >> 1; t7 >= 0; --t7) {
            this.k(t7, e7);
          }
        }
        m(t6) {
          const s5 = this.C[t6];
          while (t6 > 0) {
            const i6 = t6 - 1 >> 1;
            const e7 = this.C[i6];
            if (this.v(e7, s5) <= 0)
              break;
            this.C[t6] = e7;
            t6 = i6;
          }
          this.C[t6] = s5;
        }
        k(t6, s5) {
          const i6 = this.C[t6];
          while (t6 < s5) {
            let s6 = t6 << 1 | 1;
            const e7 = s6 + 1;
            let h6 = this.C[s6];
            if (e7 < this.i && this.v(h6, this.C[e7]) > 0) {
              s6 = e7;
              h6 = this.C[e7];
            }
            if (this.v(h6, i6) >= 0)
              break;
            this.C[t6] = h6;
            t6 = s6;
          }
          this.C[t6] = i6;
        }
        clear() {
          this.i = 0;
          this.C.length = 0;
        }
        push(t6) {
          this.C.push(t6);
          this.m(this.i);
          this.i += 1;
        }
        pop() {
          if (this.i === 0)
            return;
          const t6 = this.C[0];
          const s5 = this.C.pop();
          this.i -= 1;
          if (this.i) {
            this.C[0] = s5;
            this.k(0, this.i >> 1);
          }
          return t6;
        }
        top() {
          return this.C[0];
        }
        find(t6) {
          return this.C.indexOf(t6) >= 0;
        }
        remove(t6) {
          const s5 = this.C.indexOf(t6);
          if (s5 < 0)
            return false;
          if (s5 === 0) {
            this.pop();
          } else if (s5 === this.i - 1) {
            this.C.pop();
            this.i -= 1;
          } else {
            this.C.splice(s5, 1, this.C.pop());
            this.i -= 1;
            this.m(s5);
            this.k(s5, this.i >> 1);
          }
          return true;
        }
        updateItem(t6) {
          const s5 = this.C.indexOf(t6);
          if (s5 < 0)
            return false;
          this.m(s5);
          this.k(s5, this.i >> 1);
          return true;
        }
        toArray() {
          return [...this.C];
        }
      };
      var _default = PriorityQueue;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Base/index.js
  var require_Base = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Base/index.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _ContainerBase = require_ContainerBase();
      var SequentialContainer = class extends _ContainerBase.Container {
      };
      var _default = SequentialContainer;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/utils/throwError.js
  var require_throwError = __commonJS({
    "node_modules/js-sdsl/dist/cjs/utils/throwError.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.throwIteratorAccessError = throwIteratorAccessError;
      function throwIteratorAccessError() {
        throw new RangeError("Iterator access denied!");
      }
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Base/RandomIterator.js
  var require_RandomIterator = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Base/RandomIterator.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.RandomIterator = void 0;
      var _ContainerBase = require_ContainerBase();
      var _throwError = require_throwError();
      var RandomIterator = class extends _ContainerBase.ContainerIterator {
        constructor(t6, r7) {
          super(r7);
          this.o = t6;
          if (this.iteratorType === 0) {
            this.pre = function() {
              if (this.o === 0) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o -= 1;
              return this;
            };
            this.next = function() {
              if (this.o === this.container.size()) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o += 1;
              return this;
            };
          } else {
            this.pre = function() {
              if (this.o === this.container.size() - 1) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o += 1;
              return this;
            };
            this.next = function() {
              if (this.o === -1) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o -= 1;
              return this;
            };
          }
        }
        get pointer() {
          return this.container.getElementByPos(this.o);
        }
        set pointer(t6) {
          this.container.setElementByPos(this.o, t6);
        }
      };
      exports5.RandomIterator = RandomIterator;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Vector.js
  var require_Vector = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Vector.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _Base = _interopRequireDefault(require_Base());
      var _RandomIterator = require_RandomIterator();
      function _interopRequireDefault(t6) {
        return t6 && t6.t ? t6 : {
          default: t6
        };
      }
      var VectorIterator = class _VectorIterator extends _RandomIterator.RandomIterator {
        constructor(t6, r7, e7) {
          super(t6, e7);
          this.container = r7;
        }
        copy() {
          return new _VectorIterator(this.o, this.container, this.iteratorType);
        }
      };
      var Vector = class extends _Base.default {
        constructor(t6 = [], r7 = true) {
          super();
          if (Array.isArray(t6)) {
            this.J = r7 ? [...t6] : t6;
            this.i = t6.length;
          } else {
            this.J = [];
            const r8 = this;
            t6.forEach(function(t7) {
              r8.pushBack(t7);
            });
          }
        }
        clear() {
          this.i = 0;
          this.J.length = 0;
        }
        begin() {
          return new VectorIterator(0, this);
        }
        end() {
          return new VectorIterator(this.i, this);
        }
        rBegin() {
          return new VectorIterator(this.i - 1, this, 1);
        }
        rEnd() {
          return new VectorIterator(-1, this, 1);
        }
        front() {
          return this.J[0];
        }
        back() {
          return this.J[this.i - 1];
        }
        getElementByPos(t6) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          return this.J[t6];
        }
        eraseElementByPos(t6) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          this.J.splice(t6, 1);
          this.i -= 1;
          return this.i;
        }
        eraseElementByValue(t6) {
          let r7 = 0;
          for (let e7 = 0; e7 < this.i; ++e7) {
            if (this.J[e7] !== t6) {
              this.J[r7++] = this.J[e7];
            }
          }
          this.i = this.J.length = r7;
          return this.i;
        }
        eraseElementByIterator(t6) {
          const r7 = t6.o;
          t6 = t6.next();
          this.eraseElementByPos(r7);
          return t6;
        }
        pushBack(t6) {
          this.J.push(t6);
          this.i += 1;
          return this.i;
        }
        popBack() {
          if (this.i === 0)
            return;
          this.i -= 1;
          return this.J.pop();
        }
        setElementByPos(t6, r7) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          this.J[t6] = r7;
        }
        insert(t6, r7, e7 = 1) {
          if (t6 < 0 || t6 > this.i) {
            throw new RangeError();
          }
          this.J.splice(t6, 0, ...new Array(e7).fill(r7));
          this.i += e7;
          return this.i;
        }
        find(t6) {
          for (let r7 = 0; r7 < this.i; ++r7) {
            if (this.J[r7] === t6) {
              return new VectorIterator(r7, this);
            }
          }
          return this.end();
        }
        reverse() {
          this.J.reverse();
        }
        unique() {
          let t6 = 1;
          for (let r7 = 1; r7 < this.i; ++r7) {
            if (this.J[r7] !== this.J[r7 - 1]) {
              this.J[t6++] = this.J[r7];
            }
          }
          this.i = this.J.length = t6;
          return this.i;
        }
        sort(t6) {
          this.J.sort(t6);
        }
        forEach(t6) {
          for (let r7 = 0; r7 < this.i; ++r7) {
            t6(this.J[r7], r7, this);
          }
        }
        [Symbol.iterator]() {
          return function* () {
            yield* this.J;
          }.bind(this)();
        }
      };
      var _default = Vector;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/SequentialContainer/LinkList.js
  var require_LinkList = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/SequentialContainer/LinkList.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _Base = _interopRequireDefault(require_Base());
      var _ContainerBase = require_ContainerBase();
      var _throwError = require_throwError();
      function _interopRequireDefault(t6) {
        return t6 && t6.t ? t6 : {
          default: t6
        };
      }
      var LinkListIterator = class _LinkListIterator extends _ContainerBase.ContainerIterator {
        constructor(t6, i6, s5, r7) {
          super(r7);
          this.o = t6;
          this.h = i6;
          this.container = s5;
          if (this.iteratorType === 0) {
            this.pre = function() {
              if (this.o.L === this.h) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.L;
              return this;
            };
            this.next = function() {
              if (this.o === this.h) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.B;
              return this;
            };
          } else {
            this.pre = function() {
              if (this.o.B === this.h) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.B;
              return this;
            };
            this.next = function() {
              if (this.o === this.h) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.L;
              return this;
            };
          }
        }
        get pointer() {
          if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
          }
          return this.o.l;
        }
        set pointer(t6) {
          if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
          }
          this.o.l = t6;
        }
        copy() {
          return new _LinkListIterator(this.o, this.h, this.container, this.iteratorType);
        }
      };
      var LinkList = class extends _Base.default {
        constructor(t6 = []) {
          super();
          this.h = {};
          this.p = this._ = this.h.L = this.h.B = this.h;
          const i6 = this;
          t6.forEach(function(t7) {
            i6.pushBack(t7);
          });
        }
        V(t6) {
          const { L: i6, B: s5 } = t6;
          i6.B = s5;
          s5.L = i6;
          if (t6 === this.p) {
            this.p = s5;
          }
          if (t6 === this._) {
            this._ = i6;
          }
          this.i -= 1;
        }
        G(t6, i6) {
          const s5 = i6.B;
          const r7 = {
            l: t6,
            L: i6,
            B: s5
          };
          i6.B = r7;
          s5.L = r7;
          if (i6 === this.h) {
            this.p = r7;
          }
          if (s5 === this.h) {
            this._ = r7;
          }
          this.i += 1;
        }
        clear() {
          this.i = 0;
          this.p = this._ = this.h.L = this.h.B = this.h;
        }
        begin() {
          return new LinkListIterator(this.p, this.h, this);
        }
        end() {
          return new LinkListIterator(this.h, this.h, this);
        }
        rBegin() {
          return new LinkListIterator(this._, this.h, this, 1);
        }
        rEnd() {
          return new LinkListIterator(this.h, this.h, this, 1);
        }
        front() {
          return this.p.l;
        }
        back() {
          return this._.l;
        }
        getElementByPos(t6) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          let i6 = this.p;
          while (t6--) {
            i6 = i6.B;
          }
          return i6.l;
        }
        eraseElementByPos(t6) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          let i6 = this.p;
          while (t6--) {
            i6 = i6.B;
          }
          this.V(i6);
          return this.i;
        }
        eraseElementByValue(t6) {
          let i6 = this.p;
          while (i6 !== this.h) {
            if (i6.l === t6) {
              this.V(i6);
            }
            i6 = i6.B;
          }
          return this.i;
        }
        eraseElementByIterator(t6) {
          const i6 = t6.o;
          if (i6 === this.h) {
            (0, _throwError.throwIteratorAccessError)();
          }
          t6 = t6.next();
          this.V(i6);
          return t6;
        }
        pushBack(t6) {
          this.G(t6, this._);
          return this.i;
        }
        popBack() {
          if (this.i === 0)
            return;
          const t6 = this._.l;
          this.V(this._);
          return t6;
        }
        pushFront(t6) {
          this.G(t6, this.h);
          return this.i;
        }
        popFront() {
          if (this.i === 0)
            return;
          const t6 = this.p.l;
          this.V(this.p);
          return t6;
        }
        setElementByPos(t6, i6) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          let s5 = this.p;
          while (t6--) {
            s5 = s5.B;
          }
          s5.l = i6;
        }
        insert(t6, i6, s5 = 1) {
          if (t6 < 0 || t6 > this.i) {
            throw new RangeError();
          }
          if (s5 <= 0)
            return this.i;
          if (t6 === 0) {
            while (s5--)
              this.pushFront(i6);
          } else if (t6 === this.i) {
            while (s5--)
              this.pushBack(i6);
          } else {
            let r7 = this.p;
            for (let i7 = 1; i7 < t6; ++i7) {
              r7 = r7.B;
            }
            const e7 = r7.B;
            this.i += s5;
            while (s5--) {
              r7.B = {
                l: i6,
                L: r7
              };
              r7.B.L = r7;
              r7 = r7.B;
            }
            r7.B = e7;
            e7.L = r7;
          }
          return this.i;
        }
        find(t6) {
          let i6 = this.p;
          while (i6 !== this.h) {
            if (i6.l === t6) {
              return new LinkListIterator(i6, this.h, this);
            }
            i6 = i6.B;
          }
          return this.end();
        }
        reverse() {
          if (this.i <= 1)
            return;
          let t6 = this.p;
          let i6 = this._;
          let s5 = 0;
          while (s5 << 1 < this.i) {
            const r7 = t6.l;
            t6.l = i6.l;
            i6.l = r7;
            t6 = t6.B;
            i6 = i6.L;
            s5 += 1;
          }
        }
        unique() {
          if (this.i <= 1) {
            return this.i;
          }
          let t6 = this.p;
          while (t6 !== this.h) {
            let i6 = t6;
            while (i6.B !== this.h && i6.l === i6.B.l) {
              i6 = i6.B;
              this.i -= 1;
            }
            t6.B = i6.B;
            t6.B.L = t6;
            t6 = t6.B;
          }
          return this.i;
        }
        sort(t6) {
          if (this.i <= 1)
            return;
          const i6 = [];
          this.forEach(function(t7) {
            i6.push(t7);
          });
          i6.sort(t6);
          let s5 = this.p;
          i6.forEach(function(t7) {
            s5.l = t7;
            s5 = s5.B;
          });
        }
        merge(t6) {
          const i6 = this;
          if (this.i === 0) {
            t6.forEach(function(t7) {
              i6.pushBack(t7);
            });
          } else {
            let s5 = this.p;
            t6.forEach(function(t7) {
              while (s5 !== i6.h && s5.l <= t7) {
                s5 = s5.B;
              }
              i6.G(t7, s5.L);
            });
          }
          return this.i;
        }
        forEach(t6) {
          let i6 = this.p;
          let s5 = 0;
          while (i6 !== this.h) {
            t6(i6.l, s5++, this);
            i6 = i6.B;
          }
        }
        [Symbol.iterator]() {
          return function* () {
            if (this.i === 0)
              return;
            let t6 = this.p;
            while (t6 !== this.h) {
              yield t6.l;
              t6 = t6.B;
            }
          }.bind(this)();
        }
      };
      var _default = LinkList;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Deque.js
  var require_Deque = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/SequentialContainer/Deque.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _Base = _interopRequireDefault(require_Base());
      var _RandomIterator = require_RandomIterator();
      function _interopRequireDefault(t6) {
        return t6 && t6.t ? t6 : {
          default: t6
        };
      }
      var DequeIterator = class _DequeIterator extends _RandomIterator.RandomIterator {
        constructor(t6, i6, s5) {
          super(t6, s5);
          this.container = i6;
        }
        copy() {
          return new _DequeIterator(this.o, this.container, this.iteratorType);
        }
      };
      var Deque = class extends _Base.default {
        constructor(t6 = [], i6 = 1 << 12) {
          super();
          this.j = 0;
          this.D = 0;
          this.R = 0;
          this.N = 0;
          this.P = 0;
          this.A = [];
          const s5 = (() => {
            if (typeof t6.length === "number")
              return t6.length;
            if (typeof t6.size === "number")
              return t6.size;
            if (typeof t6.size === "function")
              return t6.size();
            throw new TypeError("Cannot get the length or size of the container");
          })();
          this.F = i6;
          this.P = Math.max(Math.ceil(s5 / this.F), 1);
          for (let t7 = 0; t7 < this.P; ++t7) {
            this.A.push(new Array(this.F));
          }
          const h6 = Math.ceil(s5 / this.F);
          this.j = this.R = (this.P >> 1) - (h6 >> 1);
          this.D = this.N = this.F - s5 % this.F >> 1;
          const e7 = this;
          t6.forEach(function(t7) {
            e7.pushBack(t7);
          });
        }
        T() {
          const t6 = [];
          const i6 = Math.max(this.P >> 1, 1);
          for (let s5 = 0; s5 < i6; ++s5) {
            t6[s5] = new Array(this.F);
          }
          for (let i7 = this.j; i7 < this.P; ++i7) {
            t6[t6.length] = this.A[i7];
          }
          for (let i7 = 0; i7 < this.R; ++i7) {
            t6[t6.length] = this.A[i7];
          }
          t6[t6.length] = [...this.A[this.R]];
          this.j = i6;
          this.R = t6.length - 1;
          for (let s5 = 0; s5 < i6; ++s5) {
            t6[t6.length] = new Array(this.F);
          }
          this.A = t6;
          this.P = t6.length;
        }
        O(t6) {
          const i6 = this.D + t6 + 1;
          const s5 = i6 % this.F;
          let h6 = s5 - 1;
          let e7 = this.j + (i6 - s5) / this.F;
          if (s5 === 0)
            e7 -= 1;
          e7 %= this.P;
          if (h6 < 0)
            h6 += this.F;
          return {
            curNodeBucketIndex: e7,
            curNodePointerIndex: h6
          };
        }
        clear() {
          this.A = [new Array(this.F)];
          this.P = 1;
          this.j = this.R = this.i = 0;
          this.D = this.N = this.F >> 1;
        }
        begin() {
          return new DequeIterator(0, this);
        }
        end() {
          return new DequeIterator(this.i, this);
        }
        rBegin() {
          return new DequeIterator(this.i - 1, this, 1);
        }
        rEnd() {
          return new DequeIterator(-1, this, 1);
        }
        front() {
          if (this.i === 0)
            return;
          return this.A[this.j][this.D];
        }
        back() {
          if (this.i === 0)
            return;
          return this.A[this.R][this.N];
        }
        pushBack(t6) {
          if (this.i) {
            if (this.N < this.F - 1) {
              this.N += 1;
            } else if (this.R < this.P - 1) {
              this.R += 1;
              this.N = 0;
            } else {
              this.R = 0;
              this.N = 0;
            }
            if (this.R === this.j && this.N === this.D)
              this.T();
          }
          this.i += 1;
          this.A[this.R][this.N] = t6;
          return this.i;
        }
        popBack() {
          if (this.i === 0)
            return;
          const t6 = this.A[this.R][this.N];
          if (this.i !== 1) {
            if (this.N > 0) {
              this.N -= 1;
            } else if (this.R > 0) {
              this.R -= 1;
              this.N = this.F - 1;
            } else {
              this.R = this.P - 1;
              this.N = this.F - 1;
            }
          }
          this.i -= 1;
          return t6;
        }
        pushFront(t6) {
          if (this.i) {
            if (this.D > 0) {
              this.D -= 1;
            } else if (this.j > 0) {
              this.j -= 1;
              this.D = this.F - 1;
            } else {
              this.j = this.P - 1;
              this.D = this.F - 1;
            }
            if (this.j === this.R && this.D === this.N)
              this.T();
          }
          this.i += 1;
          this.A[this.j][this.D] = t6;
          return this.i;
        }
        popFront() {
          if (this.i === 0)
            return;
          const t6 = this.A[this.j][this.D];
          if (this.i !== 1) {
            if (this.D < this.F - 1) {
              this.D += 1;
            } else if (this.j < this.P - 1) {
              this.j += 1;
              this.D = 0;
            } else {
              this.j = 0;
              this.D = 0;
            }
          }
          this.i -= 1;
          return t6;
        }
        getElementByPos(t6) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          const { curNodeBucketIndex: i6, curNodePointerIndex: s5 } = this.O(t6);
          return this.A[i6][s5];
        }
        setElementByPos(t6, i6) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          const { curNodeBucketIndex: s5, curNodePointerIndex: h6 } = this.O(t6);
          this.A[s5][h6] = i6;
        }
        insert(t6, i6, s5 = 1) {
          if (t6 < 0 || t6 > this.i) {
            throw new RangeError();
          }
          if (t6 === 0) {
            while (s5--)
              this.pushFront(i6);
          } else if (t6 === this.i) {
            while (s5--)
              this.pushBack(i6);
          } else {
            const h6 = [];
            for (let i7 = t6; i7 < this.i; ++i7) {
              h6.push(this.getElementByPos(i7));
            }
            this.cut(t6 - 1);
            for (let t7 = 0; t7 < s5; ++t7)
              this.pushBack(i6);
            for (let t7 = 0; t7 < h6.length; ++t7)
              this.pushBack(h6[t7]);
          }
          return this.i;
        }
        cut(t6) {
          if (t6 < 0) {
            this.clear();
            return 0;
          }
          const { curNodeBucketIndex: i6, curNodePointerIndex: s5 } = this.O(t6);
          this.R = i6;
          this.N = s5;
          this.i = t6 + 1;
          return this.i;
        }
        eraseElementByPos(t6) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          if (t6 === 0)
            this.popFront();
          else if (t6 === this.i - 1)
            this.popBack();
          else {
            const i6 = [];
            for (let s6 = t6 + 1; s6 < this.i; ++s6) {
              i6.push(this.getElementByPos(s6));
            }
            this.cut(t6);
            this.popBack();
            const s5 = this;
            i6.forEach(function(t7) {
              s5.pushBack(t7);
            });
          }
          return this.i;
        }
        eraseElementByValue(t6) {
          if (this.i === 0)
            return 0;
          const i6 = [];
          for (let s6 = 0; s6 < this.i; ++s6) {
            const h6 = this.getElementByPos(s6);
            if (h6 !== t6)
              i6.push(h6);
          }
          const s5 = i6.length;
          for (let t7 = 0; t7 < s5; ++t7)
            this.setElementByPos(t7, i6[t7]);
          return this.cut(s5 - 1);
        }
        eraseElementByIterator(t6) {
          const i6 = t6.o;
          this.eraseElementByPos(i6);
          t6 = t6.next();
          return t6;
        }
        find(t6) {
          for (let i6 = 0; i6 < this.i; ++i6) {
            if (this.getElementByPos(i6) === t6) {
              return new DequeIterator(i6, this);
            }
          }
          return this.end();
        }
        reverse() {
          let t6 = 0;
          let i6 = this.i - 1;
          while (t6 < i6) {
            const s5 = this.getElementByPos(t6);
            this.setElementByPos(t6, this.getElementByPos(i6));
            this.setElementByPos(i6, s5);
            t6 += 1;
            i6 -= 1;
          }
        }
        unique() {
          if (this.i <= 1) {
            return this.i;
          }
          let t6 = 1;
          let i6 = this.getElementByPos(0);
          for (let s5 = 1; s5 < this.i; ++s5) {
            const h6 = this.getElementByPos(s5);
            if (h6 !== i6) {
              i6 = h6;
              this.setElementByPos(t6++, h6);
            }
          }
          while (this.i > t6)
            this.popBack();
          return this.i;
        }
        sort(t6) {
          const i6 = [];
          for (let t7 = 0; t7 < this.i; ++t7) {
            i6.push(this.getElementByPos(t7));
          }
          i6.sort(t6);
          for (let t7 = 0; t7 < this.i; ++t7)
            this.setElementByPos(t7, i6[t7]);
        }
        shrinkToFit() {
          if (this.i === 0)
            return;
          const t6 = [];
          this.forEach(function(i6) {
            t6.push(i6);
          });
          this.P = Math.max(Math.ceil(this.i / this.F), 1);
          this.i = this.j = this.R = this.D = this.N = 0;
          this.A = [];
          for (let t7 = 0; t7 < this.P; ++t7) {
            this.A.push(new Array(this.F));
          }
          for (let i6 = 0; i6 < t6.length; ++i6)
            this.pushBack(t6[i6]);
        }
        forEach(t6) {
          for (let i6 = 0; i6 < this.i; ++i6) {
            t6(this.getElementByPos(i6), i6, this);
          }
        }
        [Symbol.iterator]() {
          return function* () {
            for (let t6 = 0; t6 < this.i; ++t6) {
              yield this.getElementByPos(t6);
            }
          }.bind(this)();
        }
      };
      var _default = Deque;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/TreeNode.js
  var require_TreeNode = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/TreeNode.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.TreeNodeEnableIndex = exports5.TreeNode = void 0;
      var TreeNode = class {
        constructor(e7, t6) {
          this.ee = 1;
          this.u = void 0;
          this.l = void 0;
          this.U = void 0;
          this.W = void 0;
          this.tt = void 0;
          this.u = e7;
          this.l = t6;
        }
        L() {
          let e7 = this;
          if (e7.ee === 1 && e7.tt.tt === e7) {
            e7 = e7.W;
          } else if (e7.U) {
            e7 = e7.U;
            while (e7.W) {
              e7 = e7.W;
            }
          } else {
            let t6 = e7.tt;
            while (t6.U === e7) {
              e7 = t6;
              t6 = e7.tt;
            }
            e7 = t6;
          }
          return e7;
        }
        B() {
          let e7 = this;
          if (e7.W) {
            e7 = e7.W;
            while (e7.U) {
              e7 = e7.U;
            }
            return e7;
          } else {
            let t6 = e7.tt;
            while (t6.W === e7) {
              e7 = t6;
              t6 = e7.tt;
            }
            if (e7.W !== t6) {
              return t6;
            } else
              return e7;
          }
        }
        te() {
          const e7 = this.tt;
          const t6 = this.W;
          const s5 = t6.U;
          if (e7.tt === this)
            e7.tt = t6;
          else if (e7.U === this)
            e7.U = t6;
          else
            e7.W = t6;
          t6.tt = e7;
          t6.U = this;
          this.tt = t6;
          this.W = s5;
          if (s5)
            s5.tt = this;
          return t6;
        }
        se() {
          const e7 = this.tt;
          const t6 = this.U;
          const s5 = t6.W;
          if (e7.tt === this)
            e7.tt = t6;
          else if (e7.U === this)
            e7.U = t6;
          else
            e7.W = t6;
          t6.tt = e7;
          t6.W = this;
          this.tt = t6;
          this.U = s5;
          if (s5)
            s5.tt = this;
          return t6;
        }
      };
      exports5.TreeNode = TreeNode;
      var TreeNodeEnableIndex = class extends TreeNode {
        constructor() {
          super(...arguments);
          this.rt = 1;
        }
        te() {
          const e7 = super.te();
          this.ie();
          e7.ie();
          return e7;
        }
        se() {
          const e7 = super.se();
          this.ie();
          e7.ie();
          return e7;
        }
        ie() {
          this.rt = 1;
          if (this.U) {
            this.rt += this.U.rt;
          }
          if (this.W) {
            this.rt += this.W.rt;
          }
        }
      };
      exports5.TreeNodeEnableIndex = TreeNodeEnableIndex;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/index.js
  var require_Base2 = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/index.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _TreeNode = require_TreeNode();
      var _ContainerBase = require_ContainerBase();
      var _throwError = require_throwError();
      var TreeContainer = class extends _ContainerBase.Container {
        constructor(e7 = function(e8, t7) {
          if (e8 < t7)
            return -1;
          if (e8 > t7)
            return 1;
          return 0;
        }, t6 = false) {
          super();
          this.Y = void 0;
          this.v = e7;
          if (t6) {
            this.re = _TreeNode.TreeNodeEnableIndex;
            this.M = function(e8, t7, i6) {
              const s5 = this.ne(e8, t7, i6);
              if (s5) {
                let e9 = s5.tt;
                while (e9 !== this.h) {
                  e9.rt += 1;
                  e9 = e9.tt;
                }
                const t8 = this.he(s5);
                if (t8) {
                  const { parentNode: e10, grandParent: i7, curNode: s6 } = t8;
                  e10.ie();
                  i7.ie();
                  s6.ie();
                }
              }
              return this.i;
            };
            this.V = function(e8) {
              let t7 = this.fe(e8);
              while (t7 !== this.h) {
                t7.rt -= 1;
                t7 = t7.tt;
              }
            };
          } else {
            this.re = _TreeNode.TreeNode;
            this.M = function(e8, t7, i6) {
              const s5 = this.ne(e8, t7, i6);
              if (s5)
                this.he(s5);
              return this.i;
            };
            this.V = this.fe;
          }
          this.h = new this.re();
        }
        X(e7, t6) {
          let i6 = this.h;
          while (e7) {
            const s5 = this.v(e7.u, t6);
            if (s5 < 0) {
              e7 = e7.W;
            } else if (s5 > 0) {
              i6 = e7;
              e7 = e7.U;
            } else
              return e7;
          }
          return i6;
        }
        Z(e7, t6) {
          let i6 = this.h;
          while (e7) {
            const s5 = this.v(e7.u, t6);
            if (s5 <= 0) {
              e7 = e7.W;
            } else {
              i6 = e7;
              e7 = e7.U;
            }
          }
          return i6;
        }
        $(e7, t6) {
          let i6 = this.h;
          while (e7) {
            const s5 = this.v(e7.u, t6);
            if (s5 < 0) {
              i6 = e7;
              e7 = e7.W;
            } else if (s5 > 0) {
              e7 = e7.U;
            } else
              return e7;
          }
          return i6;
        }
        rr(e7, t6) {
          let i6 = this.h;
          while (e7) {
            const s5 = this.v(e7.u, t6);
            if (s5 < 0) {
              i6 = e7;
              e7 = e7.W;
            } else {
              e7 = e7.U;
            }
          }
          return i6;
        }
        ue(e7) {
          while (true) {
            const t6 = e7.tt;
            if (t6 === this.h)
              return;
            if (e7.ee === 1) {
              e7.ee = 0;
              return;
            }
            if (e7 === t6.U) {
              const i6 = t6.W;
              if (i6.ee === 1) {
                i6.ee = 0;
                t6.ee = 1;
                if (t6 === this.Y) {
                  this.Y = t6.te();
                } else
                  t6.te();
              } else {
                if (i6.W && i6.W.ee === 1) {
                  i6.ee = t6.ee;
                  t6.ee = 0;
                  i6.W.ee = 0;
                  if (t6 === this.Y) {
                    this.Y = t6.te();
                  } else
                    t6.te();
                  return;
                } else if (i6.U && i6.U.ee === 1) {
                  i6.ee = 1;
                  i6.U.ee = 0;
                  i6.se();
                } else {
                  i6.ee = 1;
                  e7 = t6;
                }
              }
            } else {
              const i6 = t6.U;
              if (i6.ee === 1) {
                i6.ee = 0;
                t6.ee = 1;
                if (t6 === this.Y) {
                  this.Y = t6.se();
                } else
                  t6.se();
              } else {
                if (i6.U && i6.U.ee === 1) {
                  i6.ee = t6.ee;
                  t6.ee = 0;
                  i6.U.ee = 0;
                  if (t6 === this.Y) {
                    this.Y = t6.se();
                  } else
                    t6.se();
                  return;
                } else if (i6.W && i6.W.ee === 1) {
                  i6.ee = 1;
                  i6.W.ee = 0;
                  i6.te();
                } else {
                  i6.ee = 1;
                  e7 = t6;
                }
              }
            }
          }
        }
        fe(e7) {
          if (this.i === 1) {
            this.clear();
            return this.h;
          }
          let t6 = e7;
          while (t6.U || t6.W) {
            if (t6.W) {
              t6 = t6.W;
              while (t6.U)
                t6 = t6.U;
            } else {
              t6 = t6.U;
            }
            [e7.u, t6.u] = [t6.u, e7.u];
            [e7.l, t6.l] = [t6.l, e7.l];
            e7 = t6;
          }
          if (this.h.U === t6) {
            this.h.U = t6.tt;
          } else if (this.h.W === t6) {
            this.h.W = t6.tt;
          }
          this.ue(t6);
          const i6 = t6.tt;
          if (t6 === i6.U) {
            i6.U = void 0;
          } else
            i6.W = void 0;
          this.i -= 1;
          this.Y.ee = 0;
          return i6;
        }
        oe(e7, t6) {
          if (e7 === void 0)
            return false;
          const i6 = this.oe(e7.U, t6);
          if (i6)
            return true;
          if (t6(e7))
            return true;
          return this.oe(e7.W, t6);
        }
        he(e7) {
          while (true) {
            const t6 = e7.tt;
            if (t6.ee === 0)
              return;
            const i6 = t6.tt;
            if (t6 === i6.U) {
              const s5 = i6.W;
              if (s5 && s5.ee === 1) {
                s5.ee = t6.ee = 0;
                if (i6 === this.Y)
                  return;
                i6.ee = 1;
                e7 = i6;
                continue;
              } else if (e7 === t6.W) {
                e7.ee = 0;
                if (e7.U)
                  e7.U.tt = t6;
                if (e7.W)
                  e7.W.tt = i6;
                t6.W = e7.U;
                i6.U = e7.W;
                e7.U = t6;
                e7.W = i6;
                if (i6 === this.Y) {
                  this.Y = e7;
                  this.h.tt = e7;
                } else {
                  const t7 = i6.tt;
                  if (t7.U === i6) {
                    t7.U = e7;
                  } else
                    t7.W = e7;
                }
                e7.tt = i6.tt;
                t6.tt = e7;
                i6.tt = e7;
                i6.ee = 1;
                return {
                  parentNode: t6,
                  grandParent: i6,
                  curNode: e7
                };
              } else {
                t6.ee = 0;
                if (i6 === this.Y) {
                  this.Y = i6.se();
                } else
                  i6.se();
                i6.ee = 1;
              }
            } else {
              const s5 = i6.U;
              if (s5 && s5.ee === 1) {
                s5.ee = t6.ee = 0;
                if (i6 === this.Y)
                  return;
                i6.ee = 1;
                e7 = i6;
                continue;
              } else if (e7 === t6.U) {
                e7.ee = 0;
                if (e7.U)
                  e7.U.tt = i6;
                if (e7.W)
                  e7.W.tt = t6;
                i6.W = e7.U;
                t6.U = e7.W;
                e7.U = i6;
                e7.W = t6;
                if (i6 === this.Y) {
                  this.Y = e7;
                  this.h.tt = e7;
                } else {
                  const t7 = i6.tt;
                  if (t7.U === i6) {
                    t7.U = e7;
                  } else
                    t7.W = e7;
                }
                e7.tt = i6.tt;
                t6.tt = e7;
                i6.tt = e7;
                i6.ee = 1;
                return {
                  parentNode: t6,
                  grandParent: i6,
                  curNode: e7
                };
              } else {
                t6.ee = 0;
                if (i6 === this.Y) {
                  this.Y = i6.te();
                } else
                  i6.te();
                i6.ee = 1;
              }
            }
            return;
          }
        }
        ne(e7, t6, i6) {
          if (this.Y === void 0) {
            this.i += 1;
            this.Y = new this.re(e7, t6);
            this.Y.ee = 0;
            this.Y.tt = this.h;
            this.h.tt = this.Y;
            this.h.U = this.Y;
            this.h.W = this.Y;
            return;
          }
          let s5;
          const r7 = this.h.U;
          const n7 = this.v(r7.u, e7);
          if (n7 === 0) {
            r7.l = t6;
            return;
          } else if (n7 > 0) {
            r7.U = new this.re(e7, t6);
            r7.U.tt = r7;
            s5 = r7.U;
            this.h.U = s5;
          } else {
            const r8 = this.h.W;
            const n8 = this.v(r8.u, e7);
            if (n8 === 0) {
              r8.l = t6;
              return;
            } else if (n8 < 0) {
              r8.W = new this.re(e7, t6);
              r8.W.tt = r8;
              s5 = r8.W;
              this.h.W = s5;
            } else {
              if (i6 !== void 0) {
                const r9 = i6.o;
                if (r9 !== this.h) {
                  const i7 = this.v(r9.u, e7);
                  if (i7 === 0) {
                    r9.l = t6;
                    return;
                  } else if (i7 > 0) {
                    const i8 = r9.L();
                    const n9 = this.v(i8.u, e7);
                    if (n9 === 0) {
                      i8.l = t6;
                      return;
                    } else if (n9 < 0) {
                      s5 = new this.re(e7, t6);
                      if (i8.W === void 0) {
                        i8.W = s5;
                        s5.tt = i8;
                      } else {
                        r9.U = s5;
                        s5.tt = r9;
                      }
                    }
                  }
                }
              }
              if (s5 === void 0) {
                s5 = this.Y;
                while (true) {
                  const i7 = this.v(s5.u, e7);
                  if (i7 > 0) {
                    if (s5.U === void 0) {
                      s5.U = new this.re(e7, t6);
                      s5.U.tt = s5;
                      s5 = s5.U;
                      break;
                    }
                    s5 = s5.U;
                  } else if (i7 < 0) {
                    if (s5.W === void 0) {
                      s5.W = new this.re(e7, t6);
                      s5.W.tt = s5;
                      s5 = s5.W;
                      break;
                    }
                    s5 = s5.W;
                  } else {
                    s5.l = t6;
                    return;
                  }
                }
              }
            }
          }
          this.i += 1;
          return s5;
        }
        I(e7, t6) {
          while (e7) {
            const i6 = this.v(e7.u, t6);
            if (i6 < 0) {
              e7 = e7.W;
            } else if (i6 > 0) {
              e7 = e7.U;
            } else
              return e7;
          }
          return e7 || this.h;
        }
        clear() {
          this.i = 0;
          this.Y = void 0;
          this.h.tt = void 0;
          this.h.U = this.h.W = void 0;
        }
        updateKeyByIterator(e7, t6) {
          const i6 = e7.o;
          if (i6 === this.h) {
            (0, _throwError.throwIteratorAccessError)();
          }
          if (this.i === 1) {
            i6.u = t6;
            return true;
          }
          if (i6 === this.h.U) {
            if (this.v(i6.B().u, t6) > 0) {
              i6.u = t6;
              return true;
            }
            return false;
          }
          if (i6 === this.h.W) {
            if (this.v(i6.L().u, t6) < 0) {
              i6.u = t6;
              return true;
            }
            return false;
          }
          const s5 = i6.L().u;
          if (this.v(s5, t6) >= 0)
            return false;
          const r7 = i6.B().u;
          if (this.v(r7, t6) <= 0)
            return false;
          i6.u = t6;
          return true;
        }
        eraseElementByPos(e7) {
          if (e7 < 0 || e7 > this.i - 1) {
            throw new RangeError();
          }
          let t6 = 0;
          const i6 = this;
          this.oe(this.Y, function(s5) {
            if (e7 === t6) {
              i6.V(s5);
              return true;
            }
            t6 += 1;
            return false;
          });
          return this.i;
        }
        eraseElementByKey(e7) {
          if (this.i === 0)
            return false;
          const t6 = this.I(this.Y, e7);
          if (t6 === this.h)
            return false;
          this.V(t6);
          return true;
        }
        eraseElementByIterator(e7) {
          const t6 = e7.o;
          if (t6 === this.h) {
            (0, _throwError.throwIteratorAccessError)();
          }
          const i6 = t6.W === void 0;
          const s5 = e7.iteratorType === 0;
          if (s5) {
            if (i6)
              e7.next();
          } else {
            if (!i6 || t6.U === void 0)
              e7.next();
          }
          this.V(t6);
          return e7;
        }
        forEach(e7) {
          let t6 = 0;
          for (const i6 of this)
            e7(i6, t6++, this);
        }
        getElementByPos(e7) {
          if (e7 < 0 || e7 > this.i - 1) {
            throw new RangeError();
          }
          let t6;
          let i6 = 0;
          for (const s5 of this) {
            if (i6 === e7) {
              t6 = s5;
              break;
            }
            i6 += 1;
          }
          return t6;
        }
        getHeight() {
          if (this.i === 0)
            return 0;
          const traversal = function(e7) {
            if (!e7)
              return 0;
            return Math.max(traversal(e7.U), traversal(e7.W)) + 1;
          };
          return traversal(this.Y);
        }
      };
      var _default = TreeContainer;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/TreeIterator.js
  var require_TreeIterator = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/TreeContainer/Base/TreeIterator.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _ContainerBase = require_ContainerBase();
      var _throwError = require_throwError();
      var TreeIterator = class extends _ContainerBase.ContainerIterator {
        constructor(t6, r7, i6) {
          super(i6);
          this.o = t6;
          this.h = r7;
          if (this.iteratorType === 0) {
            this.pre = function() {
              if (this.o === this.h.U) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.L();
              return this;
            };
            this.next = function() {
              if (this.o === this.h) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.B();
              return this;
            };
          } else {
            this.pre = function() {
              if (this.o === this.h.W) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.B();
              return this;
            };
            this.next = function() {
              if (this.o === this.h) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.L();
              return this;
            };
          }
        }
        get index() {
          let t6 = this.o;
          const r7 = this.h.tt;
          if (t6 === this.h) {
            if (r7) {
              return r7.rt - 1;
            }
            return 0;
          }
          let i6 = 0;
          if (t6.U) {
            i6 += t6.U.rt;
          }
          while (t6 !== r7) {
            const r8 = t6.tt;
            if (t6 === r8.W) {
              i6 += 1;
              if (r8.U) {
                i6 += r8.U.rt;
              }
            }
            t6 = r8;
          }
          return i6;
        }
      };
      var _default = TreeIterator;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/TreeContainer/OrderedSet.js
  var require_OrderedSet = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/TreeContainer/OrderedSet.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _Base = _interopRequireDefault(require_Base2());
      var _TreeIterator = _interopRequireDefault(require_TreeIterator());
      var _throwError = require_throwError();
      function _interopRequireDefault(e7) {
        return e7 && e7.t ? e7 : {
          default: e7
        };
      }
      var OrderedSetIterator = class _OrderedSetIterator extends _TreeIterator.default {
        constructor(e7, t6, r7, i6) {
          super(e7, t6, i6);
          this.container = r7;
        }
        get pointer() {
          if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
          }
          return this.o.u;
        }
        copy() {
          return new _OrderedSetIterator(this.o, this.h, this.container, this.iteratorType);
        }
      };
      var OrderedSet = class extends _Base.default {
        constructor(e7 = [], t6, r7) {
          super(t6, r7);
          const i6 = this;
          e7.forEach(function(e8) {
            i6.insert(e8);
          });
        }
        *K(e7) {
          if (e7 === void 0)
            return;
          yield* this.K(e7.U);
          yield e7.u;
          yield* this.K(e7.W);
        }
        begin() {
          return new OrderedSetIterator(this.h.U || this.h, this.h, this);
        }
        end() {
          return new OrderedSetIterator(this.h, this.h, this);
        }
        rBegin() {
          return new OrderedSetIterator(this.h.W || this.h, this.h, this, 1);
        }
        rEnd() {
          return new OrderedSetIterator(this.h, this.h, this, 1);
        }
        front() {
          return this.h.U ? this.h.U.u : void 0;
        }
        back() {
          return this.h.W ? this.h.W.u : void 0;
        }
        insert(e7, t6) {
          return this.M(e7, void 0, t6);
        }
        find(e7) {
          const t6 = this.I(this.Y, e7);
          return new OrderedSetIterator(t6, this.h, this);
        }
        lowerBound(e7) {
          const t6 = this.X(this.Y, e7);
          return new OrderedSetIterator(t6, this.h, this);
        }
        upperBound(e7) {
          const t6 = this.Z(this.Y, e7);
          return new OrderedSetIterator(t6, this.h, this);
        }
        reverseLowerBound(e7) {
          const t6 = this.$(this.Y, e7);
          return new OrderedSetIterator(t6, this.h, this);
        }
        reverseUpperBound(e7) {
          const t6 = this.rr(this.Y, e7);
          return new OrderedSetIterator(t6, this.h, this);
        }
        union(e7) {
          const t6 = this;
          e7.forEach(function(e8) {
            t6.insert(e8);
          });
          return this.i;
        }
        [Symbol.iterator]() {
          return this.K(this.Y);
        }
      };
      var _default = OrderedSet;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/TreeContainer/OrderedMap.js
  var require_OrderedMap = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/TreeContainer/OrderedMap.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _Base = _interopRequireDefault(require_Base2());
      var _TreeIterator = _interopRequireDefault(require_TreeIterator());
      var _throwError = require_throwError();
      function _interopRequireDefault(r7) {
        return r7 && r7.t ? r7 : {
          default: r7
        };
      }
      var OrderedMapIterator = class _OrderedMapIterator extends _TreeIterator.default {
        constructor(r7, t6, e7, s5) {
          super(r7, t6, s5);
          this.container = e7;
        }
        get pointer() {
          if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
          }
          const r7 = this;
          return new Proxy([], {
            get(t6, e7) {
              if (e7 === "0")
                return r7.o.u;
              else if (e7 === "1")
                return r7.o.l;
            },
            set(t6, e7, s5) {
              if (e7 !== "1") {
                throw new TypeError("props must be 1");
              }
              r7.o.l = s5;
              return true;
            }
          });
        }
        copy() {
          return new _OrderedMapIterator(this.o, this.h, this.container, this.iteratorType);
        }
      };
      var OrderedMap = class extends _Base.default {
        constructor(r7 = [], t6, e7) {
          super(t6, e7);
          const s5 = this;
          r7.forEach(function(r8) {
            s5.setElement(r8[0], r8[1]);
          });
        }
        *K(r7) {
          if (r7 === void 0)
            return;
          yield* this.K(r7.U);
          yield [r7.u, r7.l];
          yield* this.K(r7.W);
        }
        begin() {
          return new OrderedMapIterator(this.h.U || this.h, this.h, this);
        }
        end() {
          return new OrderedMapIterator(this.h, this.h, this);
        }
        rBegin() {
          return new OrderedMapIterator(this.h.W || this.h, this.h, this, 1);
        }
        rEnd() {
          return new OrderedMapIterator(this.h, this.h, this, 1);
        }
        front() {
          if (this.i === 0)
            return;
          const r7 = this.h.U;
          return [r7.u, r7.l];
        }
        back() {
          if (this.i === 0)
            return;
          const r7 = this.h.W;
          return [r7.u, r7.l];
        }
        lowerBound(r7) {
          const t6 = this.X(this.Y, r7);
          return new OrderedMapIterator(t6, this.h, this);
        }
        upperBound(r7) {
          const t6 = this.Z(this.Y, r7);
          return new OrderedMapIterator(t6, this.h, this);
        }
        reverseLowerBound(r7) {
          const t6 = this.$(this.Y, r7);
          return new OrderedMapIterator(t6, this.h, this);
        }
        reverseUpperBound(r7) {
          const t6 = this.rr(this.Y, r7);
          return new OrderedMapIterator(t6, this.h, this);
        }
        setElement(r7, t6, e7) {
          return this.M(r7, t6, e7);
        }
        find(r7) {
          const t6 = this.I(this.Y, r7);
          return new OrderedMapIterator(t6, this.h, this);
        }
        getElementByKey(r7) {
          const t6 = this.I(this.Y, r7);
          return t6.l;
        }
        union(r7) {
          const t6 = this;
          r7.forEach(function(r8) {
            t6.setElement(r8[0], r8[1]);
          });
          return this.i;
        }
        [Symbol.iterator]() {
          return this.K(this.Y);
        }
      };
      var _default = OrderedMap;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/utils/checkObject.js
  var require_checkObject = __commonJS({
    "node_modules/js-sdsl/dist/cjs/utils/checkObject.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = checkObject;
      function checkObject(e7) {
        const t6 = typeof e7;
        return t6 === "object" && e7 !== null || t6 === "function";
      }
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/HashContainer/Base/index.js
  var require_Base3 = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/HashContainer/Base/index.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.HashContainerIterator = exports5.HashContainer = void 0;
      var _ContainerBase = require_ContainerBase();
      var _checkObject = _interopRequireDefault(require_checkObject());
      var _throwError = require_throwError();
      function _interopRequireDefault(t6) {
        return t6 && t6.t ? t6 : {
          default: t6
        };
      }
      var HashContainerIterator = class extends _ContainerBase.ContainerIterator {
        constructor(t6, e7, i6) {
          super(i6);
          this.o = t6;
          this.h = e7;
          if (this.iteratorType === 0) {
            this.pre = function() {
              if (this.o.L === this.h) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.L;
              return this;
            };
            this.next = function() {
              if (this.o === this.h) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.B;
              return this;
            };
          } else {
            this.pre = function() {
              if (this.o.B === this.h) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.B;
              return this;
            };
            this.next = function() {
              if (this.o === this.h) {
                (0, _throwError.throwIteratorAccessError)();
              }
              this.o = this.o.L;
              return this;
            };
          }
        }
      };
      exports5.HashContainerIterator = HashContainerIterator;
      var HashContainer = class extends _ContainerBase.Container {
        constructor() {
          super();
          this.H = [];
          this.g = {};
          this.HASH_TAG = Symbol("@@HASH_TAG");
          Object.setPrototypeOf(this.g, null);
          this.h = {};
          this.h.L = this.h.B = this.p = this._ = this.h;
        }
        V(t6) {
          const { L: e7, B: i6 } = t6;
          e7.B = i6;
          i6.L = e7;
          if (t6 === this.p) {
            this.p = i6;
          }
          if (t6 === this._) {
            this._ = e7;
          }
          this.i -= 1;
        }
        M(t6, e7, i6) {
          if (i6 === void 0)
            i6 = (0, _checkObject.default)(t6);
          let s5;
          if (i6) {
            const i7 = t6[this.HASH_TAG];
            if (i7 !== void 0) {
              this.H[i7].l = e7;
              return this.i;
            }
            Object.defineProperty(t6, this.HASH_TAG, {
              value: this.H.length,
              configurable: true
            });
            s5 = {
              u: t6,
              l: e7,
              L: this._,
              B: this.h
            };
            this.H.push(s5);
          } else {
            const i7 = this.g[t6];
            if (i7) {
              i7.l = e7;
              return this.i;
            }
            s5 = {
              u: t6,
              l: e7,
              L: this._,
              B: this.h
            };
            this.g[t6] = s5;
          }
          if (this.i === 0) {
            this.p = s5;
            this.h.B = s5;
          } else {
            this._.B = s5;
          }
          this._ = s5;
          this.h.L = s5;
          return ++this.i;
        }
        I(t6, e7) {
          if (e7 === void 0)
            e7 = (0, _checkObject.default)(t6);
          if (e7) {
            const e8 = t6[this.HASH_TAG];
            if (e8 === void 0)
              return this.h;
            return this.H[e8];
          } else {
            return this.g[t6] || this.h;
          }
        }
        clear() {
          const t6 = this.HASH_TAG;
          this.H.forEach(function(e7) {
            delete e7.u[t6];
          });
          this.H = [];
          this.g = {};
          Object.setPrototypeOf(this.g, null);
          this.i = 0;
          this.p = this._ = this.h.L = this.h.B = this.h;
        }
        eraseElementByKey(t6, e7) {
          let i6;
          if (e7 === void 0)
            e7 = (0, _checkObject.default)(t6);
          if (e7) {
            const e8 = t6[this.HASH_TAG];
            if (e8 === void 0)
              return false;
            delete t6[this.HASH_TAG];
            i6 = this.H[e8];
            delete this.H[e8];
          } else {
            i6 = this.g[t6];
            if (i6 === void 0)
              return false;
            delete this.g[t6];
          }
          this.V(i6);
          return true;
        }
        eraseElementByIterator(t6) {
          const e7 = t6.o;
          if (e7 === this.h) {
            (0, _throwError.throwIteratorAccessError)();
          }
          this.V(e7);
          return t6.next();
        }
        eraseElementByPos(t6) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          let e7 = this.p;
          while (t6--) {
            e7 = e7.B;
          }
          this.V(e7);
          return this.i;
        }
      };
      exports5.HashContainer = HashContainer;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/HashContainer/HashSet.js
  var require_HashSet = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/HashContainer/HashSet.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _Base = require_Base3();
      var _throwError = require_throwError();
      var HashSetIterator = class _HashSetIterator extends _Base.HashContainerIterator {
        constructor(t6, e7, r7, s5) {
          super(t6, e7, s5);
          this.container = r7;
        }
        get pointer() {
          if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
          }
          return this.o.u;
        }
        copy() {
          return new _HashSetIterator(this.o, this.h, this.container, this.iteratorType);
        }
      };
      var HashSet = class extends _Base.HashContainer {
        constructor(t6 = []) {
          super();
          const e7 = this;
          t6.forEach(function(t7) {
            e7.insert(t7);
          });
        }
        begin() {
          return new HashSetIterator(this.p, this.h, this);
        }
        end() {
          return new HashSetIterator(this.h, this.h, this);
        }
        rBegin() {
          return new HashSetIterator(this._, this.h, this, 1);
        }
        rEnd() {
          return new HashSetIterator(this.h, this.h, this, 1);
        }
        front() {
          return this.p.u;
        }
        back() {
          return this._.u;
        }
        insert(t6, e7) {
          return this.M(t6, void 0, e7);
        }
        getElementByPos(t6) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          let e7 = this.p;
          while (t6--) {
            e7 = e7.B;
          }
          return e7.u;
        }
        find(t6, e7) {
          const r7 = this.I(t6, e7);
          return new HashSetIterator(r7, this.h, this);
        }
        forEach(t6) {
          let e7 = 0;
          let r7 = this.p;
          while (r7 !== this.h) {
            t6(r7.u, e7++, this);
            r7 = r7.B;
          }
        }
        [Symbol.iterator]() {
          return function* () {
            let t6 = this.p;
            while (t6 !== this.h) {
              yield t6.u;
              t6 = t6.B;
            }
          }.bind(this)();
        }
      };
      var _default = HashSet;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/container/HashContainer/HashMap.js
  var require_HashMap = __commonJS({
    "node_modules/js-sdsl/dist/cjs/container/HashContainer/HashMap.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      exports5.default = void 0;
      var _Base = require_Base3();
      var _checkObject = _interopRequireDefault(require_checkObject());
      var _throwError = require_throwError();
      function _interopRequireDefault(t6) {
        return t6 && t6.t ? t6 : {
          default: t6
        };
      }
      var HashMapIterator = class _HashMapIterator extends _Base.HashContainerIterator {
        constructor(t6, e7, r7, s5) {
          super(t6, e7, s5);
          this.container = r7;
        }
        get pointer() {
          if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
          }
          const t6 = this;
          return new Proxy([], {
            get(e7, r7) {
              if (r7 === "0")
                return t6.o.u;
              else if (r7 === "1")
                return t6.o.l;
            },
            set(e7, r7, s5) {
              if (r7 !== "1") {
                throw new TypeError("props must be 1");
              }
              t6.o.l = s5;
              return true;
            }
          });
        }
        copy() {
          return new _HashMapIterator(this.o, this.h, this.container, this.iteratorType);
        }
      };
      var HashMap = class extends _Base.HashContainer {
        constructor(t6 = []) {
          super();
          const e7 = this;
          t6.forEach(function(t7) {
            e7.setElement(t7[0], t7[1]);
          });
        }
        begin() {
          return new HashMapIterator(this.p, this.h, this);
        }
        end() {
          return new HashMapIterator(this.h, this.h, this);
        }
        rBegin() {
          return new HashMapIterator(this._, this.h, this, 1);
        }
        rEnd() {
          return new HashMapIterator(this.h, this.h, this, 1);
        }
        front() {
          if (this.i === 0)
            return;
          return [this.p.u, this.p.l];
        }
        back() {
          if (this.i === 0)
            return;
          return [this._.u, this._.l];
        }
        setElement(t6, e7, r7) {
          return this.M(t6, e7, r7);
        }
        getElementByKey(t6, e7) {
          if (e7 === void 0)
            e7 = (0, _checkObject.default)(t6);
          if (e7) {
            const e8 = t6[this.HASH_TAG];
            return e8 !== void 0 ? this.H[e8].l : void 0;
          }
          const r7 = this.g[t6];
          return r7 ? r7.l : void 0;
        }
        getElementByPos(t6) {
          if (t6 < 0 || t6 > this.i - 1) {
            throw new RangeError();
          }
          let e7 = this.p;
          while (t6--) {
            e7 = e7.B;
          }
          return [e7.u, e7.l];
        }
        find(t6, e7) {
          const r7 = this.I(t6, e7);
          return new HashMapIterator(r7, this.h, this);
        }
        forEach(t6) {
          let e7 = 0;
          let r7 = this.p;
          while (r7 !== this.h) {
            t6([r7.u, r7.l], e7++, this);
            r7 = r7.B;
          }
        }
        [Symbol.iterator]() {
          return function* () {
            let t6 = this.p;
            while (t6 !== this.h) {
              yield [t6.u, t6.l];
              t6 = t6.B;
            }
          }.bind(this)();
        }
      };
      var _default = HashMap;
      exports5.default = _default;
    }
  });

  // node_modules/js-sdsl/dist/cjs/index.js
  var require_cjs2 = __commonJS({
    "node_modules/js-sdsl/dist/cjs/index.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "t", {
        value: true
      });
      Object.defineProperty(exports5, "Deque", {
        enumerable: true,
        get: function() {
          return _Deque.default;
        }
      });
      Object.defineProperty(exports5, "HashMap", {
        enumerable: true,
        get: function() {
          return _HashMap.default;
        }
      });
      Object.defineProperty(exports5, "HashSet", {
        enumerable: true,
        get: function() {
          return _HashSet.default;
        }
      });
      Object.defineProperty(exports5, "LinkList", {
        enumerable: true,
        get: function() {
          return _LinkList.default;
        }
      });
      Object.defineProperty(exports5, "OrderedMap", {
        enumerable: true,
        get: function() {
          return _OrderedMap.default;
        }
      });
      Object.defineProperty(exports5, "OrderedSet", {
        enumerable: true,
        get: function() {
          return _OrderedSet.default;
        }
      });
      Object.defineProperty(exports5, "PriorityQueue", {
        enumerable: true,
        get: function() {
          return _PriorityQueue.default;
        }
      });
      Object.defineProperty(exports5, "Queue", {
        enumerable: true,
        get: function() {
          return _Queue.default;
        }
      });
      Object.defineProperty(exports5, "Stack", {
        enumerable: true,
        get: function() {
          return _Stack.default;
        }
      });
      Object.defineProperty(exports5, "Vector", {
        enumerable: true,
        get: function() {
          return _Vector.default;
        }
      });
      var _Stack = _interopRequireDefault(require_Stack());
      var _Queue = _interopRequireDefault(require_Queue());
      var _PriorityQueue = _interopRequireDefault(require_PriorityQueue());
      var _Vector = _interopRequireDefault(require_Vector());
      var _LinkList = _interopRequireDefault(require_LinkList());
      var _Deque = _interopRequireDefault(require_Deque());
      var _OrderedSet = _interopRequireDefault(require_OrderedSet());
      var _OrderedMap = _interopRequireDefault(require_OrderedMap());
      var _HashSet = _interopRequireDefault(require_HashSet());
      var _HashMap = _interopRequireDefault(require_HashMap());
      function _interopRequireDefault(e7) {
        return e7 && e7.t ? e7 : {
          default: e7
        };
      }
    }
  });

  // node_modules/number-allocator/lib/number-allocator.js
  var require_number_allocator = __commonJS({
    "node_modules/number-allocator/lib/number-allocator.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var SortedSet = require_cjs2().OrderedSet;
      var debugTrace = require_browser4()("number-allocator:trace");
      var debugError = require_browser4()("number-allocator:error");
      function Interval(low, high) {
        this.low = low;
        this.high = high;
      }
      Interval.prototype.equals = function(other) {
        return this.low === other.low && this.high === other.high;
      };
      Interval.prototype.compare = function(other) {
        if (this.low < other.low && this.high < other.low)
          return -1;
        if (other.low < this.low && other.high < this.low)
          return 1;
        return 0;
      };
      function NumberAllocator(min, max) {
        if (!(this instanceof NumberAllocator)) {
          return new NumberAllocator(min, max);
        }
        this.min = min;
        this.max = max;
        this.ss = new SortedSet(
          [],
          (lhs, rhs) => {
            return lhs.compare(rhs);
          }
        );
        debugTrace("Create");
        this.clear();
      }
      NumberAllocator.prototype.firstVacant = function() {
        if (this.ss.size() === 0)
          return null;
        return this.ss.front().low;
      };
      NumberAllocator.prototype.alloc = function() {
        if (this.ss.size() === 0) {
          debugTrace("alloc():empty");
          return null;
        }
        const it = this.ss.begin();
        const low = it.pointer.low;
        const high = it.pointer.high;
        const num = low;
        if (num + 1 <= high) {
          this.ss.updateKeyByIterator(it, new Interval(low + 1, high));
        } else {
          this.ss.eraseElementByPos(0);
        }
        debugTrace("alloc():" + num);
        return num;
      };
      NumberAllocator.prototype.use = function(num) {
        const key = new Interval(num, num);
        const it = this.ss.lowerBound(key);
        if (!it.equals(this.ss.end())) {
          const low = it.pointer.low;
          const high = it.pointer.high;
          if (it.pointer.equals(key)) {
            this.ss.eraseElementByIterator(it);
            debugTrace("use():" + num);
            return true;
          }
          if (low > num)
            return false;
          if (low === num) {
            this.ss.updateKeyByIterator(it, new Interval(low + 1, high));
            debugTrace("use():" + num);
            return true;
          }
          if (high === num) {
            this.ss.updateKeyByIterator(it, new Interval(low, high - 1));
            debugTrace("use():" + num);
            return true;
          }
          this.ss.updateKeyByIterator(it, new Interval(num + 1, high));
          this.ss.insert(new Interval(low, num - 1));
          debugTrace("use():" + num);
          return true;
        }
        debugTrace("use():failed");
        return false;
      };
      NumberAllocator.prototype.free = function(num) {
        if (num < this.min || num > this.max) {
          debugError("free():" + num + " is out of range");
          return;
        }
        const key = new Interval(num, num);
        const it = this.ss.upperBound(key);
        if (it.equals(this.ss.end())) {
          if (it.equals(this.ss.begin())) {
            this.ss.insert(key);
            return;
          }
          it.pre();
          const low = it.pointer.high;
          const high = it.pointer.high;
          if (high + 1 === num) {
            this.ss.updateKeyByIterator(it, new Interval(low, num));
          } else {
            this.ss.insert(key);
          }
        } else {
          if (it.equals(this.ss.begin())) {
            if (num + 1 === it.pointer.low) {
              const high = it.pointer.high;
              this.ss.updateKeyByIterator(it, new Interval(num, high));
            } else {
              this.ss.insert(key);
            }
          } else {
            const rLow = it.pointer.low;
            const rHigh = it.pointer.high;
            it.pre();
            const lLow = it.pointer.low;
            const lHigh = it.pointer.high;
            if (lHigh + 1 === num) {
              if (num + 1 === rLow) {
                this.ss.eraseElementByIterator(it);
                this.ss.updateKeyByIterator(it, new Interval(lLow, rHigh));
              } else {
                this.ss.updateKeyByIterator(it, new Interval(lLow, num));
              }
            } else {
              if (num + 1 === rLow) {
                this.ss.eraseElementByIterator(it.next());
                this.ss.insert(new Interval(num, rHigh));
              } else {
                this.ss.insert(key);
              }
            }
          }
        }
        debugTrace("free():" + num);
      };
      NumberAllocator.prototype.clear = function() {
        debugTrace("clear()");
        this.ss.clear();
        this.ss.insert(new Interval(this.min, this.max));
      };
      NumberAllocator.prototype.intervalCount = function() {
        return this.ss.size();
      };
      NumberAllocator.prototype.dump = function() {
        console.log("length:" + this.ss.size());
        for (const element of this.ss) {
          console.log(element);
        }
      };
      module.exports = NumberAllocator;
    }
  });

  // node_modules/number-allocator/index.js
  var require_number_allocator2 = __commonJS({
    "node_modules/number-allocator/index.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      var NumberAllocator = require_number_allocator();
      module.exports.NumberAllocator = NumberAllocator;
    }
  });

  // build/lib/topic-alias-send.js
  var require_topic_alias_send = __commonJS({
    "build/lib/topic-alias-send.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      var lru_cache_1 = require_cjs();
      var number_allocator_1 = require_number_allocator2();
      var TopicAliasSend = class {
        constructor(max) {
          if (max > 0) {
            this.aliasToTopic = new lru_cache_1.LRUCache({ max });
            this.topicToAlias = {};
            this.numberAllocator = new number_allocator_1.NumberAllocator(1, max);
            this.max = max;
            this.length = 0;
          }
        }
        put(topic, alias) {
          if (alias === 0 || alias > this.max) {
            return false;
          }
          const entry = this.aliasToTopic.get(alias);
          if (entry) {
            delete this.topicToAlias[entry];
          }
          this.aliasToTopic.set(alias, topic);
          this.topicToAlias[topic] = alias;
          this.numberAllocator.use(alias);
          this.length = this.aliasToTopic.size;
          return true;
        }
        getTopicByAlias(alias) {
          return this.aliasToTopic.get(alias);
        }
        getAliasByTopic(topic) {
          const alias = this.topicToAlias[topic];
          if (typeof alias !== "undefined") {
            this.aliasToTopic.get(alias);
          }
          return alias;
        }
        clear() {
          this.aliasToTopic.clear();
          this.topicToAlias = {};
          this.numberAllocator.clear();
          this.length = 0;
        }
        getLruAlias() {
          const alias = this.numberAllocator.firstVacant();
          if (alias)
            return alias;
          return [...this.aliasToTopic.keys()][this.aliasToTopic.size - 1];
        }
      };
      exports5.default = TopicAliasSend;
    }
  });

  // build/lib/handlers/connack.js
  var require_connack = __commonJS({
    "build/lib/handlers/connack.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var __importDefault = exports5 && exports5.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      var ack_1 = require_ack();
      var topic_alias_send_1 = __importDefault(require_topic_alias_send());
      var shared_1 = require_shared();
      var handleConnack = (client, packet) => {
        client.log("_handleConnack");
        const { options } = client;
        const version2 = options.protocolVersion;
        const rc = version2 === 5 ? packet.reasonCode : packet.returnCode;
        clearTimeout(client["connackTimer"]);
        delete client["topicAliasSend"];
        if (packet.properties) {
          if (packet.properties.topicAliasMaximum) {
            if (packet.properties.topicAliasMaximum > 65535) {
              client.emit("error", new Error("topicAliasMaximum from broker is out of range"));
              return;
            }
            if (packet.properties.topicAliasMaximum > 0) {
              client["topicAliasSend"] = new topic_alias_send_1.default(packet.properties.topicAliasMaximum);
            }
          }
          if (packet.properties.serverKeepAlive && options.keepalive) {
            options.keepalive = packet.properties.serverKeepAlive;
            client["_shiftPingInterval"]();
          }
          if (packet.properties.maximumPacketSize) {
            if (!options.properties) {
              options.properties = {};
            }
            options.properties.maximumPacketSize = packet.properties.maximumPacketSize;
          }
        }
        if (rc === 0) {
          client.reconnecting = false;
          client["_onConnect"](packet);
        } else if (rc > 0) {
          const err = new shared_1.ErrorWithReasonCode(`Connection refused: ${ack_1.ReasonCodes[rc]}`, rc);
          client.emit("error", err);
        }
      };
      exports5.default = handleConnack;
    }
  });

  // build/lib/handlers/pubrel.js
  var require_pubrel = __commonJS({
    "build/lib/handlers/pubrel.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      var handlePubrel = (client, packet, done) => {
        client.log("handling pubrel packet");
        const callback = typeof done !== "undefined" ? done : client.noop;
        const { messageId } = packet;
        const comp = { cmd: "pubcomp", messageId };
        client.incomingStore.get(packet, (err, pub) => {
          if (!err) {
            client.emit("message", pub.topic, pub.payload, pub);
            client.handleMessage(pub, (err2) => {
              if (err2) {
                return callback(err2);
              }
              client.incomingStore.del(pub, client.noop);
              client["_sendPacket"](comp, callback);
            });
          } else {
            client["_sendPacket"](comp, callback);
          }
        });
      };
      exports5.default = handlePubrel;
    }
  });

  // build/lib/handlers/index.js
  var require_handlers = __commonJS({
    "build/lib/handlers/index.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var __importDefault = exports5 && exports5.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      var publish_1 = __importDefault(require_publish());
      var auth_1 = __importDefault(require_auth());
      var connack_1 = __importDefault(require_connack());
      var ack_1 = __importDefault(require_ack());
      var pubrel_1 = __importDefault(require_pubrel());
      var handle = (client, packet, done) => {
        const { options } = client;
        if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {
          client.emit("error", new Error(`exceeding packets size ${packet.cmd}`));
          client.end({
            reasonCode: 149,
            properties: { reasonString: "Maximum packet size was exceeded" }
          });
          return client;
        }
        client.log("_handlePacket :: emitting packetreceive");
        client.emit("packetreceive", packet);
        switch (packet.cmd) {
          case "publish":
            (0, publish_1.default)(client, packet, done);
            break;
          case "puback":
          case "pubrec":
          case "pubcomp":
          case "suback":
          case "unsuback":
            (0, ack_1.default)(client, packet);
            done();
            break;
          case "pubrel":
            (0, pubrel_1.default)(client, packet, done);
            break;
          case "connack":
            (0, connack_1.default)(client, packet);
            done();
            break;
          case "auth":
            (0, auth_1.default)(client, packet);
            done();
            break;
          case "pingresp":
            client.pingResp = true;
            done();
            break;
          case "disconnect":
            client.emit("disconnect", packet);
            done();
            break;
          default:
            client.log("_handlePacket :: unknown command");
            done();
            break;
        }
      };
      exports5.default = handle;
    }
  });

  // build/lib/TypedEmitter.js
  var require_TypedEmitter = __commonJS({
    "build/lib/TypedEmitter.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var __importDefault = exports5 && exports5.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      exports5.TypedEventEmitter = void 0;
      var events_1 = __importDefault((init_events(), __toCommonJS(events_exports)));
      var shared_1 = require_shared();
      var TypedEventEmitter = class {
      };
      exports5.TypedEventEmitter = TypedEventEmitter;
      (0, shared_1.applyMixin)(TypedEventEmitter, events_1.default);
    }
  });

  // build/lib/is-browser.js
  var require_is_browser = __commonJS({
    "build/lib/is-browser.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      exports5.isReactNativeBrowser = exports5.isWebWorker = void 0;
      var isStandardBrowserEnv = () => typeof window !== "undefined" && typeof window.document !== "undefined";
      var isWebWorkerEnv = () => {
        var _a, _b;
        return Boolean(typeof self === "object" && ((_b = (_a = self === null || self === void 0 ? void 0 : self.constructor) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.includes("WorkerGlobalScope")));
      };
      var isReactNativeEnv = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
      var isBrowser = isStandardBrowserEnv() || isWebWorkerEnv() || isReactNativeEnv();
      exports5.isWebWorker = isWebWorkerEnv();
      exports5.isReactNativeBrowser = isReactNativeEnv();
      exports5.default = isBrowser;
    }
  });

  // node_modules/fast-unique-numbers/build/es5/bundle.js
  var require_bundle = __commonJS({
    "node_modules/fast-unique-numbers/build/es5/bundle.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      (function(global2, factory) {
        typeof exports5 === "object" && typeof module !== "undefined" ? factory(exports5) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.fastUniqueNumbers = {}));
      })(exports5, function(exports6) {
        "use strict";
        var createAddUniqueNumber = function createAddUniqueNumber2(generateUniqueNumber2) {
          return function(set) {
            var number = generateUniqueNumber2(set);
            set.add(number);
            return number;
          };
        };
        var createCache = function createCache2(lastNumberWeakMap) {
          return function(collection, nextNumber) {
            lastNumberWeakMap.set(collection, nextNumber);
            return nextNumber;
          };
        };
        var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === void 0 ? 9007199254740991 : Number.MAX_SAFE_INTEGER;
        var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;
        var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;
        var createGenerateUniqueNumber = function createGenerateUniqueNumber2(cache2, lastNumberWeakMap) {
          return function(collection) {
            var lastNumber = lastNumberWeakMap.get(collection);
            var nextNumber = lastNumber === void 0 ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;
            if (!collection.has(nextNumber)) {
              return cache2(collection, nextNumber);
            }
            if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {
              while (collection.has(nextNumber)) {
                nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);
              }
              return cache2(collection, nextNumber);
            }
            if (collection.size > MAX_SAFE_INTEGER) {
              throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");
            }
            while (collection.has(nextNumber)) {
              nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);
            }
            return cache2(collection, nextNumber);
          };
        };
        var LAST_NUMBER_WEAK_MAP = /* @__PURE__ */ new WeakMap();
        var cache = createCache(LAST_NUMBER_WEAK_MAP);
        var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);
        var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);
        exports6.addUniqueNumber = addUniqueNumber;
        exports6.generateUniqueNumber = generateUniqueNumber;
      });
    }
  });

  // node_modules/worker-timers-broker/build/es5/bundle.js
  var require_bundle2 = __commonJS({
    "node_modules/worker-timers-broker/build/es5/bundle.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      (function(global2, factory) {
        typeof exports5 === "object" && typeof module !== "undefined" ? factory(exports5, require_bundle()) : typeof define === "function" && define.amd ? define(["exports", "fast-unique-numbers"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.workerTimersBroker = {}, global2.fastUniqueNumbers));
      })(exports5, function(exports6, fastUniqueNumbers) {
        "use strict";
        var isCallNotification = function isCallNotification2(message) {
          return message.method !== void 0 && message.method === "call";
        };
        var isClearResponse = function isClearResponse2(message) {
          return message.error === null && typeof message.id === "number";
        };
        var load = function load2(url) {
          var scheduledIntervalFunctions = /* @__PURE__ */ new Map([[0, function() {
          }]]);
          var scheduledTimeoutFunctions = /* @__PURE__ */ new Map([[0, function() {
          }]]);
          var unrespondedRequests = /* @__PURE__ */ new Map();
          var worker = new Worker(url);
          worker.addEventListener("message", function(_ref) {
            var data = _ref.data;
            if (isCallNotification(data)) {
              var _data$params = data.params, timerId = _data$params.timerId, timerType = _data$params.timerType;
              if (timerType === "interval") {
                var idOrFunc = scheduledIntervalFunctions.get(timerId);
                if (typeof idOrFunc === "number") {
                  var timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
                  if (timerIdAndTimerType === void 0 || timerIdAndTimerType.timerId !== timerId || timerIdAndTimerType.timerType !== timerType) {
                    throw new Error("The timer is in an undefined state.");
                  }
                } else if (typeof idOrFunc !== "undefined") {
                  idOrFunc();
                } else {
                  throw new Error("The timer is in an undefined state.");
                }
              } else if (timerType === "timeout") {
                var _idOrFunc = scheduledTimeoutFunctions.get(timerId);
                if (typeof _idOrFunc === "number") {
                  var _timerIdAndTimerType = unrespondedRequests.get(_idOrFunc);
                  if (_timerIdAndTimerType === void 0 || _timerIdAndTimerType.timerId !== timerId || _timerIdAndTimerType.timerType !== timerType) {
                    throw new Error("The timer is in an undefined state.");
                  }
                } else if (typeof _idOrFunc !== "undefined") {
                  _idOrFunc();
                  scheduledTimeoutFunctions["delete"](timerId);
                } else {
                  throw new Error("The timer is in an undefined state.");
                }
              }
            } else if (isClearResponse(data)) {
              var id = data.id;
              var _timerIdAndTimerType2 = unrespondedRequests.get(id);
              if (_timerIdAndTimerType2 === void 0) {
                throw new Error("The timer is in an undefined state.");
              }
              var _timerId = _timerIdAndTimerType2.timerId, _timerType = _timerIdAndTimerType2.timerType;
              unrespondedRequests["delete"](id);
              if (_timerType === "interval") {
                scheduledIntervalFunctions["delete"](_timerId);
              } else {
                scheduledTimeoutFunctions["delete"](_timerId);
              }
            } else {
              var message = data.error.message;
              throw new Error(message);
            }
          });
          var clearInterval2 = function clearInterval3(timerId) {
            var id = fastUniqueNumbers.generateUniqueNumber(unrespondedRequests);
            unrespondedRequests.set(id, {
              timerId,
              timerType: "interval"
            });
            scheduledIntervalFunctions.set(timerId, id);
            worker.postMessage({
              id,
              method: "clear",
              params: {
                timerId,
                timerType: "interval"
              }
            });
          };
          var clearTimeout2 = function clearTimeout3(timerId) {
            var id = fastUniqueNumbers.generateUniqueNumber(unrespondedRequests);
            unrespondedRequests.set(id, {
              timerId,
              timerType: "timeout"
            });
            scheduledTimeoutFunctions.set(timerId, id);
            worker.postMessage({
              id,
              method: "clear",
              params: {
                timerId,
                timerType: "timeout"
              }
            });
          };
          var setInterval2 = function setInterval3(func) {
            var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var timerId = fastUniqueNumbers.generateUniqueNumber(scheduledIntervalFunctions);
            scheduledIntervalFunctions.set(timerId, function() {
              func();
              if (typeof scheduledIntervalFunctions.get(timerId) === "function") {
                worker.postMessage({
                  id: null,
                  method: "set",
                  params: {
                    delay,
                    now: performance.now(),
                    timerId,
                    timerType: "interval"
                  }
                });
              }
            });
            worker.postMessage({
              id: null,
              method: "set",
              params: {
                delay,
                now: performance.now(),
                timerId,
                timerType: "interval"
              }
            });
            return timerId;
          };
          var setTimeout2 = function setTimeout3(func) {
            var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var timerId = fastUniqueNumbers.generateUniqueNumber(scheduledTimeoutFunctions);
            scheduledTimeoutFunctions.set(timerId, func);
            worker.postMessage({
              id: null,
              method: "set",
              params: {
                delay,
                now: performance.now(),
                timerId,
                timerType: "timeout"
              }
            });
            return timerId;
          };
          return {
            clearInterval: clearInterval2,
            clearTimeout: clearTimeout2,
            setInterval: setInterval2,
            setTimeout: setTimeout2
          };
        };
        exports6.load = load;
      });
    }
  });

  // node_modules/worker-timers/build/es5/bundle.js
  var require_bundle3 = __commonJS({
    "node_modules/worker-timers/build/es5/bundle.js"(exports5, module) {
      init_buffer2();
      init_process2();
      init_navigator();
      (function(global2, factory) {
        typeof exports5 === "object" && typeof module !== "undefined" ? factory(exports5, require_bundle2()) : typeof define === "function" && define.amd ? define(["exports", "worker-timers-broker"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.workerTimers = {}, global2.workerTimersBroker));
      })(exports5, function(exports6, workerTimersBroker) {
        "use strict";
        var createLoadOrReturnBroker = function createLoadOrReturnBroker2(loadBroker, worker2) {
          var broker = null;
          return function() {
            if (broker !== null) {
              return broker;
            }
            var blob = new Blob([worker2], {
              type: "application/javascript; charset=utf-8"
            });
            var url = URL.createObjectURL(blob);
            broker = loadBroker(url);
            setTimeout(function() {
              return URL.revokeObjectURL(url);
            });
            return broker;
          };
        };
        var worker = `(()=>{var e={472:(e,t,r)=>{var o,i;void 0===(i="function"==typeof(o=function(){"use strict";var e=new Map,t=new Map,r=function(t){var r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id "'.concat(t,'".'));clearTimeout(r),e.delete(t)},o=function(e){var r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(r),t.delete(e)},i=function(e,t){var r,o=performance.now();return{expected:o+(r=e-Math.max(0,o-t)),remainingDelay:r}},n=function e(t,r,o,i){var n=performance.now();n>o?postMessage({id:null,method:"call",params:{timerId:r,timerType:i}}):t.set(r,setTimeout(e,o-n,t,r,o,i))},a=function(t,r,o){var a=i(t,o),s=a.expected,d=a.remainingDelay;e.set(r,setTimeout(n,d,e,r,s,"interval"))},s=function(e,r,o){var a=i(e,o),s=a.expected,d=a.remainingDelay;t.set(r,setTimeout(n,d,t,r,s,"timeout"))};addEventListener("message",(function(e){var t=e.data;try{if("clear"===t.method){var i=t.id,n=t.params,d=n.timerId,c=n.timerType;if("interval"===c)r(d),postMessage({error:null,id:i});else{if("timeout"!==c)throw new Error('The given type "'.concat(c,'" is not supported'));o(d),postMessage({error:null,id:i})}}else{if("set"!==t.method)throw new Error('The given method "'.concat(t.method,'" is not supported'));var u=t.params,l=u.delay,p=u.now,m=u.timerId,v=u.timerType;if("interval"===v)a(l,m,p);else{if("timeout"!==v)throw new Error('The given type "'.concat(v,'" is not supported'));s(l,m,p)}}}catch(e){postMessage({error:{message:e.message},id:t.id,result:null})}}))})?o.call(t,r,t,e):o)||(e.exports=i)}},t={};function r(o){var i=t[o];if(void 0!==i)return i.exports;var n=t[o]={exports:{}};return e[o](n,n.exports,r),n.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";r(472)})()})();`;
        var loadOrReturnBroker = createLoadOrReturnBroker(workerTimersBroker.load, worker);
        var clearInterval2 = function clearInterval3(timerId) {
          return loadOrReturnBroker().clearInterval(timerId);
        };
        var clearTimeout2 = function clearTimeout3(timerId) {
          return loadOrReturnBroker().clearTimeout(timerId);
        };
        var setInterval2 = function setInterval3() {
          var _loadOrReturnBroker;
          return (_loadOrReturnBroker = loadOrReturnBroker()).setInterval.apply(_loadOrReturnBroker, arguments);
        };
        var setTimeout$1 = function setTimeout2() {
          var _loadOrReturnBroker2;
          return (_loadOrReturnBroker2 = loadOrReturnBroker()).setTimeout.apply(_loadOrReturnBroker2, arguments);
        };
        exports6.clearInterval = clearInterval2;
        exports6.clearTimeout = clearTimeout2;
        exports6.setInterval = setInterval2;
        exports6.setTimeout = setTimeout$1;
      });
    }
  });

  // build/lib/get-timer.js
  var require_get_timer = __commonJS({
    "build/lib/get-timer.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var __createBinding = exports5 && exports5.__createBinding || (Object.create ? function(o7, m4, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m4, k2);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k2];
          } };
        }
        Object.defineProperty(o7, k22, desc);
      } : function(o7, m4, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o7[k22] = m4[k2];
      });
      var __setModuleDefault = exports5 && exports5.__setModuleDefault || (Object.create ? function(o7, v4) {
        Object.defineProperty(o7, "default", { enumerable: true, value: v4 });
      } : function(o7, v4) {
        o7["default"] = v4;
      });
      var __importStar = exports5 && exports5.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding(result, mod, k2);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      var is_browser_1 = __importStar(require_is_browser());
      var worker_timers_1 = require_bundle3();
      var workerTimer = {
        set: worker_timers_1.setTimeout,
        clear: worker_timers_1.clearTimeout
      };
      var nativeTimer = {
        set: (func, time) => setTimeout(func, time),
        clear: (timerId) => clearTimeout(timerId)
      };
      var getTimer = (variant) => {
        switch (variant) {
          case "native": {
            return nativeTimer;
          }
          case "worker": {
            return workerTimer;
          }
          case "auto":
          default: {
            return is_browser_1.default && !is_browser_1.isWebWorker && !is_browser_1.isReactNativeBrowser ? workerTimer : nativeTimer;
          }
        }
      };
      exports5.default = getTimer;
    }
  });

  // build/lib/PingTimer.js
  var require_PingTimer = __commonJS({
    "build/lib/PingTimer.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var __importDefault = exports5 && exports5.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      var get_timer_1 = __importDefault(require_get_timer());
      var PingTimer = class {
        constructor(keepalive, checkPing, variant) {
          this.destroyed = false;
          this.keepalive = keepalive * 1e3;
          this.checkPing = checkPing;
          this.timer = (0, get_timer_1.default)(variant);
          this.reschedule();
        }
        clear() {
          if (this.timerId) {
            this.timer.clear(this.timerId);
            this.timerId = null;
          }
        }
        destroy() {
          this.clear();
          this.destroyed = true;
        }
        reschedule() {
          if (this.destroyed) {
            return;
          }
          this.clear();
          this.timerId = this.timer.set(() => {
            if (this.destroyed) {
              return;
            }
            this.checkPing();
            this.reschedule();
          }, this.keepalive);
        }
      };
      exports5.default = PingTimer;
    }
  });

  // build/lib/client.js
  var require_client = __commonJS({
    "build/lib/client.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var __createBinding = exports5 && exports5.__createBinding || (Object.create ? function(o7, m4, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m4, k2);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k2];
          } };
        }
        Object.defineProperty(o7, k22, desc);
      } : function(o7, m4, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o7[k22] = m4[k2];
      });
      var __setModuleDefault = exports5 && exports5.__setModuleDefault || (Object.create ? function(o7, v4) {
        Object.defineProperty(o7, "default", { enumerable: true, value: v4 });
      } : function(o7, v4) {
        o7["default"] = v4;
      });
      var __importStar = exports5 && exports5.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding(result, mod, k2);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports5 && exports5.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      var topic_alias_recv_1 = __importDefault(require_topic_alias_recv());
      var mqtt_packet_1 = __importDefault(require_mqtt());
      var default_message_id_provider_1 = __importDefault(require_default_message_id_provider());
      var readable_stream_1 = require_browser3();
      var default_1 = __importDefault(require_default());
      var validations = __importStar(require_validations());
      var debug_1 = __importDefault(require_browser4());
      var store_1 = __importDefault(require_store());
      var handlers_1 = __importDefault(require_handlers());
      var shared_1 = require_shared();
      var TypedEmitter_1 = require_TypedEmitter();
      var PingTimer_1 = __importDefault(require_PingTimer());
      var is_browser_1 = __importStar(require_is_browser());
      var setImmediate2 = globalThis.setImmediate || ((...args) => {
        const callback = args.shift();
        (0, shared_1.nextTick)(() => {
          callback(...args);
        });
      });
      var defaultConnectOptions = {
        keepalive: 60,
        reschedulePings: true,
        protocolId: "MQTT",
        protocolVersion: 4,
        reconnectPeriod: 1e3,
        connectTimeout: 30 * 1e3,
        clean: true,
        resubscribe: true,
        writeCache: true,
        timerVariant: "auto"
      };
      var MqttClient = class _MqttClient extends TypedEmitter_1.TypedEventEmitter {
        static defaultId() {
          return `mqttjs_${Math.random().toString(16).substr(2, 8)}`;
        }
        constructor(streamBuilder, options) {
          super();
          this.options = options || {};
          for (const k2 in defaultConnectOptions) {
            if (typeof this.options[k2] === "undefined") {
              this.options[k2] = defaultConnectOptions[k2];
            } else {
              this.options[k2] = options[k2];
            }
          }
          this.log = this.options.log || (0, debug_1.default)("mqttjs:client");
          this.noop = this._noop.bind(this);
          this.log("MqttClient :: version:", _MqttClient.VERSION);
          if (is_browser_1.isWebWorker) {
            this.log("MqttClient :: environment", "webworker");
          } else {
            this.log("MqttClient :: environment", is_browser_1.default ? "browser" : "node");
          }
          this.log("MqttClient :: options.protocol", options.protocol);
          this.log("MqttClient :: options.protocolVersion", options.protocolVersion);
          this.log("MqttClient :: options.username", options.username);
          this.log("MqttClient :: options.keepalive", options.keepalive);
          this.log("MqttClient :: options.reconnectPeriod", options.reconnectPeriod);
          this.log("MqttClient :: options.rejectUnauthorized", options.rejectUnauthorized);
          this.log("MqttClient :: options.properties.topicAliasMaximum", options.properties ? options.properties.topicAliasMaximum : void 0);
          this.options.clientId = typeof options.clientId === "string" ? options.clientId : _MqttClient.defaultId();
          this.log("MqttClient :: clientId", this.options.clientId);
          this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : (...args) => {
            args[3](null, 0);
          };
          if (!this.options.writeCache) {
            mqtt_packet_1.default.writeToStream.cacheNumbers = false;
          }
          this.streamBuilder = streamBuilder;
          this.messageIdProvider = typeof this.options.messageIdProvider === "undefined" ? new default_message_id_provider_1.default() : this.options.messageIdProvider;
          this.outgoingStore = options.outgoingStore || new store_1.default();
          this.incomingStore = options.incomingStore || new store_1.default();
          this.queueQoSZero = options.queueQoSZero === void 0 ? true : options.queueQoSZero;
          this._resubscribeTopics = {};
          this.messageIdToTopic = {};
          this.pingTimer = null;
          this.connected = false;
          this.disconnecting = false;
          this.reconnecting = false;
          this.queue = [];
          this.connackTimer = null;
          this.reconnectTimer = null;
          this._storeProcessing = false;
          this._packetIdsDuringStoreProcessing = {};
          this._storeProcessingQueue = [];
          this.outgoing = {};
          this._firstConnection = true;
          if (options.properties && options.properties.topicAliasMaximum > 0) {
            if (options.properties.topicAliasMaximum > 65535) {
              this.log("MqttClient :: options.properties.topicAliasMaximum is out of range");
            } else {
              this.topicAliasRecv = new topic_alias_recv_1.default(options.properties.topicAliasMaximum);
            }
          }
          this.on("connect", () => {
            const { queue: queue2 } = this;
            const deliver = () => {
              const entry = queue2.shift();
              this.log("deliver :: entry %o", entry);
              let packet = null;
              if (!entry) {
                this._resubscribe();
                return;
              }
              packet = entry.packet;
              this.log("deliver :: call _sendPacket for %o", packet);
              let send = true;
              if (packet.messageId && packet.messageId !== 0) {
                if (!this.messageIdProvider.register(packet.messageId)) {
                  send = false;
                }
              }
              if (send) {
                this._sendPacket(packet, (err) => {
                  if (entry.cb) {
                    entry.cb(err);
                  }
                  deliver();
                });
              } else {
                this.log("messageId: %d has already used. The message is skipped and removed.", packet.messageId);
                deliver();
              }
            };
            this.log("connect :: sending queued packets");
            deliver();
          });
          this.on("close", () => {
            this.log("close :: connected set to `false`");
            this.connected = false;
            this.log("close :: clearing connackTimer");
            clearTimeout(this.connackTimer);
            this.log("close :: destroy ping timer");
            if (this.pingTimer) {
              this.pingTimer.destroy();
              this.pingTimer = null;
            }
            if (this.topicAliasRecv) {
              this.topicAliasRecv.clear();
            }
            this.log("close :: calling _setupReconnect");
            this._setupReconnect();
          });
          if (!this.options.manualConnect) {
            this.log("MqttClient :: setting up stream");
            this.connect();
          }
        }
        handleAuth(packet, callback) {
          callback();
        }
        handleMessage(packet, callback) {
          callback();
        }
        _nextId() {
          return this.messageIdProvider.allocate();
        }
        getLastMessageId() {
          return this.messageIdProvider.getLastAllocated();
        }
        connect() {
          var _a;
          const writable = new readable_stream_1.Writable();
          const parser = mqtt_packet_1.default.parser(this.options);
          let completeParse = null;
          const packets = [];
          this.log("connect :: calling method to clear reconnect");
          this._clearReconnect();
          this.log("connect :: using streamBuilder provided to client to create stream");
          this.stream = this.streamBuilder(this);
          parser.on("packet", (packet) => {
            this.log("parser :: on packet push to packets array.");
            packets.push(packet);
          });
          const work = () => {
            this.log("work :: getting next packet in queue");
            const packet = packets.shift();
            if (packet) {
              this.log("work :: packet pulled from queue");
              (0, handlers_1.default)(this, packet, nextTickWork);
            } else {
              this.log("work :: no packets in queue");
              const done = completeParse;
              completeParse = null;
              this.log("work :: done flag is %s", !!done);
              if (done)
                done();
            }
          };
          const nextTickWork = () => {
            if (packets.length) {
              (0, shared_1.nextTick)(work);
            } else {
              const done = completeParse;
              completeParse = null;
              done();
            }
          };
          writable._write = (buf, enc, done) => {
            completeParse = done;
            this.log("writable stream :: parsing buffer");
            parser.parse(buf);
            work();
          };
          const streamErrorHandler = (error) => {
            this.log("streamErrorHandler :: error", error.message);
            if (error.code) {
              this.log("streamErrorHandler :: emitting error");
              this.emit("error", error);
            } else {
              this.noop(error);
            }
          };
          this.log("connect :: pipe stream to writable stream");
          this.stream.pipe(writable);
          this.stream.on("error", streamErrorHandler);
          this.stream.on("close", () => {
            this.log("(%s)stream :: on close", this.options.clientId);
            this._flushVolatile();
            this.log("stream: emit close to MqttClient");
            this.emit("close");
          });
          this.log("connect: sending packet `connect`");
          const connectPacket = {
            cmd: "connect",
            protocolId: this.options.protocolId,
            protocolVersion: this.options.protocolVersion,
            clean: this.options.clean,
            clientId: this.options.clientId,
            keepalive: this.options.keepalive,
            username: this.options.username,
            password: this.options.password,
            properties: this.options.properties
          };
          if (this.options.will) {
            connectPacket.will = Object.assign(Object.assign({}, this.options.will), { payload: (_a = this.options.will) === null || _a === void 0 ? void 0 : _a.payload });
          }
          if (this.topicAliasRecv) {
            if (!connectPacket.properties) {
              connectPacket.properties = {};
            }
            if (this.topicAliasRecv) {
              connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max;
            }
          }
          this._writePacket(connectPacket);
          parser.on("error", this.emit.bind(this, "error"));
          if (this.options.properties) {
            if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {
              this.end(() => this.emit("error", new Error("Packet has no Authentication Method")));
              return this;
            }
            if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === "object") {
              const authPacket = Object.assign({ cmd: "auth", reasonCode: 0 }, this.options.authPacket);
              this._writePacket(authPacket);
            }
          }
          this.stream.setMaxListeners(1e3);
          clearTimeout(this.connackTimer);
          this.connackTimer = setTimeout(() => {
            this.log("!!connectTimeout hit!! Calling _cleanUp with force `true`");
            this.emit("error", new Error("connack timeout"));
            this._cleanUp(true);
          }, this.options.connectTimeout);
          return this;
        }
        publish(topic, message, opts, callback) {
          this.log("publish :: message `%s` to topic `%s`", message, topic);
          const { options } = this;
          if (typeof opts === "function") {
            callback = opts;
            opts = null;
          }
          opts = opts || {};
          const defaultOpts = {
            qos: 0,
            retain: false,
            dup: false
          };
          opts = Object.assign(Object.assign({}, defaultOpts), opts);
          const { qos, retain, dup, properties, cbStorePut } = opts;
          if (this._checkDisconnecting(callback)) {
            return this;
          }
          const publishProc = () => {
            let messageId = 0;
            if (qos === 1 || qos === 2) {
              messageId = this._nextId();
              if (messageId === null) {
                this.log("No messageId left");
                return false;
              }
            }
            const packet = {
              cmd: "publish",
              topic,
              payload: message,
              qos,
              retain,
              messageId,
              dup
            };
            if (options.protocolVersion === 5) {
              packet.properties = properties;
            }
            this.log("publish :: qos", qos);
            switch (qos) {
              case 1:
              case 2:
                this.outgoing[packet.messageId] = {
                  volatile: false,
                  cb: callback || this.noop
                };
                this.log("MqttClient:publish: packet cmd: %s", packet.cmd);
                this._sendPacket(packet, void 0, cbStorePut);
                break;
              default:
                this.log("MqttClient:publish: packet cmd: %s", packet.cmd);
                this._sendPacket(packet, callback, cbStorePut);
                break;
            }
            return true;
          };
          if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {
            this._storeProcessingQueue.push({
              invoke: publishProc,
              cbStorePut: opts.cbStorePut,
              callback
            });
          }
          return this;
        }
        publishAsync(topic, message, opts) {
          return new Promise((resolve2, reject) => {
            this.publish(topic, message, opts, (err, packet) => {
              if (err) {
                reject(err);
              } else {
                resolve2(packet);
              }
            });
          });
        }
        subscribe(topicObject, opts, callback) {
          const version2 = this.options.protocolVersion;
          if (typeof opts === "function") {
            callback = opts;
          }
          callback = callback || this.noop;
          let resubscribe = false;
          let topicsList = [];
          if (typeof topicObject === "string") {
            topicObject = [topicObject];
            topicsList = topicObject;
          } else if (Array.isArray(topicObject)) {
            topicsList = topicObject;
          } else if (typeof topicObject === "object") {
            resubscribe = topicObject.resubscribe;
            delete topicObject.resubscribe;
            topicsList = Object.keys(topicObject);
          }
          const invalidTopic = validations.validateTopics(topicsList);
          if (invalidTopic !== null) {
            setImmediate2(callback, new Error(`Invalid topic ${invalidTopic}`));
            return this;
          }
          if (this._checkDisconnecting(callback)) {
            this.log("subscribe: discconecting true");
            return this;
          }
          const defaultOpts = {
            qos: 0
          };
          if (version2 === 5) {
            defaultOpts.nl = false;
            defaultOpts.rap = false;
            defaultOpts.rh = 0;
          }
          opts = Object.assign(Object.assign({}, defaultOpts), opts);
          const properties = opts.properties;
          const subs = [];
          const parseSub = (topic, subOptions) => {
            subOptions = subOptions || opts;
            if (!Object.prototype.hasOwnProperty.call(this._resubscribeTopics, topic) || this._resubscribeTopics[topic].qos < subOptions.qos || resubscribe) {
              const currentOpts = {
                topic,
                qos: subOptions.qos
              };
              if (version2 === 5) {
                currentOpts.nl = subOptions.nl;
                currentOpts.rap = subOptions.rap;
                currentOpts.rh = subOptions.rh;
                currentOpts.properties = properties;
              }
              this.log("subscribe: pushing topic `%s` and qos `%s` to subs list", currentOpts.topic, currentOpts.qos);
              subs.push(currentOpts);
            }
          };
          if (Array.isArray(topicObject)) {
            topicObject.forEach((topic) => {
              this.log("subscribe: array topic %s", topic);
              parseSub(topic);
            });
          } else {
            Object.keys(topicObject).forEach((topic) => {
              this.log("subscribe: object topic %s, %o", topic, topicObject[topic]);
              parseSub(topic, topicObject[topic]);
            });
          }
          if (!subs.length) {
            callback(null, []);
            return this;
          }
          const subscribeProc = () => {
            const messageId = this._nextId();
            if (messageId === null) {
              this.log("No messageId left");
              return false;
            }
            const packet = {
              cmd: "subscribe",
              subscriptions: subs,
              messageId
            };
            if (properties) {
              packet.properties = properties;
            }
            if (this.options.resubscribe) {
              this.log("subscribe :: resubscribe true");
              const topics = [];
              subs.forEach((sub) => {
                if (this.options.reconnectPeriod > 0) {
                  const topic = { qos: sub.qos };
                  if (version2 === 5) {
                    topic.nl = sub.nl || false;
                    topic.rap = sub.rap || false;
                    topic.rh = sub.rh || 0;
                    topic.properties = sub.properties;
                  }
                  this._resubscribeTopics[sub.topic] = topic;
                  topics.push(sub.topic);
                }
              });
              this.messageIdToTopic[packet.messageId] = topics;
            }
            this.outgoing[packet.messageId] = {
              volatile: true,
              cb(err, packet2) {
                if (!err) {
                  const { granted } = packet2;
                  for (let i6 = 0; i6 < granted.length; i6 += 1) {
                    subs[i6].qos = granted[i6];
                  }
                }
                callback(err, subs);
              }
            };
            this.log("subscribe :: call _sendPacket");
            this._sendPacket(packet);
            return true;
          };
          if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {
            this._storeProcessingQueue.push({
              invoke: subscribeProc,
              callback
            });
          }
          return this;
        }
        subscribeAsync(topicObject, opts) {
          return new Promise((resolve2, reject) => {
            this.subscribe(topicObject, opts, (err, granted) => {
              if (err) {
                reject(err);
              } else {
                resolve2(granted);
              }
            });
          });
        }
        unsubscribe(topic, opts, callback) {
          if (typeof topic === "string") {
            topic = [topic];
          }
          if (typeof opts === "function") {
            callback = opts;
          }
          callback = callback || this.noop;
          const invalidTopic = validations.validateTopics(topic);
          if (invalidTopic !== null) {
            setImmediate2(callback, new Error(`Invalid topic ${invalidTopic}`));
            return this;
          }
          if (this._checkDisconnecting(callback)) {
            return this;
          }
          const unsubscribeProc = () => {
            const messageId = this._nextId();
            if (messageId === null) {
              this.log("No messageId left");
              return false;
            }
            const packet = {
              cmd: "unsubscribe",
              messageId,
              unsubscriptions: []
            };
            if (typeof topic === "string") {
              packet.unsubscriptions = [topic];
            } else if (Array.isArray(topic)) {
              packet.unsubscriptions = topic;
            }
            if (this.options.resubscribe) {
              packet.unsubscriptions.forEach((topic2) => {
                delete this._resubscribeTopics[topic2];
              });
            }
            if (typeof opts === "object" && opts.properties) {
              packet.properties = opts.properties;
            }
            this.outgoing[packet.messageId] = {
              volatile: true,
              cb: callback
            };
            this.log("unsubscribe: call _sendPacket");
            this._sendPacket(packet);
            return true;
          };
          if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {
            this._storeProcessingQueue.push({
              invoke: unsubscribeProc,
              callback
            });
          }
          return this;
        }
        unsubscribeAsync(topic, opts) {
          return new Promise((resolve2, reject) => {
            this.unsubscribe(topic, opts, (err, packet) => {
              if (err) {
                reject(err);
              } else {
                resolve2(packet);
              }
            });
          });
        }
        end(force, opts, cb) {
          this.log("end :: (%s)", this.options.clientId);
          if (force == null || typeof force !== "boolean") {
            cb = cb || opts;
            opts = force;
            force = false;
          }
          if (typeof opts !== "object") {
            cb = cb || opts;
            opts = null;
          }
          this.log("end :: cb? %s", !!cb);
          if (!cb || typeof cb !== "function") {
            cb = this.noop;
          }
          const closeStores = () => {
            this.log("end :: closeStores: closing incoming and outgoing stores");
            this.disconnected = true;
            this.incomingStore.close((e1) => {
              this.outgoingStore.close((e22) => {
                this.log("end :: closeStores: emitting end");
                this.emit("end");
                if (cb) {
                  const err = e1 || e22;
                  this.log("end :: closeStores: invoking callback with args");
                  cb(err);
                }
              });
            });
            if (this._deferredReconnect) {
              this._deferredReconnect();
            }
          };
          const finish = () => {
            this.log("end :: (%s) :: finish :: calling _cleanUp with force %s", this.options.clientId, force);
            this._cleanUp(force, () => {
              this.log("end :: finish :: calling process.nextTick on closeStores");
              (0, shared_1.nextTick)(closeStores);
            }, opts);
          };
          if (this.disconnecting) {
            cb();
            return this;
          }
          this._clearReconnect();
          this.disconnecting = true;
          if (!force && Object.keys(this.outgoing).length > 0) {
            this.log("end :: (%s) :: calling finish in 10ms once outgoing is empty", this.options.clientId);
            this.once("outgoingEmpty", setTimeout.bind(null, finish, 10));
          } else {
            this.log("end :: (%s) :: immediately calling finish", this.options.clientId);
            finish();
          }
          return this;
        }
        endAsync(force, opts) {
          return new Promise((resolve2, reject) => {
            this.end(force, opts, (err) => {
              if (err) {
                reject(err);
              } else {
                resolve2();
              }
            });
          });
        }
        removeOutgoingMessage(messageId) {
          if (this.outgoing[messageId]) {
            const { cb } = this.outgoing[messageId];
            this._removeOutgoingAndStoreMessage(messageId, () => {
              cb(new Error("Message removed"));
            });
          }
          return this;
        }
        reconnect(opts) {
          this.log("client reconnect");
          const f6 = () => {
            if (opts) {
              this.options.incomingStore = opts.incomingStore;
              this.options.outgoingStore = opts.outgoingStore;
            } else {
              this.options.incomingStore = null;
              this.options.outgoingStore = null;
            }
            this.incomingStore = this.options.incomingStore || new store_1.default();
            this.outgoingStore = this.options.outgoingStore || new store_1.default();
            this.disconnecting = false;
            this.disconnected = false;
            this._deferredReconnect = null;
            this._reconnect();
          };
          if (this.disconnecting && !this.disconnected) {
            this._deferredReconnect = f6;
          } else {
            f6();
          }
          return this;
        }
        _flushVolatile() {
          if (this.outgoing) {
            this.log("_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function");
            Object.keys(this.outgoing).forEach((messageId) => {
              if (this.outgoing[messageId].volatile && typeof this.outgoing[messageId].cb === "function") {
                this.outgoing[messageId].cb(new Error("Connection closed"));
                delete this.outgoing[messageId];
              }
            });
          }
        }
        _flush() {
          if (this.outgoing) {
            this.log("_flush: queue exists? %b", !!this.outgoing);
            Object.keys(this.outgoing).forEach((messageId) => {
              if (typeof this.outgoing[messageId].cb === "function") {
                this.outgoing[messageId].cb(new Error("Connection closed"));
                delete this.outgoing[messageId];
              }
            });
          }
        }
        _removeTopicAliasAndRecoverTopicName(packet) {
          let alias;
          if (packet.properties) {
            alias = packet.properties.topicAlias;
          }
          let topic = packet.topic.toString();
          this.log("_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o", alias, topic);
          if (topic.length === 0) {
            if (typeof alias === "undefined") {
              return new Error("Unregistered Topic Alias");
            }
            topic = this.topicAliasSend.getTopicByAlias(alias);
            if (typeof topic === "undefined") {
              return new Error("Unregistered Topic Alias");
            }
            packet.topic = topic;
          }
          if (alias) {
            delete packet.properties.topicAlias;
          }
        }
        _checkDisconnecting(callback) {
          if (this.disconnecting) {
            if (callback && callback !== this.noop) {
              callback(new Error("client disconnecting"));
            } else {
              this.emit("error", new Error("client disconnecting"));
            }
          }
          return this.disconnecting;
        }
        _reconnect() {
          this.log("_reconnect: emitting reconnect to client");
          this.emit("reconnect");
          if (this.connected) {
            this.end(() => {
              this.connect();
            });
            this.log("client already connected. disconnecting first.");
          } else {
            this.log("_reconnect: calling connect");
            this.connect();
          }
        }
        _setupReconnect() {
          if (!this.disconnecting && !this.reconnectTimer && this.options.reconnectPeriod > 0) {
            if (!this.reconnecting) {
              this.log("_setupReconnect :: emit `offline` state");
              this.emit("offline");
              this.log("_setupReconnect :: set `reconnecting` to `true`");
              this.reconnecting = true;
            }
            this.log("_setupReconnect :: setting reconnectTimer for %d ms", this.options.reconnectPeriod);
            this.reconnectTimer = setInterval(() => {
              this.log("reconnectTimer :: reconnect triggered!");
              this._reconnect();
            }, this.options.reconnectPeriod);
          } else {
            this.log("_setupReconnect :: doing nothing...");
          }
        }
        _clearReconnect() {
          this.log("_clearReconnect : clearing reconnect timer");
          if (this.reconnectTimer) {
            clearInterval(this.reconnectTimer);
            this.reconnectTimer = null;
          }
        }
        _cleanUp(forced, done, opts = {}) {
          if (done) {
            this.log("_cleanUp :: done callback provided for on stream close");
            this.stream.on("close", done);
          }
          this.log("_cleanUp :: forced? %s", forced);
          if (forced) {
            if (this.options.reconnectPeriod === 0 && this.options.clean) {
              this._flush();
            }
            this.log("_cleanUp :: (%s) :: destroying stream", this.options.clientId);
            this.stream.destroy();
          } else {
            const packet = Object.assign({ cmd: "disconnect" }, opts);
            this.log("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId);
            this._sendPacket(packet, () => {
              this.log("_cleanUp :: (%s) :: destroying stream", this.options.clientId);
              setImmediate2(() => {
                this.stream.end(() => {
                  this.log("_cleanUp :: (%s) :: stream destroyed", this.options.clientId);
                });
              });
            });
          }
          if (!this.disconnecting && !this.reconnecting) {
            this.log("_cleanUp :: client not disconnecting/reconnecting. Clearing and resetting reconnect.");
            this._clearReconnect();
            this._setupReconnect();
          }
          if (this.pingTimer) {
            this.log("_cleanUp :: destroy pingTimer");
            this.pingTimer.destroy();
            this.pingTimer = null;
          }
          if (done && !this.connected) {
            this.log("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId);
            this.stream.removeListener("close", done);
            done();
          }
        }
        _storeAndSend(packet, cb, cbStorePut) {
          this.log("storeAndSend :: store packet with cmd %s to outgoingStore", packet.cmd);
          let storePacket = packet;
          let err;
          if (storePacket.cmd === "publish") {
            storePacket = (0, default_1.default)(packet);
            err = this._removeTopicAliasAndRecoverTopicName(storePacket);
            if (err) {
              return cb && cb(err);
            }
          }
          this.outgoingStore.put(storePacket, (err2) => {
            if (err2) {
              return cb && cb(err2);
            }
            cbStorePut();
            this._writePacket(packet, cb);
          });
        }
        _applyTopicAlias(packet) {
          if (this.options.protocolVersion === 5) {
            if (packet.cmd === "publish") {
              let alias;
              if (packet.properties) {
                alias = packet.properties.topicAlias;
              }
              const topic = packet.topic.toString();
              if (this.topicAliasSend) {
                if (alias) {
                  if (topic.length !== 0) {
                    this.log("applyTopicAlias :: register topic: %s - alias: %d", topic, alias);
                    if (!this.topicAliasSend.put(topic, alias)) {
                      this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d", topic, alias);
                      return new Error("Sending Topic Alias out of range");
                    }
                  }
                } else if (topic.length !== 0) {
                  if (this.options.autoAssignTopicAlias) {
                    alias = this.topicAliasSend.getAliasByTopic(topic);
                    if (alias) {
                      packet.topic = "";
                      packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                      this.log("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", topic, alias);
                    } else {
                      alias = this.topicAliasSend.getLruAlias();
                      this.topicAliasSend.put(topic, alias);
                      packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                      this.log("applyTopicAlias :: auto assign topic: %s - alias: %d", topic, alias);
                    }
                  } else if (this.options.autoUseTopicAlias) {
                    alias = this.topicAliasSend.getAliasByTopic(topic);
                    if (alias) {
                      packet.topic = "";
                      packet.properties = Object.assign(Object.assign({}, packet.properties), { topicAlias: alias });
                      this.log("applyTopicAlias :: auto use topic: %s - alias: %d", topic, alias);
                    }
                  }
                }
              } else if (alias) {
                this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d", topic, alias);
                return new Error("Sending Topic Alias out of range");
              }
            }
          }
        }
        _noop(err) {
          this.log("noop ::", err);
        }
        _writePacket(packet, cb) {
          this.log("_writePacket :: packet: %O", packet);
          this.log("_writePacket :: emitting `packetsend`");
          this.emit("packetsend", packet);
          this._shiftPingInterval();
          this.log("_writePacket :: writing to stream");
          const result = mqtt_packet_1.default.writeToStream(packet, this.stream, this.options);
          this.log("_writePacket :: writeToStream result %s", result);
          if (!result && cb && cb !== this.noop) {
            this.log("_writePacket :: handle events on `drain` once through callback.");
            this.stream.once("drain", cb);
          } else if (cb) {
            this.log("_writePacket :: invoking cb");
            cb();
          }
        }
        _sendPacket(packet, cb, cbStorePut, noStore) {
          this.log("_sendPacket :: (%s) ::  start", this.options.clientId);
          cbStorePut = cbStorePut || this.noop;
          cb = cb || this.noop;
          const err = this._applyTopicAlias(packet);
          if (err) {
            cb(err);
            return;
          }
          if (!this.connected) {
            if (packet.cmd === "auth") {
              this._writePacket(packet, cb);
              return;
            }
            this.log("_sendPacket :: client not connected. Storing packet offline.");
            this._storePacket(packet, cb, cbStorePut);
            return;
          }
          if (noStore) {
            this._writePacket(packet, cb);
            return;
          }
          switch (packet.cmd) {
            case "publish":
              break;
            case "pubrel":
              this._storeAndSend(packet, cb, cbStorePut);
              return;
            default:
              this._writePacket(packet, cb);
              return;
          }
          switch (packet.qos) {
            case 2:
            case 1:
              this._storeAndSend(packet, cb, cbStorePut);
              break;
            case 0:
            default:
              this._writePacket(packet, cb);
              break;
          }
          this.log("_sendPacket :: (%s) ::  end", this.options.clientId);
        }
        _storePacket(packet, cb, cbStorePut) {
          this.log("_storePacket :: packet: %o", packet);
          this.log("_storePacket :: cb? %s", !!cb);
          cbStorePut = cbStorePut || this.noop;
          let storePacket = packet;
          if (storePacket.cmd === "publish") {
            storePacket = (0, default_1.default)(packet);
            const err = this._removeTopicAliasAndRecoverTopicName(storePacket);
            if (err) {
              return cb && cb(err);
            }
          }
          const qos = storePacket.qos || 0;
          if (qos === 0 && this.queueQoSZero || storePacket.cmd !== "publish") {
            this.queue.push({ packet: storePacket, cb });
          } else if (qos > 0) {
            cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null;
            this.outgoingStore.put(storePacket, (err) => {
              if (err) {
                return cb && cb(err);
              }
              cbStorePut();
            });
          } else if (cb) {
            cb(new Error("No connection to broker"));
          }
        }
        _setupPingTimer() {
          this.log("_setupPingTimer :: keepalive %d (seconds)", this.options.keepalive);
          if (!this.pingTimer && this.options.keepalive) {
            this.pingResp = true;
            this.pingTimer = new PingTimer_1.default(this.options.keepalive, () => {
              this._checkPing();
            }, this.options.timerVariant);
          }
        }
        _shiftPingInterval() {
          if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {
            this.pingTimer.reschedule();
          }
        }
        _checkPing() {
          this.log("_checkPing :: checking ping...");
          if (this.pingResp) {
            this.log("_checkPing :: ping response received. Clearing flag and sending `pingreq`");
            this.pingResp = false;
            this._sendPacket({ cmd: "pingreq" });
          } else {
            this.emit("error", new Error("Keepalive timeout"));
            this.log("_checkPing :: calling _cleanUp with force true");
            this._cleanUp(true);
          }
        }
        _resubscribe() {
          this.log("_resubscribe");
          const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);
          if (!this._firstConnection && (this.options.clean || this.options.protocolVersion >= 4 && !this.connackPacket.sessionPresent) && _resubscribeTopicsKeys.length > 0) {
            if (this.options.resubscribe) {
              if (this.options.protocolVersion === 5) {
                this.log("_resubscribe: protocolVersion 5");
                for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {
                  const resubscribeTopic = {};
                  resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];
                  resubscribeTopic.resubscribe = true;
                  this.subscribe(resubscribeTopic, {
                    properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties
                  });
                }
              } else {
                this._resubscribeTopics.resubscribe = true;
                this.subscribe(this._resubscribeTopics);
              }
            } else {
              this._resubscribeTopics = {};
            }
          }
          this._firstConnection = false;
        }
        _onConnect(packet) {
          if (this.disconnected) {
            this.emit("connect", packet);
            return;
          }
          this.connackPacket = packet;
          this.messageIdProvider.clear();
          this._setupPingTimer();
          this.connected = true;
          const startStreamProcess = () => {
            let outStore = this.outgoingStore.createStream();
            const remove = () => {
              outStore.destroy();
              outStore = null;
              this._flushStoreProcessingQueue();
              clearStoreProcessing();
            };
            const clearStoreProcessing = () => {
              this._storeProcessing = false;
              this._packetIdsDuringStoreProcessing = {};
            };
            this.once("close", remove);
            outStore.on("error", (err) => {
              clearStoreProcessing();
              this._flushStoreProcessingQueue();
              this.removeListener("close", remove);
              this.emit("error", err);
            });
            const storeDeliver = () => {
              if (!outStore) {
                return;
              }
              const packet2 = outStore.read(1);
              let cb;
              if (!packet2) {
                outStore.once("readable", storeDeliver);
                return;
              }
              this._storeProcessing = true;
              if (this._packetIdsDuringStoreProcessing[packet2.messageId]) {
                storeDeliver();
                return;
              }
              if (!this.disconnecting && !this.reconnectTimer) {
                cb = this.outgoing[packet2.messageId] ? this.outgoing[packet2.messageId].cb : null;
                this.outgoing[packet2.messageId] = {
                  volatile: false,
                  cb(err, status) {
                    if (cb) {
                      cb(err, status);
                    }
                    storeDeliver();
                  }
                };
                this._packetIdsDuringStoreProcessing[packet2.messageId] = true;
                if (this.messageIdProvider.register(packet2.messageId)) {
                  this._sendPacket(packet2, void 0, void 0, true);
                } else {
                  this.log("messageId: %d has already used.", packet2.messageId);
                }
              } else if (outStore.destroy) {
                outStore.destroy();
              }
            };
            outStore.on("end", () => {
              let allProcessed = true;
              for (const id in this._packetIdsDuringStoreProcessing) {
                if (!this._packetIdsDuringStoreProcessing[id]) {
                  allProcessed = false;
                  break;
                }
              }
              this.removeListener("close", remove);
              if (allProcessed) {
                clearStoreProcessing();
                this._invokeAllStoreProcessingQueue();
                this.emit("connect", packet);
              } else {
                startStreamProcess();
              }
            });
            storeDeliver();
          };
          startStreamProcess();
        }
        _invokeStoreProcessingQueue() {
          if (!this._storeProcessing && this._storeProcessingQueue.length > 0) {
            const f6 = this._storeProcessingQueue[0];
            if (f6 && f6.invoke()) {
              this._storeProcessingQueue.shift();
              return true;
            }
          }
          return false;
        }
        _invokeAllStoreProcessingQueue() {
          while (this._invokeStoreProcessingQueue()) {
          }
        }
        _flushStoreProcessingQueue() {
          for (const f6 of this._storeProcessingQueue) {
            if (f6.cbStorePut)
              f6.cbStorePut(new Error("Connection closed"));
            if (f6.callback)
              f6.callback(new Error("Connection closed"));
          }
          this._storeProcessingQueue.splice(0);
        }
        _removeOutgoingAndStoreMessage(messageId, cb) {
          delete this.outgoing[messageId];
          this.outgoingStore.del({ messageId }, (err, packet) => {
            cb(err, packet);
            this.messageIdProvider.deallocate(messageId);
            this._invokeStoreProcessingQueue();
          });
        }
      };
      MqttClient.VERSION = shared_1.MQTTJS_VERSION;
      exports5.default = MqttClient;
    }
  });

  // build/lib/unique-message-id-provider.js
  var require_unique_message_id_provider = __commonJS({
    "build/lib/unique-message-id-provider.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      var number_allocator_1 = require_number_allocator2();
      var UniqueMessageIdProvider = class {
        constructor() {
          this.numberAllocator = new number_allocator_1.NumberAllocator(1, 65535);
        }
        allocate() {
          this.lastId = this.numberAllocator.alloc();
          return this.lastId;
        }
        getLastAllocated() {
          return this.lastId;
        }
        register(messageId) {
          return this.numberAllocator.use(messageId);
        }
        deallocate(messageId) {
          this.numberAllocator.free(messageId);
        }
        clear() {
          this.numberAllocator.clear();
        }
      };
      exports5.default = UniqueMessageIdProvider;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js
  function i3(t6) {
    throw new RangeError(r3[t6]);
  }
  function f3(t6, o7) {
    const n7 = t6.split("@");
    let r7 = "";
    n7.length > 1 && (r7 = n7[0] + "@", t6 = n7[1]);
    const c6 = function(t7, o8) {
      const n8 = [];
      let e7 = t7.length;
      for (; e7--; )
        n8[e7] = o8(t7[e7]);
      return n8;
    }((t6 = t6.replace(e3, ".")).split("."), o7).join(".");
    return r7 + c6;
  }
  function l3(t6) {
    const o7 = [];
    let n7 = 0;
    const e7 = t6.length;
    for (; n7 < e7; ) {
      const r7 = t6.charCodeAt(n7++);
      if (r7 >= 55296 && r7 <= 56319 && n7 < e7) {
        const e8 = t6.charCodeAt(n7++);
        56320 == (64512 & e8) ? o7.push(((1023 & r7) << 10) + (1023 & e8) + 65536) : (o7.push(r7), n7--);
      } else
        o7.push(r7);
    }
    return o7;
  }
  var t3, o3, n3, e3, r3, c3, s3, u3, a3, d2, h3, p3;
  var init_chunk_924bb2e1 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      t3 = 2147483647;
      o3 = /^xn--/;
      n3 = /[^\0-\x7E]/;
      e3 = /[\x2E\u3002\uFF0E\uFF61]/g;
      r3 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
      c3 = Math.floor;
      s3 = String.fromCharCode;
      u3 = function(t6, o7) {
        return t6 + 22 + 75 * (t6 < 26) - ((0 != o7) << 5);
      };
      a3 = function(t6, o7, n7) {
        let e7 = 0;
        for (t6 = n7 ? c3(t6 / 700) : t6 >> 1, t6 += c3(t6 / o7); t6 > 455; e7 += 36)
          t6 = c3(t6 / 35);
        return c3(e7 + 36 * t6 / (t6 + 38));
      };
      d2 = function(o7) {
        const n7 = [], e7 = o7.length;
        let r7 = 0, s5 = 128, f6 = 72, l6 = o7.lastIndexOf("-");
        l6 < 0 && (l6 = 0);
        for (let t6 = 0; t6 < l6; ++t6)
          o7.charCodeAt(t6) >= 128 && i3("not-basic"), n7.push(o7.charCodeAt(t6));
        for (let d4 = l6 > 0 ? l6 + 1 : 0; d4 < e7; ) {
          let l7 = r7;
          for (let n8 = 1, s6 = 36; ; s6 += 36) {
            d4 >= e7 && i3("invalid-input");
            const l8 = (u6 = o7.charCodeAt(d4++)) - 48 < 10 ? u6 - 22 : u6 - 65 < 26 ? u6 - 65 : u6 - 97 < 26 ? u6 - 97 : 36;
            (l8 >= 36 || l8 > c3((t3 - r7) / n8)) && i3("overflow"), r7 += l8 * n8;
            const a6 = s6 <= f6 ? 1 : s6 >= f6 + 26 ? 26 : s6 - f6;
            if (l8 < a6)
              break;
            const h7 = 36 - a6;
            n8 > c3(t3 / h7) && i3("overflow"), n8 *= h7;
          }
          const h6 = n7.length + 1;
          f6 = a3(r7 - l7, h6, 0 == l7), c3(r7 / h6) > t3 - s5 && i3("overflow"), s5 += c3(r7 / h6), r7 %= h6, n7.splice(r7++, 0, s5);
        }
        var u6;
        return String.fromCodePoint(...n7);
      };
      h3 = function(o7) {
        const n7 = [];
        let e7 = (o7 = l3(o7)).length, r7 = 128, f6 = 0, d4 = 72;
        for (const t6 of o7)
          t6 < 128 && n7.push(s3(t6));
        let h6 = n7.length, p6 = h6;
        for (h6 && n7.push("-"); p6 < e7; ) {
          let e8 = t3;
          for (const t6 of o7)
            t6 >= r7 && t6 < e8 && (e8 = t6);
          const l6 = p6 + 1;
          e8 - r7 > c3((t3 - f6) / l6) && i3("overflow"), f6 += (e8 - r7) * l6, r7 = e8;
          for (const e9 of o7)
            if (e9 < r7 && ++f6 > t3 && i3("overflow"), e9 == r7) {
              let t6 = f6;
              for (let o8 = 36; ; o8 += 36) {
                const e10 = o8 <= d4 ? 1 : o8 >= d4 + 26 ? 26 : o8 - d4;
                if (t6 < e10)
                  break;
                const r8 = t6 - e10, i6 = 36 - e10;
                n7.push(s3(u3(e10 + r8 % i6, 0))), t6 = c3(r8 / i6);
              }
              n7.push(s3(u3(t6, 0))), d4 = a3(f6, l6, p6 == h6), f6 = 0, ++p6;
            }
          ++f6, ++r7;
        }
        return n7.join("");
      };
      p3 = { version: "2.1.0", ucs2: { decode: l3, encode: (t6) => String.fromCodePoint(...t6) }, decode: d2, encode: h3, toASCII: function(t6) {
        return f3(t6, function(t7) {
          return n3.test(t7) ? "xn--" + h3(t7) : t7;
        });
      }, toUnicode: function(t6) {
        return f3(t6, function(t7) {
          return o3.test(t7) ? d2(t7.slice(4).toLowerCase()) : t7;
        });
      } };
      p3.decode;
      p3.encode;
      p3.toASCII;
      p3.toUnicode;
      p3.ucs2;
      p3.version;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js
  function e4(e7, n7) {
    return Object.prototype.hasOwnProperty.call(e7, n7);
  }
  var n4, r4, t4, o4;
  var init_chunk_b04e620d = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      n4 = function(n7, r7, t6, o7) {
        r7 = r7 || "&", t6 = t6 || "=";
        var a6 = {};
        if ("string" != typeof n7 || 0 === n7.length)
          return a6;
        var u6 = /\+/g;
        n7 = n7.split(r7);
        var c6 = 1e3;
        o7 && "number" == typeof o7.maxKeys && (c6 = o7.maxKeys);
        var i6 = n7.length;
        c6 > 0 && i6 > c6 && (i6 = c6);
        for (var s5 = 0; s5 < i6; ++s5) {
          var p6, f6, d4, y4, m4 = n7[s5].replace(u6, "%20"), l6 = m4.indexOf(t6);
          l6 >= 0 ? (p6 = m4.substr(0, l6), f6 = m4.substr(l6 + 1)) : (p6 = m4, f6 = ""), d4 = decodeURIComponent(p6), y4 = decodeURIComponent(f6), e4(a6, d4) ? Array.isArray(a6[d4]) ? a6[d4].push(y4) : a6[d4] = [a6[d4], y4] : a6[d4] = y4;
        }
        return a6;
      };
      r4 = function(e7) {
        switch (typeof e7) {
          case "string":
            return e7;
          case "boolean":
            return e7 ? "true" : "false";
          case "number":
            return isFinite(e7) ? e7 : "";
          default:
            return "";
        }
      };
      t4 = function(e7, n7, t6, o7) {
        return n7 = n7 || "&", t6 = t6 || "=", null === e7 && (e7 = void 0), "object" == typeof e7 ? Object.keys(e7).map(function(o8) {
          var a6 = encodeURIComponent(r4(o8)) + t6;
          return Array.isArray(e7[o8]) ? e7[o8].map(function(e8) {
            return a6 + encodeURIComponent(r4(e8));
          }).join(n7) : a6 + encodeURIComponent(r4(e7[o8]));
        }).join(n7) : o7 ? encodeURIComponent(r4(o7)) + t6 + encodeURIComponent(r4(e7)) : "";
      };
      o4 = {};
      o4.decode = o4.parse = n4, o4.encode = o4.stringify = t4;
      o4.decode;
      o4.encode;
      o4.parse;
      o4.stringify;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js
  function i4() {
    throw new Error("setTimeout has not been defined");
  }
  function u4() {
    throw new Error("clearTimeout has not been defined");
  }
  function c4(e7) {
    if (t5 === setTimeout)
      return setTimeout(e7, 0);
    if ((t5 === i4 || !t5) && setTimeout)
      return t5 = setTimeout, setTimeout(e7, 0);
    try {
      return t5(e7, 0);
    } catch (n7) {
      try {
        return t5.call(null, e7, 0);
      } catch (n8) {
        return t5.call(this || r5, e7, 0);
      }
    }
  }
  function h4() {
    f4 && l4 && (f4 = false, l4.length ? s4 = l4.concat(s4) : a4 = -1, s4.length && d3());
  }
  function d3() {
    if (!f4) {
      var e7 = c4(h4);
      f4 = true;
      for (var t6 = s4.length; t6; ) {
        for (l4 = s4, s4 = []; ++a4 < t6; )
          l4 && l4[a4].run();
        a4 = -1, t6 = s4.length;
      }
      l4 = null, f4 = false, function(e8) {
        if (n5 === clearTimeout)
          return clearTimeout(e8);
        if ((n5 === u4 || !n5) && clearTimeout)
          return n5 = clearTimeout, clearTimeout(e8);
        try {
          n5(e8);
        } catch (t7) {
          try {
            return n5.call(null, e8);
          } catch (t8) {
            return n5.call(this || r5, e8);
          }
        }
      }(e7);
    }
  }
  function m2(e7, t6) {
    (this || r5).fun = e7, (this || r5).array = t6;
  }
  function p4() {
  }
  var e5, t5, n5, r5, o5, l4, s4, f4, a4, T2;
  var init_chunk_5decc758 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      r5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
      o5 = e5 = {};
      !function() {
        try {
          t5 = "function" == typeof setTimeout ? setTimeout : i4;
        } catch (e7) {
          t5 = i4;
        }
        try {
          n5 = "function" == typeof clearTimeout ? clearTimeout : u4;
        } catch (e7) {
          n5 = u4;
        }
      }();
      s4 = [];
      f4 = false;
      a4 = -1;
      o5.nextTick = function(e7) {
        var t6 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n7 = 1; n7 < arguments.length; n7++)
            t6[n7 - 1] = arguments[n7];
        s4.push(new m2(e7, t6)), 1 !== s4.length || f4 || c4(d3);
      }, m2.prototype.run = function() {
        (this || r5).fun.apply(null, (this || r5).array);
      }, o5.title = "browser", o5.browser = true, o5.env = {}, o5.argv = [], o5.version = "", o5.versions = {}, o5.on = p4, o5.addListener = p4, o5.once = p4, o5.off = p4, o5.removeListener = p4, o5.removeAllListeners = p4, o5.emit = p4, o5.prependListener = p4, o5.prependOnceListener = p4, o5.listeners = function(e7) {
        return [];
      }, o5.binding = function(e7) {
        throw new Error("process.binding is not supported");
      }, o5.cwd = function() {
        return "/";
      }, o5.chdir = function(e7) {
        throw new Error("process.chdir is not supported");
      }, o5.umask = function() {
        return 0;
      };
      T2 = e5;
      T2.addListener;
      T2.argv;
      T2.binding;
      T2.browser;
      T2.chdir;
      T2.cwd;
      T2.emit;
      T2.env;
      T2.listeners;
      T2.nextTick;
      T2.off;
      T2.on;
      T2.once;
      T2.prependListener;
      T2.prependOnceListener;
      T2.removeAllListeners;
      T2.removeListener;
      T2.title;
      T2.umask;
      T2.version;
      T2.versions;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js
  function dew2() {
    if (_dewExec2)
      return exports2;
    _dewExec2 = true;
    var process3 = exports2 = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e7) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e7) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e7) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e8) {
          return cachedSetTimeout.call(this || _global, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e7) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e8) {
          return cachedClearTimeout.call(this || _global, marker);
        }
      }
    }
    var queue2 = [];
    var draining2 = false;
    var currentQueue2;
    var queueIndex2 = -1;
    function cleanUpNextTick2() {
      if (!draining2 || !currentQueue2) {
        return;
      }
      draining2 = false;
      if (currentQueue2.length) {
        queue2 = currentQueue2.concat(queue2);
      } else {
        queueIndex2 = -1;
      }
      if (queue2.length) {
        drainQueue2();
      }
    }
    function drainQueue2() {
      if (draining2) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick2);
      draining2 = true;
      var len = queue2.length;
      while (len) {
        currentQueue2 = queue2;
        queue2 = [];
        while (++queueIndex2 < len) {
          if (currentQueue2) {
            currentQueue2[queueIndex2].run();
          }
        }
        queueIndex2 = -1;
        len = queue2.length;
      }
      currentQueue2 = null;
      draining2 = false;
      runClearTimeout(timeout);
    }
    process3.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i6 = 1; i6 < arguments.length; i6++) {
          args[i6 - 1] = arguments[i6];
        }
      }
      queue2.push(new Item2(fun, args));
      if (queue2.length === 1 && !draining2) {
        runTimeout(drainQueue2);
      }
    };
    function Item2(fun, array) {
      (this || _global).fun = fun;
      (this || _global).array = array;
    }
    Item2.prototype.run = function() {
      (this || _global).fun.apply(null, (this || _global).array);
    };
    process3.title = "browser";
    process3.browser = true;
    process3.env = {};
    process3.argv = [];
    process3.version = "";
    process3.versions = {};
    function noop2() {
    }
    process3.on = noop2;
    process3.addListener = noop2;
    process3.once = noop2;
    process3.off = noop2;
    process3.removeListener = noop2;
    process3.removeAllListeners = noop2;
    process3.emit = noop2;
    process3.prependListener = noop2;
    process3.prependOnceListener = noop2;
    process3.listeners = function(name2) {
      return [];
    };
    process3.binding = function(name2) {
      throw new Error("process.binding is not supported");
    };
    process3.cwd = function() {
      return "/";
    };
    process3.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process3.umask = function() {
      return 0;
    };
    return exports2;
  }
  var exports2, _dewExec2, _global, process2;
  var init_chunk_2eac56ff = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      exports2 = {};
      _dewExec2 = false;
      _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      process2 = dew2();
      process2.platform = "browser";
      process2.addListener;
      process2.argv;
      process2.binding;
      process2.browser;
      process2.chdir;
      process2.cwd;
      process2.emit;
      process2.env;
      process2.listeners;
      process2.nextTick;
      process2.off;
      process2.on;
      process2.once;
      process2.prependListener;
      process2.prependOnceListener;
      process2.removeAllListeners;
      process2.removeListener;
      process2.title;
      process2.umask;
      process2.version;
      process2.versions;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js
  function dew3() {
    if (_dewExec3)
      return exports$12;
    _dewExec3 = true;
    var process$1 = process2;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i6 = 0; i6 <= path2.length; ++i6) {
        if (i6 < path2.length)
          code = path2.charCodeAt(i6);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i6 - 1 || dots === 1)
            ;
          else if (lastSlash !== i6 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i6;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i6;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path2.slice(lastSlash + 1, i6);
            else
              res = path2.slice(lastSlash + 1, i6);
            lastSegmentLength = i6 - lastSlash - 1;
          }
          lastSlash = i6;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve2() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd2;
        for (var i6 = arguments.length - 1; i6 >= -1 && !resolvedAbsolute; i6--) {
          var path2;
          if (i6 >= 0)
            path2 = arguments[i6];
          else {
            if (cwd2 === void 0)
              cwd2 = process$1.cwd();
            path2 = cwd2;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var isAbsolute = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute);
        if (path2.length === 0 && !isAbsolute)
          path2 = ".";
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute)
          return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i6 = 0; i6 < arguments.length; ++i6) {
          var arg = arguments[i6];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i6 = 0;
        for (; i6 <= length; ++i6) {
          if (i6 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i6) === 47) {
                return to.slice(toStart + i6 + 1);
              } else if (i6 === 0) {
                return to.slice(toStart + i6);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i6) === 47) {
                lastCommonSep = i6;
              } else if (i6 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i6);
          var toCode = to.charCodeAt(toStart + i6);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i6;
        }
        var out = "";
        for (i6 = fromStart + lastCommonSep + 1; i6 <= fromEnd; ++i6) {
          if (i6 === fromEnd || from.charCodeAt(i6) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path2) {
        return path2;
      },
      dirname: function dirname(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var code = path2.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i6 = path2.length - 1; i6 >= 1; --i6) {
          code = path2.charCodeAt(i6);
          if (code === 47) {
            if (!matchedSlash) {
              end = i6;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path2.slice(0, end);
      },
      basename: function basename(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i6;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i6 = path2.length - 1; i6 >= 0; --i6) {
            var code = path2.charCodeAt(i6);
            if (code === 47) {
              if (!matchedSlash) {
                start = i6 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i6 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i6;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i6 = path2.length - 1; i6 >= 0; --i6) {
            if (path2.charCodeAt(i6) === 47) {
              if (!matchedSlash) {
                start = i6 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i6 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i6 = path2.length - 1; i6 >= 0; --i6) {
          var code = path2.charCodeAt(i6);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i6 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i6 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i6;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format2(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse2(path2) {
        assertPath(path2);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path2.length === 0)
          return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i6 = path2.length - 1;
        var preDotState = 0;
        for (; i6 >= start; --i6) {
          code = path2.charCodeAt(i6);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i6 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i6 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i6;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    exports$12 = posix;
    return exports$12;
  }
  var exports$12, _dewExec3, exports3;
  var init_chunk_23dbec7b = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      init_chunk_2eac56ff();
      exports$12 = {};
      _dewExec3 = false;
      exports3 = dew3();
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/url.js
  var url_exports = {};
  __export(url_exports, {
    URL: () => _URL,
    Url: () => Url,
    default: () => h5,
    fileURLToPath: () => fileURLToPath,
    format: () => format,
    parse: () => parse,
    pathToFileURL: () => pathToFileURL,
    resolve: () => resolve,
    resolveObject: () => resolveObject
  });
  function r6() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  function O2(t6, s5, h6) {
    if (t6 && a5.isObject(t6) && t6 instanceof r6)
      return t6;
    var e7 = new r6();
    return e7.parse(t6, s5, h6), e7;
  }
  function dew4() {
    if (_dewExec4)
      return exports4;
    _dewExec4 = true;
    var process3 = T2;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i6 = 0; i6 <= path2.length; ++i6) {
        if (i6 < path2.length)
          code = path2.charCodeAt(i6);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i6 - 1 || dots === 1)
            ;
          else if (lastSlash !== i6 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i6;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i6;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path2.slice(lastSlash + 1, i6);
            else
              res = path2.slice(lastSlash + 1, i6);
            lastSegmentLength = i6 - lastSlash - 1;
          }
          lastSlash = i6;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve2() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd2;
        for (var i6 = arguments.length - 1; i6 >= -1 && !resolvedAbsolute; i6--) {
          var path2;
          if (i6 >= 0)
            path2 = arguments[i6];
          else {
            if (cwd2 === void 0)
              cwd2 = process3.cwd();
            path2 = cwd2;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var isAbsolute = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute);
        if (path2.length === 0 && !isAbsolute)
          path2 = ".";
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute)
          return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i6 = 0; i6 < arguments.length; ++i6) {
          var arg = arguments[i6];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i6 = 0;
        for (; i6 <= length; ++i6) {
          if (i6 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i6) === 47) {
                return to.slice(toStart + i6 + 1);
              } else if (i6 === 0) {
                return to.slice(toStart + i6);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i6) === 47) {
                lastCommonSep = i6;
              } else if (i6 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i6);
          var toCode = to.charCodeAt(toStart + i6);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i6;
        }
        var out = "";
        for (i6 = fromStart + lastCommonSep + 1; i6 <= fromEnd; ++i6) {
          if (i6 === fromEnd || from.charCodeAt(i6) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path2) {
        return path2;
      },
      dirname: function dirname(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var code = path2.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i6 = path2.length - 1; i6 >= 1; --i6) {
          code = path2.charCodeAt(i6);
          if (code === 47) {
            if (!matchedSlash) {
              end = i6;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path2.slice(0, end);
      },
      basename: function basename(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i6;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i6 = path2.length - 1; i6 >= 0; --i6) {
            var code = path2.charCodeAt(i6);
            if (code === 47) {
              if (!matchedSlash) {
                start = i6 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i6 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i6;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i6 = path2.length - 1; i6 >= 0; --i6) {
            if (path2.charCodeAt(i6) === 47) {
              if (!matchedSlash) {
                start = i6 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i6 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i6 = path2.length - 1; i6 >= 0; --i6) {
          var code = path2.charCodeAt(i6);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i6 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i6 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i6;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format2(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse2(path2) {
        assertPath(path2);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path2.length === 0)
          return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i6 = path2.length - 1;
        var preDotState = 0;
        for (; i6 >= start; --i6) {
          code = path2.charCodeAt(i6);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i6 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i6 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i6;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    exports4 = posix;
    return exports4;
  }
  function fileURLToPath$1(path2) {
    if (typeof path2 === "string")
      path2 = new URL(path2);
    else if (!(path2 instanceof URL)) {
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    }
    if (path2.protocol !== "file:") {
      throw new Deno.errors.InvalidData("invalid url scheme");
    }
    return isWindows$1 ? getPathFromURLWin$1(path2) : getPathFromURLPosix$1(path2);
  }
  function getPathFromURLWin$1(url) {
    const hostname = url.hostname;
    let pathname = url.pathname;
    for (let n7 = 0; n7 < pathname.length; n7++) {
      if (pathname[n7] === "%") {
        const third = pathname.codePointAt(n7 + 2) || 32;
        if (pathname[n7 + 1] === "2" && third === 102 || // 2f 2F /
        pathname[n7 + 1] === "5" && third === 99) {
          throw new Deno.errors.InvalidData(
            "must not include encoded \\ or / characters"
          );
        }
      }
    }
    pathname = pathname.replace(forwardSlashRegEx$1, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname !== "") {
      return `\\\\${hostname}${pathname}`;
    } else {
      const letter = pathname.codePointAt(1) | 32;
      const sep = pathname[2];
      if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
      sep !== ":") {
        throw new Deno.errors.InvalidData("file url path must be absolute");
      }
      return pathname.slice(1);
    }
  }
  function getPathFromURLPosix$1(url) {
    if (url.hostname !== "") {
      throw new Deno.errors.InvalidData("invalid file url hostname");
    }
    const pathname = url.pathname;
    for (let n7 = 0; n7 < pathname.length; n7++) {
      if (pathname[n7] === "%") {
        const third = pathname.codePointAt(n7 + 2) || 32;
        if (pathname[n7 + 1] === "2" && third === 102) {
          throw new Deno.errors.InvalidData(
            "must not include encoded / characters"
          );
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFileURL$1(filepath) {
    let resolved = path.resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
      resolved += "/";
    }
    const outURL = new URL("file://");
    if (resolved.includes("%"))
      resolved = resolved.replace(percentRegEx$1, "%25");
    if (!isWindows$1 && resolved.includes("\\")) {
      resolved = resolved.replace(backslashRegEx$1, "%5C");
    }
    if (resolved.includes("\n"))
      resolved = resolved.replace(newlineRegEx$1, "%0A");
    if (resolved.includes("\r")) {
      resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
    }
    if (resolved.includes("	"))
      resolved = resolved.replace(tabRegEx$1, "%09");
    outURL.pathname = resolved;
    return outURL;
  }
  function fileURLToPath(path2) {
    if (typeof path2 === "string")
      path2 = new URL(path2);
    else if (!(path2 instanceof URL)) {
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    }
    if (path2.protocol !== "file:") {
      throw new Deno.errors.InvalidData("invalid url scheme");
    }
    return isWindows ? getPathFromURLWin(path2) : getPathFromURLPosix(path2);
  }
  function getPathFromURLWin(url) {
    const hostname = url.hostname;
    let pathname = url.pathname;
    for (let n7 = 0; n7 < pathname.length; n7++) {
      if (pathname[n7] === "%") {
        const third = pathname.codePointAt(n7 + 2) || 32;
        if (pathname[n7 + 1] === "2" && third === 102 || // 2f 2F /
        pathname[n7 + 1] === "5" && third === 99) {
          throw new Deno.errors.InvalidData(
            "must not include encoded \\ or / characters"
          );
        }
      }
    }
    pathname = pathname.replace(forwardSlashRegEx, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname !== "") {
      return `\\\\${hostname}${pathname}`;
    } else {
      const letter = pathname.codePointAt(1) | 32;
      const sep = pathname[2];
      if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
      sep !== ":") {
        throw new Deno.errors.InvalidData("file url path must be absolute");
      }
      return pathname.slice(1);
    }
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      throw new Deno.errors.InvalidData("invalid file url hostname");
    }
    const pathname = url.pathname;
    for (let n7 = 0; n7 < pathname.length; n7++) {
      if (pathname[n7] === "%") {
        const third = pathname.codePointAt(n7 + 2) || 32;
        if (pathname[n7 + 1] === "2" && third === 102) {
          throw new Deno.errors.InvalidData(
            "must not include encoded / characters"
          );
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFileURL(filepath) {
    let resolved = exports3.resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports3.sep) {
      resolved += "/";
    }
    const outURL = new URL("file://");
    if (resolved.includes("%"))
      resolved = resolved.replace(percentRegEx, "%25");
    if (!isWindows && resolved.includes("\\")) {
      resolved = resolved.replace(backslashRegEx, "%5C");
    }
    if (resolved.includes("\n"))
      resolved = resolved.replace(newlineRegEx, "%0A");
    if (resolved.includes("\r")) {
      resolved = resolved.replace(carriageReturnRegEx, "%0D");
    }
    if (resolved.includes("	"))
      resolved = resolved.replace(tabRegEx, "%09");
    outURL.pathname = resolved;
    return outURL;
  }
  var h5, e6, a5, o6, n6, i5, l5, p5, c5, u5, f5, m3, v3, g2, y3, b2, exports4, _dewExec4, path, processPlatform$1, CHAR_BACKWARD_SLASH$1, CHAR_FORWARD_SLASH$1, CHAR_LOWERCASE_A$1, CHAR_LOWERCASE_Z$1, isWindows$1, forwardSlashRegEx$1, percentRegEx$1, backslashRegEx$1, newlineRegEx$1, carriageReturnRegEx$1, tabRegEx$1, processPlatform, Url, format, resolve, resolveObject, parse, _URL, CHAR_BACKWARD_SLASH, CHAR_FORWARD_SLASH, CHAR_LOWERCASE_A, CHAR_LOWERCASE_Z, isWindows, forwardSlashRegEx, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx;
  var init_url = __esm({
    "node_modules/@jspm/core/nodelibs/browser/url.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      init_chunk_924bb2e1();
      init_chunk_b04e620d();
      init_chunk_5decc758();
      init_chunk_23dbec7b();
      init_chunk_2eac56ff();
      h5 = {};
      e6 = p3;
      a5 = { isString: function(t6) {
        return "string" == typeof t6;
      }, isObject: function(t6) {
        return "object" == typeof t6 && null !== t6;
      }, isNull: function(t6) {
        return null === t6;
      }, isNullOrUndefined: function(t6) {
        return null == t6;
      } };
      h5.parse = O2, h5.resolve = function(t6, s5) {
        return O2(t6, false, true).resolve(s5);
      }, h5.resolveObject = function(t6, s5) {
        return t6 ? O2(t6, false, true).resolveObject(s5) : s5;
      }, h5.format = function(t6) {
        a5.isString(t6) && (t6 = O2(t6));
        return t6 instanceof r6 ? t6.format() : r6.prototype.format.call(t6);
      }, h5.Url = r6;
      o6 = /^([a-z0-9.+-]+:)/i;
      n6 = /:[0-9]*$/;
      i5 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
      l5 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
      p5 = ["'"].concat(l5);
      c5 = ["%", "/", "?", ";", "#"].concat(p5);
      u5 = ["/", "?", "#"];
      f5 = /^[+a-z0-9A-Z_-]{0,63}$/;
      m3 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
      v3 = { javascript: true, "javascript:": true };
      g2 = { javascript: true, "javascript:": true };
      y3 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
      b2 = o4;
      r6.prototype.parse = function(t6, s5, h6) {
        if (!a5.isString(t6))
          throw new TypeError("Parameter 'url' must be a string, not " + typeof t6);
        var r7 = t6.indexOf("?"), n7 = -1 !== r7 && r7 < t6.indexOf("#") ? "?" : "#", l6 = t6.split(n7);
        l6[0] = l6[0].replace(/\\/g, "/");
        var O3 = t6 = l6.join(n7);
        if (O3 = O3.trim(), !h6 && 1 === t6.split("#").length) {
          var d4 = i5.exec(O3);
          if (d4)
            return this.path = O3, this.href = O3, this.pathname = d4[1], d4[2] ? (this.search = d4[2], this.query = s5 ? b2.parse(this.search.substr(1)) : this.search.substr(1)) : s5 && (this.search = "", this.query = {}), this;
        }
        var j2 = o6.exec(O3);
        if (j2) {
          var q = (j2 = j2[0]).toLowerCase();
          this.protocol = q, O3 = O3.substr(j2.length);
        }
        if (h6 || j2 || O3.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var x2 = "//" === O3.substr(0, 2);
          !x2 || j2 && g2[j2] || (O3 = O3.substr(2), this.slashes = true);
        }
        if (!g2[j2] && (x2 || j2 && !y3[j2])) {
          for (var A2, C2, I2 = -1, w2 = 0; w2 < u5.length; w2++) {
            -1 !== (N2 = O3.indexOf(u5[w2])) && (-1 === I2 || N2 < I2) && (I2 = N2);
          }
          -1 !== (C2 = -1 === I2 ? O3.lastIndexOf("@") : O3.lastIndexOf("@", I2)) && (A2 = O3.slice(0, C2), O3 = O3.slice(C2 + 1), this.auth = decodeURIComponent(A2)), I2 = -1;
          for (w2 = 0; w2 < c5.length; w2++) {
            var N2;
            -1 !== (N2 = O3.indexOf(c5[w2])) && (-1 === I2 || N2 < I2) && (I2 = N2);
          }
          -1 === I2 && (I2 = O3.length), this.host = O3.slice(0, I2), O3 = O3.slice(I2), this.parseHost(), this.hostname = this.hostname || "";
          var U2 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
          if (!U2)
            for (var k2 = this.hostname.split(/\./), S2 = (w2 = 0, k2.length); w2 < S2; w2++) {
              var R2 = k2[w2];
              if (R2 && !R2.match(f5)) {
                for (var $ = "", z2 = 0, H = R2.length; z2 < H; z2++)
                  R2.charCodeAt(z2) > 127 ? $ += "x" : $ += R2[z2];
                if (!$.match(f5)) {
                  var L2 = k2.slice(0, w2), Z = k2.slice(w2 + 1), _2 = R2.match(m3);
                  _2 && (L2.push(_2[1]), Z.unshift(_2[2])), Z.length && (O3 = "/" + Z.join(".") + O3), this.hostname = L2.join(".");
                  break;
                }
              }
            }
          this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U2 || (this.hostname = e6.toASCII(this.hostname));
          var E2 = this.port ? ":" + this.port : "", P2 = this.hostname || "";
          this.host = P2 + E2, this.href += this.host, U2 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O3[0] && (O3 = "/" + O3));
        }
        if (!v3[q])
          for (w2 = 0, S2 = p5.length; w2 < S2; w2++) {
            var T3 = p5[w2];
            if (-1 !== O3.indexOf(T3)) {
              var B2 = encodeURIComponent(T3);
              B2 === T3 && (B2 = escape(T3)), O3 = O3.split(T3).join(B2);
            }
          }
        var D2 = O3.indexOf("#");
        -1 !== D2 && (this.hash = O3.substr(D2), O3 = O3.slice(0, D2));
        var F2 = O3.indexOf("?");
        if (-1 !== F2 ? (this.search = O3.substr(F2), this.query = O3.substr(F2 + 1), s5 && (this.query = b2.parse(this.query)), O3 = O3.slice(0, F2)) : s5 && (this.search = "", this.query = {}), O3 && (this.pathname = O3), y3[q] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          E2 = this.pathname || "";
          var G = this.search || "";
          this.path = E2 + G;
        }
        return this.href = this.format(), this;
      }, r6.prototype.format = function() {
        var t6 = this.auth || "";
        t6 && (t6 = (t6 = encodeURIComponent(t6)).replace(/%3A/i, ":"), t6 += "@");
        var s5 = this.protocol || "", h6 = this.pathname || "", e7 = this.hash || "", r7 = false, o7 = "";
        this.host ? r7 = t6 + this.host : this.hostname && (r7 = t6 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r7 += ":" + this.port)), this.query && a5.isObject(this.query) && Object.keys(this.query).length && (o7 = b2.stringify(this.query));
        var n7 = this.search || o7 && "?" + o7 || "";
        return s5 && ":" !== s5.substr(-1) && (s5 += ":"), this.slashes || (!s5 || y3[s5]) && false !== r7 ? (r7 = "//" + (r7 || ""), h6 && "/" !== h6.charAt(0) && (h6 = "/" + h6)) : r7 || (r7 = ""), e7 && "#" !== e7.charAt(0) && (e7 = "#" + e7), n7 && "?" !== n7.charAt(0) && (n7 = "?" + n7), s5 + r7 + (h6 = h6.replace(/[?#]/g, function(t7) {
          return encodeURIComponent(t7);
        })) + (n7 = n7.replace("#", "%23")) + e7;
      }, r6.prototype.resolve = function(t6) {
        return this.resolveObject(O2(t6, false, true)).format();
      }, r6.prototype.resolveObject = function(t6) {
        if (a5.isString(t6)) {
          var s5 = new r6();
          s5.parse(t6, false, true), t6 = s5;
        }
        for (var h6 = new r6(), e7 = Object.keys(this), o7 = 0; o7 < e7.length; o7++) {
          var n7 = e7[o7];
          h6[n7] = this[n7];
        }
        if (h6.hash = t6.hash, "" === t6.href)
          return h6.href = h6.format(), h6;
        if (t6.slashes && !t6.protocol) {
          for (var i6 = Object.keys(t6), l6 = 0; l6 < i6.length; l6++) {
            var p6 = i6[l6];
            "protocol" !== p6 && (h6[p6] = t6[p6]);
          }
          return y3[h6.protocol] && h6.hostname && !h6.pathname && (h6.path = h6.pathname = "/"), h6.href = h6.format(), h6;
        }
        if (t6.protocol && t6.protocol !== h6.protocol) {
          if (!y3[t6.protocol]) {
            for (var c6 = Object.keys(t6), u6 = 0; u6 < c6.length; u6++) {
              var f6 = c6[u6];
              h6[f6] = t6[f6];
            }
            return h6.href = h6.format(), h6;
          }
          if (h6.protocol = t6.protocol, t6.host || g2[t6.protocol])
            h6.pathname = t6.pathname;
          else {
            for (var m4 = (t6.pathname || "").split("/"); m4.length && !(t6.host = m4.shift()); )
              ;
            t6.host || (t6.host = ""), t6.hostname || (t6.hostname = ""), "" !== m4[0] && m4.unshift(""), m4.length < 2 && m4.unshift(""), h6.pathname = m4.join("/");
          }
          if (h6.search = t6.search, h6.query = t6.query, h6.host = t6.host || "", h6.auth = t6.auth, h6.hostname = t6.hostname || t6.host, h6.port = t6.port, h6.pathname || h6.search) {
            var v4 = h6.pathname || "", b3 = h6.search || "";
            h6.path = v4 + b3;
          }
          return h6.slashes = h6.slashes || t6.slashes, h6.href = h6.format(), h6;
        }
        var O3 = h6.pathname && "/" === h6.pathname.charAt(0), d4 = t6.host || t6.pathname && "/" === t6.pathname.charAt(0), j2 = d4 || O3 || h6.host && t6.pathname, q = j2, x2 = h6.pathname && h6.pathname.split("/") || [], A2 = (m4 = t6.pathname && t6.pathname.split("/") || [], h6.protocol && !y3[h6.protocol]);
        if (A2 && (h6.hostname = "", h6.port = null, h6.host && ("" === x2[0] ? x2[0] = h6.host : x2.unshift(h6.host)), h6.host = "", t6.protocol && (t6.hostname = null, t6.port = null, t6.host && ("" === m4[0] ? m4[0] = t6.host : m4.unshift(t6.host)), t6.host = null), j2 = j2 && ("" === m4[0] || "" === x2[0])), d4)
          h6.host = t6.host || "" === t6.host ? t6.host : h6.host, h6.hostname = t6.hostname || "" === t6.hostname ? t6.hostname : h6.hostname, h6.search = t6.search, h6.query = t6.query, x2 = m4;
        else if (m4.length)
          x2 || (x2 = []), x2.pop(), x2 = x2.concat(m4), h6.search = t6.search, h6.query = t6.query;
        else if (!a5.isNullOrUndefined(t6.search)) {
          if (A2)
            h6.hostname = h6.host = x2.shift(), (U2 = !!(h6.host && h6.host.indexOf("@") > 0) && h6.host.split("@")) && (h6.auth = U2.shift(), h6.host = h6.hostname = U2.shift());
          return h6.search = t6.search, h6.query = t6.query, a5.isNull(h6.pathname) && a5.isNull(h6.search) || (h6.path = (h6.pathname ? h6.pathname : "") + (h6.search ? h6.search : "")), h6.href = h6.format(), h6;
        }
        if (!x2.length)
          return h6.pathname = null, h6.search ? h6.path = "/" + h6.search : h6.path = null, h6.href = h6.format(), h6;
        for (var C2 = x2.slice(-1)[0], I2 = (h6.host || t6.host || x2.length > 1) && ("." === C2 || ".." === C2) || "" === C2, w2 = 0, N2 = x2.length; N2 >= 0; N2--)
          "." === (C2 = x2[N2]) ? x2.splice(N2, 1) : ".." === C2 ? (x2.splice(N2, 1), w2++) : w2 && (x2.splice(N2, 1), w2--);
        if (!j2 && !q)
          for (; w2--; w2)
            x2.unshift("..");
        !j2 || "" === x2[0] || x2[0] && "/" === x2[0].charAt(0) || x2.unshift(""), I2 && "/" !== x2.join("/").substr(-1) && x2.push("");
        var U2, k2 = "" === x2[0] || x2[0] && "/" === x2[0].charAt(0);
        A2 && (h6.hostname = h6.host = k2 ? "" : x2.length ? x2.shift() : "", (U2 = !!(h6.host && h6.host.indexOf("@") > 0) && h6.host.split("@")) && (h6.auth = U2.shift(), h6.host = h6.hostname = U2.shift()));
        return (j2 = j2 || h6.host && x2.length) && !k2 && x2.unshift(""), x2.length ? h6.pathname = x2.join("/") : (h6.pathname = null, h6.path = null), a5.isNull(h6.pathname) && a5.isNull(h6.search) || (h6.path = (h6.pathname ? h6.pathname : "") + (h6.search ? h6.search : "")), h6.auth = t6.auth || h6.auth, h6.slashes = h6.slashes || t6.slashes, h6.href = h6.format(), h6;
      }, r6.prototype.parseHost = function() {
        var t6 = this.host, s5 = n6.exec(t6);
        s5 && (":" !== (s5 = s5[0]) && (this.port = s5.substr(1)), t6 = t6.substr(0, t6.length - s5.length)), t6 && (this.hostname = t6);
      };
      h5.Url;
      h5.format;
      h5.resolve;
      h5.resolveObject;
      exports4 = {};
      _dewExec4 = false;
      path = dew4();
      processPlatform$1 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
      h5.URL = typeof URL !== "undefined" ? URL : null;
      h5.pathToFileURL = pathToFileURL$1;
      h5.fileURLToPath = fileURLToPath$1;
      h5.Url;
      h5.format;
      h5.resolve;
      h5.resolveObject;
      h5.URL;
      CHAR_BACKWARD_SLASH$1 = 92;
      CHAR_FORWARD_SLASH$1 = 47;
      CHAR_LOWERCASE_A$1 = 97;
      CHAR_LOWERCASE_Z$1 = 122;
      isWindows$1 = processPlatform$1 === "win32";
      forwardSlashRegEx$1 = /\//g;
      percentRegEx$1 = /%/g;
      backslashRegEx$1 = /\\/g;
      newlineRegEx$1 = /\n/g;
      carriageReturnRegEx$1 = /\r/g;
      tabRegEx$1 = /\t/g;
      processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
      h5.URL = typeof URL !== "undefined" ? URL : null;
      h5.pathToFileURL = pathToFileURL;
      h5.fileURLToPath = fileURLToPath;
      Url = h5.Url;
      format = h5.format;
      resolve = h5.resolve;
      resolveObject = h5.resolveObject;
      parse = h5.parse;
      _URL = h5.URL;
      CHAR_BACKWARD_SLASH = 92;
      CHAR_FORWARD_SLASH = 47;
      CHAR_LOWERCASE_A = 97;
      CHAR_LOWERCASE_Z = 122;
      isWindows = processPlatform === "win32";
      forwardSlashRegEx = /\//g;
      percentRegEx = /%/g;
      backslashRegEx = /\\/g;
      newlineRegEx = /\n/g;
      carriageReturnRegEx = /\r/g;
      tabRegEx = /\t/g;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/net.js
  var net_exports = {};
  __export(net_exports, {
    Server: () => unimplemented2,
    Socket: () => unimplemented2,
    Stream: () => unimplemented2,
    _createServerHandle: () => unimplemented2,
    _normalizeArgs: () => unimplemented2,
    _setSimultaneousAccepts: () => unimplemented2,
    connect: () => unimplemented2,
    createConnection: () => unimplemented2,
    createServer: () => unimplemented2,
    default: () => net,
    isIP: () => unimplemented2,
    isIPv4: () => unimplemented2,
    isIPv6: () => unimplemented2
  });
  function unimplemented2() {
    throw new Error("Node.js net module is not supported by JSPM core outside of Node.js");
  }
  var net;
  var init_net = __esm({
    "node_modules/@jspm/core/nodelibs/browser/net.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      net = {
        _createServerHandle: unimplemented2,
        _normalizeArgs: unimplemented2,
        _setSimultaneousAccepts: unimplemented2,
        connect: unimplemented2,
        createConnection: unimplemented2,
        createServer: unimplemented2,
        isIP: unimplemented2,
        isIPv4: unimplemented2,
        isIPv6: unimplemented2,
        Server: unimplemented2,
        Socket: unimplemented2,
        Stream: unimplemented2
      };
    }
  });

  // build/lib/connect/tcp.js
  var require_tcp = __commonJS({
    "build/lib/connect/tcp.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var __importDefault = exports5 && exports5.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      var net_1 = __importDefault((init_net(), __toCommonJS(net_exports)));
      var debug_1 = __importDefault(require_browser4());
      var debug = (0, debug_1.default)("mqttjs:tcp");
      var buildStream = (client, opts) => {
        opts.port = opts.port || 1883;
        opts.hostname = opts.hostname || opts.host || "localhost";
        const { port, path: path2 } = opts;
        const host = opts.hostname;
        debug("port %d and host %s", port, host);
        return net_1.default.createConnection({ port, host, path: path2 });
      };
      exports5.default = buildStream;
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js
  var empty_exports = {};
  __export(empty_exports, {
    default: () => empty_default
  });
  var empty_default;
  var init_empty = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js"() {
      init_buffer2();
      init_process2();
      init_navigator();
      empty_default = {};
    }
  });

  // build/lib/connect/tls.js
  var require_tls = __commonJS({
    "build/lib/connect/tls.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var __importDefault = exports5 && exports5.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      var tls_1 = __importDefault((init_empty(), __toCommonJS(empty_exports)));
      var net_1 = __importDefault((init_net(), __toCommonJS(net_exports)));
      var debug_1 = __importDefault(require_browser4());
      var debug = (0, debug_1.default)("mqttjs:tls");
      var buildStream = (client, opts) => {
        opts.port = opts.port || 8883;
        opts.host = opts.hostname || opts.host || "localhost";
        if (net_1.default.isIP(opts.host) === 0) {
          opts.servername = opts.host;
        }
        opts.rejectUnauthorized = opts.rejectUnauthorized !== false;
        delete opts.path;
        debug("port %d host %s rejectUnauthorized %b", opts.port, opts.host, opts.rejectUnauthorized);
        const connection = tls_1.default.connect(opts);
        connection.on("secureConnect", () => {
          if (opts.rejectUnauthorized && !connection.authorized) {
            connection.emit("error", new Error("TLS not authorized"));
          } else {
            connection.removeListener("error", handleTLSerrors);
          }
        });
        function handleTLSerrors(err) {
          if (opts.rejectUnauthorized) {
            client.emit("error", err);
          }
          connection.end();
        }
        connection.on("error", handleTLSerrors);
        return connection;
      };
      exports5.default = buildStream;
    }
  });

  // build/lib/BufferedDuplex.js
  var require_BufferedDuplex = __commonJS({
    "build/lib/BufferedDuplex.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      exports5.BufferedDuplex = exports5.writev = void 0;
      var readable_stream_1 = require_browser3();
      var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));
      function writev(chunks, cb) {
        const buffers = new Array(chunks.length);
        for (let i6 = 0; i6 < chunks.length; i6++) {
          if (typeof chunks[i6].chunk === "string") {
            buffers[i6] = buffer_1.Buffer.from(chunks[i6].chunk, "utf8");
          } else {
            buffers[i6] = chunks[i6].chunk;
          }
        }
        this._write(buffer_1.Buffer.concat(buffers), "binary", cb);
      }
      exports5.writev = writev;
      var BufferedDuplex = class extends readable_stream_1.Duplex {
        constructor(opts, proxy, socket) {
          super({
            objectMode: true
          });
          this.proxy = proxy;
          this.socket = socket;
          this.writeQueue = [];
          if (!opts.objectMode) {
            this._writev = writev.bind(this);
          }
          this.isSocketOpen = false;
          this.proxy.on("data", (chunk) => {
            this.push(chunk);
          });
        }
        _read(size) {
          this.proxy.read(size);
        }
        _write(chunk, encoding, cb) {
          if (!this.isSocketOpen) {
            this.writeQueue.push({ chunk, encoding, cb });
          } else {
            this.writeToProxy(chunk, encoding, cb);
          }
        }
        _final(callback) {
          this.writeQueue = [];
          this.proxy.end(callback);
        }
        _destroy(err, callback) {
          this.writeQueue = [];
          this.proxy.destroy();
          callback(err);
        }
        socketReady() {
          this.emit("connect");
          this.isSocketOpen = true;
          this.processWriteQueue();
        }
        writeToProxy(chunk, encoding, cb) {
          if (this.proxy.write(chunk, encoding) === false) {
            this.proxy.once("drain", cb);
          } else {
            cb();
          }
        }
        processWriteQueue() {
          while (this.writeQueue.length > 0) {
            const { chunk, encoding, cb } = this.writeQueue.shift();
            this.writeToProxy(chunk, encoding, cb);
          }
        }
      };
      exports5.BufferedDuplex = BufferedDuplex;
    }
  });

  // build/lib/connect/wx.js
  var require_wx = __commonJS({
    "build/lib/connect/wx.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));
      var readable_stream_1 = require_browser3();
      var BufferedDuplex_1 = require_BufferedDuplex();
      var socketTask;
      var proxy;
      var stream;
      function buildProxy() {
        const _proxy = new readable_stream_1.Transform();
        _proxy._write = (chunk, encoding, next) => {
          socketTask.send({
            data: chunk.buffer,
            success() {
              next();
            },
            fail(errMsg) {
              next(new Error(errMsg));
            }
          });
        };
        _proxy._flush = (done) => {
          socketTask.close({
            success() {
              done();
            }
          });
        };
        return _proxy;
      }
      function setDefaultOpts(opts) {
        if (!opts.hostname) {
          opts.hostname = "localhost";
        }
        if (!opts.path) {
          opts.path = "/";
        }
        if (!opts.wsOptions) {
          opts.wsOptions = {};
        }
      }
      function buildUrl(opts, client) {
        const protocol = opts.protocol === "wxs" ? "wss" : "ws";
        let url = `${protocol}://${opts.hostname}${opts.path}`;
        if (opts.port && opts.port !== 80 && opts.port !== 443) {
          url = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`;
        }
        if (typeof opts.transformWsUrl === "function") {
          url = opts.transformWsUrl(url, opts, client);
        }
        return url;
      }
      function bindEventHandler() {
        socketTask.onOpen(() => {
          stream.socketReady();
        });
        socketTask.onMessage((res) => {
          let { data } = res;
          if (data instanceof ArrayBuffer)
            data = buffer_1.Buffer.from(data);
          else
            data = buffer_1.Buffer.from(data, "utf8");
          proxy.push(data);
        });
        socketTask.onClose(() => {
          stream.emit("close");
          stream.end();
          stream.destroy();
        });
        socketTask.onError((error) => {
          const err = new Error(error.errMsg);
          stream.destroy(err);
        });
      }
      var buildStream = (client, opts) => {
        opts.hostname = opts.hostname || opts.host;
        if (!opts.hostname) {
          throw new Error("Could not determine host. Specify host manually.");
        }
        const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
        setDefaultOpts(opts);
        const url = buildUrl(opts, client);
        socketTask = wx.connectSocket({
          url,
          protocols: [websocketSubProtocol]
        });
        proxy = buildProxy();
        stream = new BufferedDuplex_1.BufferedDuplex(opts, proxy, socketTask);
        stream._destroy = (err, cb) => {
          socketTask.close({
            success() {
              if (cb)
                cb(err);
            }
          });
        };
        const destroyRef = stream.destroy;
        stream.destroy = (err, cb) => {
          stream.destroy = destroyRef;
          setTimeout(() => {
            socketTask.close({
              fail() {
                stream._destroy(err, cb);
              }
            });
          }, 0);
          return stream;
        };
        bindEventHandler();
        return stream;
      };
      exports5.default = buildStream;
    }
  });

  // build/lib/connect/ali.js
  var require_ali = __commonJS({
    "build/lib/connect/ali.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      Object.defineProperty(exports5, "__esModule", { value: true });
      var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));
      var readable_stream_1 = require_browser3();
      var BufferedDuplex_1 = require_BufferedDuplex();
      var my;
      var proxy;
      var stream;
      var isInitialized = false;
      function buildProxy() {
        const _proxy = new readable_stream_1.Transform();
        _proxy._write = (chunk, encoding, next) => {
          my.sendSocketMessage({
            data: chunk.buffer,
            success() {
              next();
            },
            fail() {
              next(new Error());
            }
          });
        };
        _proxy._flush = (done) => {
          my.closeSocket({
            success() {
              done();
            }
          });
        };
        return _proxy;
      }
      function setDefaultOpts(opts) {
        if (!opts.hostname) {
          opts.hostname = "localhost";
        }
        if (!opts.path) {
          opts.path = "/";
        }
        if (!opts.wsOptions) {
          opts.wsOptions = {};
        }
      }
      function buildUrl(opts, client) {
        const protocol = opts.protocol === "alis" ? "wss" : "ws";
        let url = `${protocol}://${opts.hostname}${opts.path}`;
        if (opts.port && opts.port !== 80 && opts.port !== 443) {
          url = `${protocol}://${opts.hostname}:${opts.port}${opts.path}`;
        }
        if (typeof opts.transformWsUrl === "function") {
          url = opts.transformWsUrl(url, opts, client);
        }
        return url;
      }
      function bindEventHandler() {
        if (isInitialized)
          return;
        isInitialized = true;
        my.onSocketOpen(() => {
          stream.socketReady();
        });
        my.onSocketMessage((res) => {
          if (typeof res.data === "string") {
            const buffer = buffer_1.Buffer.from(res.data, "base64");
            proxy.push(buffer);
          } else {
            const reader = new FileReader();
            reader.addEventListener("load", () => {
              let data = reader.result;
              if (data instanceof ArrayBuffer)
                data = buffer_1.Buffer.from(data);
              else
                data = buffer_1.Buffer.from(data, "utf8");
              proxy.push(data);
            });
            reader.readAsArrayBuffer(res.data);
          }
        });
        my.onSocketClose(() => {
          stream.end();
          stream.destroy();
        });
        my.onSocketError((err) => {
          stream.destroy(err);
        });
      }
      var buildStream = (client, opts) => {
        opts.hostname = opts.hostname || opts.host;
        if (!opts.hostname) {
          throw new Error("Could not determine host. Specify host manually.");
        }
        const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
        setDefaultOpts(opts);
        const url = buildUrl(opts, client);
        my = opts.my;
        my.connectSocket({
          url,
          protocols: websocketSubProtocol
        });
        proxy = buildProxy();
        stream = new BufferedDuplex_1.BufferedDuplex(opts, proxy, my);
        bindEventHandler();
        return stream;
      };
      exports5.default = buildStream;
    }
  });

  // node_modules/ws/browser.js
  var require_browser5 = __commonJS({
    "node_modules/ws/browser.js"(exports5, module) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      module.exports = function() {
        throw new Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      };
    }
  });

  // build/lib/connect/ws.js
  var require_ws = __commonJS({
    "build/lib/connect/ws.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var __importDefault = exports5 && exports5.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));
      var ws_1 = __importDefault(require_browser5());
      var debug_1 = __importDefault(require_browser4());
      var readable_stream_1 = require_browser3();
      var is_browser_1 = __importDefault(require_is_browser());
      var BufferedDuplex_1 = require_BufferedDuplex();
      var debug = (0, debug_1.default)("mqttjs:ws");
      var WSS_OPTIONS = [
        "rejectUnauthorized",
        "ca",
        "cert",
        "key",
        "pfx",
        "passphrase"
      ];
      function buildUrl(opts, client) {
        let url = `${opts.protocol}://${opts.hostname}:${opts.port}${opts.path}`;
        if (typeof opts.transformWsUrl === "function") {
          url = opts.transformWsUrl(url, opts, client);
        }
        return url;
      }
      function setDefaultOpts(opts) {
        const options = opts;
        if (!opts.hostname) {
          options.hostname = "localhost";
        }
        if (!opts.port) {
          if (opts.protocol === "wss") {
            options.port = 443;
          } else {
            options.port = 80;
          }
        }
        if (!opts.path) {
          options.path = "/";
        }
        if (!opts.wsOptions) {
          options.wsOptions = {};
        }
        if (!is_browser_1.default && opts.protocol === "wss") {
          WSS_OPTIONS.forEach((prop) => {
            if (Object.prototype.hasOwnProperty.call(opts, prop) && !Object.prototype.hasOwnProperty.call(opts.wsOptions, prop)) {
              options.wsOptions[prop] = opts[prop];
            }
          });
        }
        return options;
      }
      function setDefaultBrowserOpts(opts) {
        const options = setDefaultOpts(opts);
        if (!options.hostname) {
          options.hostname = options.host;
        }
        if (!options.hostname) {
          if (typeof document === "undefined") {
            throw new Error("Could not determine host. Specify host manually.");
          }
          const parsed = new URL(document.URL);
          options.hostname = parsed.hostname;
          if (!options.port) {
            options.port = Number(parsed.port);
          }
        }
        if (options.objectMode === void 0) {
          options.objectMode = !(options.binary === true || options.binary === void 0);
        }
        return options;
      }
      function createWebSocket(client, url, opts) {
        debug("createWebSocket");
        debug(`protocol: ${opts.protocolId} ${opts.protocolVersion}`);
        const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
        debug(`creating new Websocket for url: ${url} and protocol: ${websocketSubProtocol}`);
        let socket;
        if (opts.createWebsocket) {
          socket = opts.createWebsocket(url, [websocketSubProtocol], opts);
        } else {
          socket = new ws_1.default(url, [websocketSubProtocol], opts.wsOptions);
        }
        return socket;
      }
      function createBrowserWebSocket(client, opts) {
        const websocketSubProtocol = opts.protocolId === "MQIsdp" && opts.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
        const url = buildUrl(opts, client);
        let socket;
        if (opts.createWebsocket) {
          socket = opts.createWebsocket(url, [websocketSubProtocol], opts);
        } else {
          socket = new WebSocket(url, [websocketSubProtocol]);
        }
        socket.binaryType = "arraybuffer";
        return socket;
      }
      var streamBuilder = (client, opts) => {
        debug("streamBuilder");
        const options = setDefaultOpts(opts);
        const url = buildUrl(options, client);
        const socket = createWebSocket(client, url, options);
        const webSocketStream = ws_1.default.createWebSocketStream(socket, options.wsOptions);
        webSocketStream["url"] = url;
        socket.on("close", () => {
          webSocketStream.destroy();
        });
        return webSocketStream;
      };
      var browserStreamBuilder = (client, opts) => {
        debug("browserStreamBuilder");
        let stream;
        const options = setDefaultBrowserOpts(opts);
        const bufferSize = options.browserBufferSize || 1024 * 512;
        const bufferTimeout = opts.browserBufferTimeout || 1e3;
        const coerceToBuffer = !opts.objectMode;
        const socket = createBrowserWebSocket(client, opts);
        const proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser);
        if (!opts.objectMode) {
          proxy._writev = BufferedDuplex_1.writev.bind(proxy);
        }
        proxy.on("close", () => {
          socket.close();
        });
        const eventListenerSupport = typeof socket.addEventListener !== "undefined";
        if (socket.readyState === socket.OPEN) {
          stream = proxy;
          stream.socket = socket;
        } else {
          stream = new BufferedDuplex_1.BufferedDuplex(opts, proxy, socket);
          if (eventListenerSupport) {
            socket.addEventListener("open", onOpen);
          } else {
            socket.onopen = onOpen;
          }
        }
        if (eventListenerSupport) {
          socket.addEventListener("close", onClose);
          socket.addEventListener("error", onError);
          socket.addEventListener("message", onMessage);
        } else {
          socket.onclose = onClose;
          socket.onerror = onError;
          socket.onmessage = onMessage;
        }
        function buildProxy(pOptions, socketWrite, socketEnd) {
          const _proxy = new readable_stream_1.Transform({
            objectMode: pOptions.objectMode
          });
          _proxy._write = socketWrite;
          _proxy._flush = socketEnd;
          return _proxy;
        }
        function onOpen() {
          debug("WebSocket onOpen");
          if (stream instanceof BufferedDuplex_1.BufferedDuplex) {
            stream.socketReady();
          }
        }
        function onClose(event) {
          debug("WebSocket onClose", event);
          stream.end();
          stream.destroy();
        }
        function onError(err) {
          debug("WebSocket onError", err);
          const error = new Error("WebSocket error");
          error["event"] = err;
          stream.destroy(error);
        }
        function onMessage(event) {
          let { data } = event;
          if (data instanceof ArrayBuffer)
            data = buffer_1.Buffer.from(data);
          else
            data = buffer_1.Buffer.from(data, "utf8");
          proxy.push(data);
        }
        function socketWriteBrowser(chunk, enc, next) {
          if (socket.bufferedAmount > bufferSize) {
            setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);
            return;
          }
          if (coerceToBuffer && typeof chunk === "string") {
            chunk = buffer_1.Buffer.from(chunk, "utf8");
          }
          try {
            socket.send(chunk);
          } catch (err) {
            return next(err);
          }
          next();
        }
        function socketEndBrowser(done) {
          socket.close();
          done();
        }
        return stream;
      };
      exports5.default = is_browser_1.default ? browserStreamBuilder : streamBuilder;
    }
  });

  // build/lib/connect/index.js
  var require_connect = __commonJS({
    "build/lib/connect/index.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var __importDefault = exports5 && exports5.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      exports5.connectAsync = void 0;
      var debug_1 = __importDefault(require_browser4());
      var url_1 = __importDefault((init_url(), __toCommonJS(url_exports)));
      var client_1 = __importDefault(require_client());
      var is_browser_1 = __importDefault(require_is_browser());
      if (typeof (process_exports === null || process_exports === void 0 ? void 0 : process_exports.nextTick) !== "function") {
        process_exports.nextTick = setImmediate;
      }
      var debug = (0, debug_1.default)("mqttjs");
      var protocols = {};
      if (!is_browser_1.default) {
        protocols.mqtt = require_tcp().default;
        protocols.tcp = require_tcp().default;
        protocols.ssl = require_tls().default;
        protocols.tls = protocols.ssl;
        protocols.mqtts = require_tls().default;
      } else {
        protocols.wx = require_wx().default;
        protocols.wxs = require_wx().default;
        protocols.ali = require_ali().default;
        protocols.alis = require_ali().default;
      }
      protocols.ws = require_ws().default;
      protocols.wss = require_ws().default;
      function parseAuthOptions(opts) {
        let matches;
        if (opts.auth) {
          matches = opts.auth.match(/^(.+):(.+)$/);
          if (matches) {
            opts.username = matches[1];
            opts.password = matches[2];
          } else {
            opts.username = opts.auth;
          }
        }
      }
      function connect(brokerUrl, opts) {
        debug("connecting to an MQTT broker...");
        if (typeof brokerUrl === "object" && !opts) {
          opts = brokerUrl;
          brokerUrl = "";
        }
        opts = opts || {};
        if (brokerUrl && typeof brokerUrl === "string") {
          const parsed = url_1.default.parse(brokerUrl, true);
          if (parsed.port != null) {
            parsed.port = Number(parsed.port);
          }
          opts = Object.assign(Object.assign({}, parsed), opts);
          if (opts.protocol === null) {
            throw new Error("Missing protocol");
          }
          opts.protocol = opts.protocol.replace(/:$/, "");
        }
        parseAuthOptions(opts);
        if (opts.query && typeof opts.query.clientId === "string") {
          opts.clientId = opts.query.clientId;
        }
        if (opts.cert && opts.key) {
          if (opts.protocol) {
            if (["mqtts", "wss", "wxs", "alis"].indexOf(opts.protocol) === -1) {
              switch (opts.protocol) {
                case "mqtt":
                  opts.protocol = "mqtts";
                  break;
                case "ws":
                  opts.protocol = "wss";
                  break;
                case "wx":
                  opts.protocol = "wxs";
                  break;
                case "ali":
                  opts.protocol = "alis";
                  break;
                default:
                  throw new Error(`Unknown protocol for secure connection: "${opts.protocol}"!`);
              }
            }
          } else {
            throw new Error("Missing secure protocol key");
          }
        }
        if (!protocols[opts.protocol]) {
          const isSecure = ["mqtts", "wss"].indexOf(opts.protocol) !== -1;
          opts.protocol = [
            "mqtt",
            "mqtts",
            "ws",
            "wss",
            "wx",
            "wxs",
            "ali",
            "alis"
          ].filter((key, index) => {
            if (isSecure && index % 2 === 0) {
              return false;
            }
            return typeof protocols[key] === "function";
          })[0];
        }
        if (opts.clean === false && !opts.clientId) {
          throw new Error("Missing clientId for unclean clients");
        }
        if (opts.protocol) {
          opts.defaultProtocol = opts.protocol;
        }
        function wrapper(client2) {
          if (opts.servers) {
            if (!client2._reconnectCount || client2._reconnectCount === opts.servers.length) {
              client2._reconnectCount = 0;
            }
            opts.host = opts.servers[client2._reconnectCount].host;
            opts.port = opts.servers[client2._reconnectCount].port;
            opts.protocol = !opts.servers[client2._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client2._reconnectCount].protocol;
            opts.hostname = opts.host;
            client2._reconnectCount++;
          }
          debug("calling streambuilder for", opts.protocol);
          return protocols[opts.protocol](client2, opts);
        }
        const client = new client_1.default(wrapper, opts);
        client.on("error", () => {
        });
        return client;
      }
      function connectAsync(brokerUrl, opts, allowRetries = true) {
        return new Promise((resolve2, reject) => {
          const client = connect(brokerUrl, opts);
          const promiseResolutionListeners = {
            connect: (connack) => {
              removePromiseResolutionListeners();
              resolve2(client);
            },
            end: () => {
              removePromiseResolutionListeners();
              resolve2(client);
            },
            error: (err) => {
              removePromiseResolutionListeners();
              client.end();
              reject(err);
            }
          };
          if (allowRetries === false) {
            promiseResolutionListeners.close = () => {
              promiseResolutionListeners.error(new Error("Couldn't connect to server"));
            };
          }
          function removePromiseResolutionListeners() {
            Object.keys(promiseResolutionListeners).forEach((eventName) => {
              client.off(eventName, promiseResolutionListeners[eventName]);
            });
          }
          Object.keys(promiseResolutionListeners).forEach((eventName) => {
            client.on(eventName, promiseResolutionListeners[eventName]);
          });
        });
      }
      exports5.connectAsync = connectAsync;
      exports5.default = connect;
    }
  });

  // build/mqtt.js
  var require_mqtt2 = __commonJS({
    "build/mqtt.js"(exports5) {
      "use strict";
      init_buffer2();
      init_process2();
      init_navigator();
      var __createBinding = exports5 && exports5.__createBinding || (Object.create ? function(o7, m4, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m4, k2);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k2];
          } };
        }
        Object.defineProperty(o7, k22, desc);
      } : function(o7, m4, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o7[k22] = m4[k2];
      });
      var __setModuleDefault = exports5 && exports5.__setModuleDefault || (Object.create ? function(o7, v4) {
        Object.defineProperty(o7, "default", { enumerable: true, value: v4 });
      } : function(o7, v4) {
        o7["default"] = v4;
      });
      var __importStar = exports5 && exports5.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding(result, mod, k2);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = exports5 && exports5.__exportStar || function(m4, exports6) {
        for (var p6 in m4)
          if (p6 !== "default" && !Object.prototype.hasOwnProperty.call(exports6, p6))
            __createBinding(exports6, m4, p6);
      };
      var __importDefault = exports5 && exports5.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      exports5.ReasonCodes = exports5.PingTimer = exports5.UniqueMessageIdProvider = exports5.DefaultMessageIdProvider = exports5.Store = exports5.MqttClient = exports5.connectAsync = exports5.connect = exports5.Client = void 0;
      var client_1 = __importDefault(require_client());
      exports5.MqttClient = client_1.default;
      var default_message_id_provider_1 = __importDefault(require_default_message_id_provider());
      exports5.DefaultMessageIdProvider = default_message_id_provider_1.default;
      var unique_message_id_provider_1 = __importDefault(require_unique_message_id_provider());
      exports5.UniqueMessageIdProvider = unique_message_id_provider_1.default;
      var store_1 = __importDefault(require_store());
      exports5.Store = store_1.default;
      var connect_1 = __importStar(require_connect());
      exports5.connect = connect_1.default;
      Object.defineProperty(exports5, "connectAsync", { enumerable: true, get: function() {
        return connect_1.connectAsync;
      } });
      var PingTimer_1 = __importDefault(require_PingTimer());
      exports5.PingTimer = PingTimer_1.default;
      exports5.Client = client_1.default;
      __exportStar(require_client(), exports5);
      __exportStar(require_shared(), exports5);
      var ack_1 = require_ack();
      Object.defineProperty(exports5, "ReasonCodes", { enumerable: true, get: function() {
        return ack_1.ReasonCodes;
      } });
    }
  });

  // build/index.js
  var require_build = __commonJS({
    "build/index.js"(exports5) {
      init_buffer2();
      init_process2();
      init_navigator();
      var __createBinding = exports5 && exports5.__createBinding || (Object.create ? function(o7, m4, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m4, k2);
        if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m4[k2];
          } };
        }
        Object.defineProperty(o7, k22, desc);
      } : function(o7, m4, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o7[k22] = m4[k2];
      });
      var __setModuleDefault = exports5 && exports5.__setModuleDefault || (Object.create ? function(o7, v4) {
        Object.defineProperty(o7, "default", { enumerable: true, value: v4 });
      } : function(o7, v4) {
        o7["default"] = v4;
      });
      var __importStar = exports5 && exports5.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding(result, mod, k2);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = exports5 && exports5.__exportStar || function(m4, exports6) {
        for (var p6 in m4)
          if (p6 !== "default" && !Object.prototype.hasOwnProperty.call(exports6, p6))
            __createBinding(exports6, m4, p6);
      };
      Object.defineProperty(exports5, "__esModule", { value: true });
      var mqtt = __importStar(require_mqtt2());
      exports5.default = mqtt;
      __exportStar(require_mqtt2(), exports5);
    }
  });
  return require_build();
})();
/*! Bundled license information:

@jspm/core/nodelibs/browser/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
>>>>>>> 729de8f5701c724d8f78bd8da250f66d252ebba9
